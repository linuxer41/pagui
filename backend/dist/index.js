import { createRequire } from "node:module";
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};
var __esm = (fn, res) => () => (fn && (res = fn(fn = 0)), res);
var __require = /* @__PURE__ */ createRequire(import.meta.url);

// node_modules/memoirist/dist/cjs/index.js
var require_cjs = __commonJS((exports, module) => {
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Memoirist: () => Memoirist,
    default: () => src_default
  });
  module.exports = __toCommonJS(src_exports);
  var createNode = (part, inert) => ({
    part,
    store: null,
    inert: inert !== undefined ? new Map(inert.map((child) => [child.part.charCodeAt(0), child])) : null,
    params: null,
    wildcardStore: null
  });
  var cloneNode = (node, part) => ({
    ...node,
    part
  });
  var createParamNode = (paramName) => ({
    paramName,
    store: null,
    inert: null
  });
  var Memoirist = class _Memoirist {
    root = {};
    history = [];
    static regex = {
      static: /:.+?(?=\/|$)/,
      params: /:.+?(?=\/|$)/g
    };
    add(method, path, store) {
      if (typeof path !== "string")
        throw new TypeError("Route path must be a string");
      if (path === "")
        path = "/";
      else if (path[0] !== "/")
        path = `/${path}`;
      this.history.push([method, path, store]);
      const isWildcard = path[path.length - 1] === "*";
      if (isWildcard) {
        path = path.slice(0, -1);
      }
      const inertParts = path.split(_Memoirist.regex.static);
      const paramParts = path.match(_Memoirist.regex.params) || [];
      if (inertParts[inertParts.length - 1] === "")
        inertParts.pop();
      let node;
      if (!this.root[method])
        node = this.root[method] = createNode("/");
      else
        node = this.root[method];
      let paramPartsIndex = 0;
      for (let i = 0;i < inertParts.length; ++i) {
        let part = inertParts[i];
        if (i > 0) {
          const param = paramParts[paramPartsIndex++].slice(1);
          if (node.params === null)
            node.params = createParamNode(param);
          else if (node.params.paramName !== param)
            throw new Error(`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.paramName}") in the same location`);
          const params = node.params;
          if (params.inert === null) {
            node = params.inert = createNode(part);
            continue;
          }
          node = params.inert;
        }
        for (let j = 0;; ) {
          if (j === part.length) {
            if (j < node.part.length) {
              const childNode = cloneNode(node, node.part.slice(j));
              Object.assign(node, createNode(part, [childNode]));
            }
            break;
          }
          if (j === node.part.length) {
            if (node.inert === null)
              node.inert = /* @__PURE__ */ new Map;
            else if (node.inert.has(part.charCodeAt(j))) {
              node = node.inert.get(part.charCodeAt(j));
              part = part.slice(j);
              j = 0;
              continue;
            }
            const childNode = createNode(part.slice(j));
            node.inert.set(part.charCodeAt(j), childNode);
            node = childNode;
            break;
          }
          if (part[j] !== node.part[j]) {
            const existingChild = cloneNode(node, node.part.slice(j));
            const newChild = createNode(part.slice(j));
            Object.assign(node, createNode(node.part.slice(0, j), [
              existingChild,
              newChild
            ]));
            node = newChild;
            break;
          }
          ++j;
        }
      }
      if (paramPartsIndex < paramParts.length) {
        const param = paramParts[paramPartsIndex];
        const paramName = param.slice(1);
        if (node.params === null)
          node.params = createParamNode(paramName);
        else if (node.params.paramName !== paramName)
          throw new Error(`Cannot create route "${path}" with parameter "${paramName}" because a route already exists with a different parameter name ("${node.params.paramName}") in the same location`);
        if (node.params.store === null)
          node.params.store = store;
        return node.params.store;
      }
      if (isWildcard) {
        if (node.wildcardStore === null)
          node.wildcardStore = store;
        return node.wildcardStore;
      }
      if (node.store === null)
        node.store = store;
      return node.store;
    }
    find(method, url) {
      const root = this.root[method];
      if (!root)
        return null;
      return matchRoute(url, url.length, root, 0);
    }
  };
  var matchRoute = (url, urlLength, node, startIndex) => {
    const part = node?.part;
    const endIndex = startIndex + part.length;
    if (part.length > 1) {
      if (endIndex > urlLength)
        return null;
      if (part.length < 15) {
        for (let i = 1, j = startIndex + 1;i < part.length; ++i, ++j)
          if (part.charCodeAt(i) !== url.charCodeAt(j))
            return null;
      } else if (url.substring(startIndex, endIndex) !== part)
        return null;
    }
    if (endIndex === urlLength) {
      if (node.store !== null)
        return {
          store: node.store,
          params: {}
        };
      if (node.wildcardStore !== null)
        return {
          store: node.wildcardStore,
          params: { "*": "" }
        };
      return null;
    }
    if (node.inert !== null) {
      const inert = node.inert.get(url.charCodeAt(endIndex));
      if (inert !== undefined) {
        const route = matchRoute(url, urlLength, inert, endIndex);
        if (route !== null)
          return route;
      }
    }
    if (node.params !== null) {
      const param = node.params;
      const slashIndex = url.indexOf("/", endIndex);
      if (slashIndex !== endIndex) {
        if (slashIndex === -1 || slashIndex >= urlLength) {
          if (param.store !== null) {
            const params = {};
            params[param.paramName] = url.substring(endIndex, urlLength);
            return {
              store: param.store,
              params
            };
          }
        } else if (param.inert !== null) {
          const route = matchRoute(url, urlLength, param.inert, slashIndex);
          if (route !== null) {
            route.params[param.paramName] = url.substring(endIndex, slashIndex);
            return route;
          }
        }
      }
    }
    if (node.wildcardStore !== null)
      return {
        store: node.wildcardStore,
        params: {
          "*": url.substring(endIndex, urlLength)
        }
      };
    return null;
  };
  var src_default = Memoirist;
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {}
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events;
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/guard.js
var require_guard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsIterator = IsIterator;
  exports.IsStandardObject = IsStandardObject;
  exports.IsInstanceObject = IsInstanceObject;
  exports.IsPromise = IsPromise;
  exports.IsDate = IsDate;
  exports.IsMap = IsMap;
  exports.IsSet = IsSet;
  exports.IsRegExp = IsRegExp;
  exports.IsTypedArray = IsTypedArray;
  exports.IsInt8Array = IsInt8Array;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUint8ClampedArray = IsUint8ClampedArray;
  exports.IsInt16Array = IsInt16Array;
  exports.IsUint16Array = IsUint16Array;
  exports.IsInt32Array = IsInt32Array;
  exports.IsUint32Array = IsUint32Array;
  exports.IsFloat32Array = IsFloat32Array;
  exports.IsFloat64Array = IsFloat64Array;
  exports.IsBigInt64Array = IsBigInt64Array;
  exports.IsBigUint64Array = IsBigUint64Array;
  exports.HasPropertyKey = HasPropertyKey;
  exports.IsObject = IsObject;
  exports.IsArray = IsArray;
  exports.IsUndefined = IsUndefined;
  exports.IsNull = IsNull;
  exports.IsBoolean = IsBoolean;
  exports.IsNumber = IsNumber;
  exports.IsInteger = IsInteger;
  exports.IsBigInt = IsBigInt;
  exports.IsString = IsString;
  exports.IsFunction = IsFunction;
  exports.IsSymbol = IsSymbol;
  exports.IsValueType = IsValueType;
  function IsAsyncIterator(value) {
    return IsObject(value) && Symbol.asyncIterator in value;
  }
  function IsIterator(value) {
    return IsObject(value) && Symbol.iterator in value;
  }
  function IsStandardObject(value) {
    return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
  }
  function IsInstanceObject(value) {
    return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name !== "Object";
  }
  function IsPromise(value) {
    return value instanceof Promise;
  }
  function IsDate(value) {
    return value instanceof Date && Number.isFinite(value.getTime());
  }
  function IsMap(value) {
    return value instanceof globalThis.Map;
  }
  function IsSet(value) {
    return value instanceof globalThis.Set;
  }
  function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsTypedArray(value) {
    return ArrayBuffer.isView(value);
  }
  function IsInt8Array(value) {
    return value instanceof globalThis.Int8Array;
  }
  function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUint8ClampedArray(value) {
    return value instanceof globalThis.Uint8ClampedArray;
  }
  function IsInt16Array(value) {
    return value instanceof globalThis.Int16Array;
  }
  function IsUint16Array(value) {
    return value instanceof globalThis.Uint16Array;
  }
  function IsInt32Array(value) {
    return value instanceof globalThis.Int32Array;
  }
  function IsUint32Array(value) {
    return value instanceof globalThis.Uint32Array;
  }
  function IsFloat32Array(value) {
    return value instanceof globalThis.Float32Array;
  }
  function IsFloat64Array(value) {
    return value instanceof globalThis.Float64Array;
  }
  function IsBigInt64Array(value) {
    return value instanceof globalThis.BigInt64Array;
  }
  function IsBigUint64Array(value) {
    return value instanceof globalThis.BigUint64Array;
  }
  function HasPropertyKey(value, key) {
    return key in value;
  }
  function IsObject(value) {
    return value !== null && typeof value === "object";
  }
  function IsArray(value) {
    return Array.isArray(value) && !ArrayBuffer.isView(value);
  }
  function IsUndefined(value) {
    return value === undefined;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsInteger(value) {
    return Number.isInteger(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsValueType(value) {
    return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/guard/index.js
var require_guard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_guard(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/system/policy.js
var require_policy = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystemPolicy = undefined;
  var index_1 = require_guard2();
  var TypeSystemPolicy;
  (function(TypeSystemPolicy2) {
    TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
    TypeSystemPolicy2.AllowArrayObject = false;
    TypeSystemPolicy2.AllowNaN = false;
    TypeSystemPolicy2.AllowNullVoid = false;
    function IsExactOptionalProperty(value, key) {
      return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
    }
    TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      const isObject = (0, index_1.IsObject)(value);
      return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !(0, index_1.IsArray)(value);
    }
    TypeSystemPolicy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
    }
    TypeSystemPolicy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return TypeSystemPolicy2.AllowNaN ? (0, index_1.IsNumber)(value) : Number.isFinite(value);
    }
    TypeSystemPolicy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      const isUndefined = (0, index_1.IsUndefined)(value);
      return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
    }
    TypeSystemPolicy2.IsVoidLike = IsVoidLike;
  })(TypeSystemPolicy || (exports.TypeSystemPolicy = TypeSystemPolicy = {}));
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entries = Entries;
  exports.Clear = Clear;
  exports.Delete = Delete;
  exports.Has = Has;
  exports.Set = Set2;
  exports.Get = Get;
  var map = new Map;
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(format) {
    return map.delete(format);
  }
  function Has(format) {
    return map.has(format);
  }
  function Set2(format, func) {
    map.set(format, func);
  }
  function Get(format) {
    return map.get(format);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/type.js
var require_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Entries = Entries;
  exports.Clear = Clear;
  exports.Delete = Delete;
  exports.Has = Has;
  exports.Set = Set2;
  exports.Get = Get;
  var map = new Map;
  function Entries() {
    return new Map(map);
  }
  function Clear() {
    return map.clear();
  }
  function Delete(kind) {
    return map.delete(kind);
  }
  function Has(kind) {
    return map.has(kind);
  }
  function Set2(kind, func) {
    map.set(kind, func);
  }
  function Get(kind) {
    return map.get(kind);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/registry/index.js
var require_registry = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeRegistry = exports.FormatRegistry = undefined;
  exports.FormatRegistry = require_format();
  exports.TypeRegistry = require_type();
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/symbols.js
var require_symbols = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Kind = exports.Hint = exports.OptionalKind = exports.ReadonlyKind = exports.TransformKind = undefined;
  exports.TransformKind = Symbol.for("TypeBox.Transform");
  exports.ReadonlyKind = Symbol.for("TypeBox.Readonly");
  exports.OptionalKind = Symbol.for("TypeBox.Optional");
  exports.Hint = Symbol.for("TypeBox.Hint");
  exports.Kind = Symbol.for("TypeBox.Kind");
});

// node_modules/@sinclair/typebox/build/cjs/type/symbols/index.js
var require_symbols2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbols(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/unsafe.js
var require_unsafe = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unsafe = Unsafe;
  var index_1 = require_symbols2();
  function Unsafe(options = {}) {
    return {
      ...options,
      [index_1.Kind]: options[index_1.Kind] ?? "Unsafe"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unsafe/index.js
var require_unsafe2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unsafe(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/error/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeBoxError = undefined;

  class TypeBoxError extends Error {
    constructor(message) {
      super(message);
    }
  }
  exports.TypeBoxError = TypeBoxError;
});

// node_modules/@sinclair/typebox/build/cjs/type/error/index.js
var require_error2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_error(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/system/system.js
var require_system = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeSystem = exports.TypeSystemDuplicateFormat = exports.TypeSystemDuplicateTypeKind = undefined;
  var index_1 = require_registry();
  var index_2 = require_unsafe2();
  var index_3 = require_symbols2();
  var index_4 = require_error2();

  class TypeSystemDuplicateTypeKind extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate type kind '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;

  class TypeSystemDuplicateFormat extends index_4.TypeBoxError {
    constructor(kind) {
      super(`Duplicate string format '${kind}' detected`);
    }
  }
  exports.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
  var TypeSystem;
  (function(TypeSystem2) {
    function Type(kind, check) {
      if (index_1.TypeRegistry.Has(kind))
        throw new TypeSystemDuplicateTypeKind(kind);
      index_1.TypeRegistry.Set(kind, check);
      return (options = {}) => (0, index_2.Unsafe)({ ...options, [index_3.Kind]: kind });
    }
    TypeSystem2.Type = Type;
    function Format(format, check) {
      if (index_1.FormatRegistry.Has(format))
        throw new TypeSystemDuplicateFormat(format);
      index_1.FormatRegistry.Set(format, check);
      return format;
    }
    TypeSystem2.Format = Format;
  })(TypeSystem || (exports.TypeSystem = TypeSystem = {}));
});

// node_modules/@sinclair/typebox/build/cjs/system/index.js
var require_system2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_policy(), exports);
  __exportStar(require_system(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-key.js
var require_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedKey = MappedKey;
  var index_1 = require_symbols2();
  function MappedKey(T) {
    return {
      [index_1.Kind]: "MappedKey",
      keys: T
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped-result.js
var require_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedResult = MappedResult;
  var index_1 = require_symbols2();
  function MappedResult(properties) {
    return {
      [index_1.Kind]: "MappedResult",
      properties
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/value.js
var require_value = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsArray = IsArray;
  exports.IsBigInt = IsBigInt;
  exports.IsBoolean = IsBoolean;
  exports.IsDate = IsDate;
  exports.IsFunction = IsFunction;
  exports.IsIterator = IsIterator;
  exports.IsNull = IsNull;
  exports.IsNumber = IsNumber;
  exports.IsObject = IsObject;
  exports.IsRegExp = IsRegExp;
  exports.IsString = IsString;
  exports.IsSymbol = IsSymbol;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUndefined = IsUndefined;
  function IsAsyncIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.asyncIterator in value;
  }
  function IsArray(value) {
    return Array.isArray(value);
  }
  function IsBigInt(value) {
    return typeof value === "bigint";
  }
  function IsBoolean(value) {
    return typeof value === "boolean";
  }
  function IsDate(value) {
    return value instanceof globalThis.Date;
  }
  function IsFunction(value) {
    return typeof value === "function";
  }
  function IsIterator(value) {
    return IsObject(value) && !IsArray(value) && !IsUint8Array(value) && Symbol.iterator in value;
  }
  function IsNull(value) {
    return value === null;
  }
  function IsNumber(value) {
    return typeof value === "number";
  }
  function IsObject(value) {
    return typeof value === "object" && value !== null;
  }
  function IsRegExp(value) {
    return value instanceof globalThis.RegExp;
  }
  function IsString(value) {
    return typeof value === "string";
  }
  function IsSymbol(value) {
    return typeof value === "symbol";
  }
  function IsUint8Array(value) {
    return value instanceof globalThis.Uint8Array;
  }
  function IsUndefined(value) {
    return value === undefined;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/value.js
var require_value2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = Clone;
  var ValueGuard = require_value();
  function ArrayType(value) {
    return value.map((value2) => Visit(value2));
  }
  function DateType(value) {
    return new Date(value.getTime());
  }
  function Uint8ArrayType(value) {
    return new Uint8Array(value);
  }
  function RegExpType(value) {
    return new RegExp(value.source, value.flags);
  }
  function ObjectType(value) {
    const result = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      result[key] = Visit(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      result[key] = Visit(value[key]);
    }
    return result;
  }
  function Visit(value) {
    return ValueGuard.IsArray(value) ? ArrayType(value) : ValueGuard.IsDate(value) ? DateType(value) : ValueGuard.IsUint8Array(value) ? Uint8ArrayType(value) : ValueGuard.IsRegExp(value) ? RegExpType(value) : ValueGuard.IsObject(value) ? ObjectType(value) : value;
  }
  function Clone(value) {
    return Visit(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/type.js
var require_type2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CloneRest = CloneRest;
  exports.CloneType = CloneType;
  var value_1 = require_value2();
  function CloneRest(schemas) {
    return schemas.map((schema) => CloneType(schema));
  }
  function CloneType(schema, options = {}) {
    return { ...(0, value_1.Clone)(schema), ...options };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/discard.js
var require_discard = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Discard = Discard;
  function DiscardKey(value, key) {
    const { [key]: _, ...rest } = value;
    return rest;
  }
  function Discard(value, keys) {
    return keys.reduce((acc, key) => DiscardKey(acc, key), value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/discard/index.js
var require_discard2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_discard(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/array/array.js
var require_array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Array = Array2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Array2(schema, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Array",
      type: "array",
      items: (0, type_1.CloneType)(schema)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/array/index.js
var require_array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_array(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/async-iterator.js
var require_async_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.AsyncIterator = AsyncIterator;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  function AsyncIterator(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "AsyncIterator",
      type: "AsyncIterator",
      items: (0, type_1.CloneType)(items)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/async-iterator/index.js
var require_async_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_async_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/constructor.js
var require_constructor = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Constructor = Constructor;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Constructor(parameters, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Constructor",
      type: "Constructor",
      parameters: (0, type_1.CloneRest)(parameters),
      returns: (0, type_1.CloneType)(returns)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor/index.js
var require_constructor2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/function/function.js
var require_function = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Function = Function2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Function2(parameters, returns, options) {
    return {
      ...options,
      [index_1.Kind]: "Function",
      type: "Function",
      parameters: (0, type_1.CloneRest)(parameters),
      returns: (0, type_1.CloneType)(returns)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/function/index.js
var require_function2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_function(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/never/never.js
var require_never = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Never = Never;
  var index_1 = require_symbols2();
  function Never(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Never",
      not: {}
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/never/index.js
var require_never2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_never(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/kind.js
var require_kind = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IsReadonly = IsReadonly;
  exports.IsOptional = IsOptional;
  exports.IsAny = IsAny;
  exports.IsArray = IsArray;
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsBigInt = IsBigInt;
  exports.IsBoolean = IsBoolean;
  exports.IsConstructor = IsConstructor;
  exports.IsDate = IsDate;
  exports.IsFunction = IsFunction;
  exports.IsInteger = IsInteger;
  exports.IsProperties = IsProperties;
  exports.IsIntersect = IsIntersect;
  exports.IsIterator = IsIterator;
  exports.IsKindOf = IsKindOf;
  exports.IsLiteralString = IsLiteralString;
  exports.IsLiteralNumber = IsLiteralNumber;
  exports.IsLiteralBoolean = IsLiteralBoolean;
  exports.IsLiteral = IsLiteral;
  exports.IsMappedKey = IsMappedKey;
  exports.IsMappedResult = IsMappedResult;
  exports.IsNever = IsNever;
  exports.IsNot = IsNot;
  exports.IsNull = IsNull;
  exports.IsNumber = IsNumber;
  exports.IsObject = IsObject;
  exports.IsPromise = IsPromise;
  exports.IsRecord = IsRecord;
  exports.IsRecursive = IsRecursive;
  exports.IsRef = IsRef;
  exports.IsRegExp = IsRegExp;
  exports.IsString = IsString;
  exports.IsSymbol = IsSymbol;
  exports.IsTemplateLiteral = IsTemplateLiteral;
  exports.IsThis = IsThis;
  exports.IsTransform = IsTransform;
  exports.IsTuple = IsTuple;
  exports.IsUndefined = IsUndefined;
  exports.IsUnion = IsUnion;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUnknown = IsUnknown;
  exports.IsUnsafe = IsUnsafe;
  exports.IsVoid = IsVoid;
  exports.IsKind = IsKind;
  exports.IsSchema = IsSchema;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value) {
    return IsKindOf(value, "Any");
  }
  function IsArray(value) {
    return IsKindOf(value, "Array");
  }
  function IsAsyncIterator(value) {
    return IsKindOf(value, "AsyncIterator");
  }
  function IsBigInt(value) {
    return IsKindOf(value, "BigInt");
  }
  function IsBoolean(value) {
    return IsKindOf(value, "Boolean");
  }
  function IsConstructor(value) {
    return IsKindOf(value, "Constructor");
  }
  function IsDate(value) {
    return IsKindOf(value, "Date");
  }
  function IsFunction(value) {
    return IsKindOf(value, "Function");
  }
  function IsInteger(value) {
    return IsKindOf(value, "Integer");
  }
  function IsProperties(value) {
    return ValueGuard.IsObject(value);
  }
  function IsIntersect(value) {
    return IsKindOf(value, "Intersect");
  }
  function IsIterator(value) {
    return IsKindOf(value, "Iterator");
  }
  function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral(value) {
    return IsKindOf(value, "Literal");
  }
  function IsMappedKey(value) {
    return IsKindOf(value, "MappedKey");
  }
  function IsMappedResult(value) {
    return IsKindOf(value, "MappedResult");
  }
  function IsNever(value) {
    return IsKindOf(value, "Never");
  }
  function IsNot(value) {
    return IsKindOf(value, "Not");
  }
  function IsNull(value) {
    return IsKindOf(value, "Null");
  }
  function IsNumber(value) {
    return IsKindOf(value, "Number");
  }
  function IsObject(value) {
    return IsKindOf(value, "Object");
  }
  function IsPromise(value) {
    return IsKindOf(value, "Promise");
  }
  function IsRecord(value) {
    return IsKindOf(value, "Record");
  }
  function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef(value) {
    return IsKindOf(value, "Ref");
  }
  function IsRegExp(value) {
    return IsKindOf(value, "RegExp");
  }
  function IsString(value) {
    return IsKindOf(value, "String");
  }
  function IsSymbol(value) {
    return IsKindOf(value, "Symbol");
  }
  function IsTemplateLiteral(value) {
    return IsKindOf(value, "TemplateLiteral");
  }
  function IsThis(value) {
    return IsKindOf(value, "This");
  }
  function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple(value) {
    return IsKindOf(value, "Tuple");
  }
  function IsUndefined(value) {
    return IsKindOf(value, "Undefined");
  }
  function IsUnion(value) {
    return IsKindOf(value, "Union");
  }
  function IsUint8Array(value) {
    return IsKindOf(value, "Uint8Array");
  }
  function IsUnknown(value) {
    return IsKindOf(value, "Unknown");
  }
  function IsUnsafe(value) {
    return IsKindOf(value, "Unsafe");
  }
  function IsVoid(value) {
    return IsKindOf(value, "Void");
  }
  function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]);
  }
  function IsSchema(value) {
    return IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional.js
var require_optional = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Optional = Optional;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var optional_from_mapped_result_1 = require_optional_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveOptional(schema) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.OptionalKind]);
  }
  function AddOptional(schema) {
    return { ...(0, type_1.CloneType)(schema), [index_1.OptionalKind]: "Optional" };
  }
  function OptionalWithFlag(schema, F) {
    return F === false ? RemoveOptional(schema) : AddOptional(schema);
  }
  function Optional(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, optional_from_mapped_result_1.OptionalFromMappedResult)(schema, F) : OptionalWithFlag(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/optional-from-mapped-result.js
var require_optional_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OptionalFromMappedResult = OptionalFromMappedResult;
  var index_1 = require_mapped2();
  var optional_1 = require_optional();
  function FromProperties(P, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, optional_1.Optional)(P[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function OptionalFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/optional/index.js
var require_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_optional_from_mapped_result(), exports);
  __exportStar(require_optional(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-create.js
var require_intersect_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectCreate = IntersectCreate;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function IntersectCreate(T, options) {
    const allObjects = T.every((schema) => (0, kind_1.IsObject)(schema));
    const clonedUnevaluatedProperties = (0, kind_1.IsSchema)(options.unevaluatedProperties) ? { unevaluatedProperties: (0, type_1.CloneType)(options.unevaluatedProperties) } : {};
    return options.unevaluatedProperties === false || (0, kind_1.IsSchema)(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", type: "object", allOf: (0, type_1.CloneRest)(T) } : { ...options, ...clonedUnevaluatedProperties, [index_1.Kind]: "Intersect", allOf: (0, type_1.CloneRest)(T) };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-evaluated.js
var require_intersect_evaluated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntersectEvaluated = IntersectEvaluated;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never2();
  var index_4 = require_optional2();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function IsIntersectOptional(T) {
    return T.every((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function ResolveIntersect(T, options) {
    return IsIntersectOptional(T) ? (0, index_4.Optional)((0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options)) : (0, intersect_create_1.IntersectCreate)(RemoveOptionalFromRest(T), options);
  }
  function IntersectEvaluated(T, options = {}) {
    if (T.length === 0)
      return (0, index_3.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return ResolveIntersect(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect-type.js
var require_intersect_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/intersect.js
var require_intersect = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intersect = Intersect;
  var type_1 = require_type2();
  var index_1 = require_never2();
  var intersect_create_1 = require_intersect_create();
  var kind_1 = require_kind();
  function Intersect(T, options = {}) {
    if (T.length === 0)
      return (0, index_1.Never)(options);
    if (T.length === 1)
      return (0, type_1.CloneType)(T[0], options);
    if (T.some((schema) => (0, kind_1.IsTransform)(schema)))
      throw new Error("Cannot intersect transform types");
    return (0, intersect_create_1.IntersectCreate)(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intersect/index.js
var require_intersect2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_intersect_evaluated(), exports);
  __exportStar(require_intersect_type(), exports);
  __exportStar(require_intersect(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-create.js
var require_union_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionCreate = UnionCreate;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function UnionCreate(T, options) {
    return { ...options, [index_1.Kind]: "Union", anyOf: (0, type_1.CloneRest)(T) };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-evaluated.js
var require_union_evaluated = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UnionEvaluated = UnionEvaluated;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_never2();
  var index_4 = require_optional2();
  var union_create_1 = require_union_create();
  var kind_1 = require_kind();
  function IsUnionOptional(T) {
    return T.some((L) => (0, kind_1.IsOptional)(L));
  }
  function RemoveOptionalFromRest(T) {
    return T.map((L) => (0, kind_1.IsOptional)(L) ? RemoveOptionalFromType(L) : L);
  }
  function RemoveOptionalFromType(T) {
    return (0, index_2.Discard)(T, [index_1.OptionalKind]);
  }
  function ResolveUnion(T, options) {
    return IsUnionOptional(T) ? (0, index_4.Optional)((0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options)) : (0, union_create_1.UnionCreate)(RemoveOptionalFromRest(T), options);
  }
  function UnionEvaluated(T, options = {}) {
    return T.length === 0 ? (0, index_3.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : ResolveUnion(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union-type.js
var require_union_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/union/union.js
var require_union = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Union = Union;
  var index_1 = require_never2();
  var type_1 = require_type2();
  var union_create_1 = require_union_create();
  function Union(T, options = {}) {
    return T.length === 0 ? (0, index_1.Never)(options) : T.length === 1 ? (0, type_1.CloneType)(T[0], options) : (0, union_create_1.UnionCreate)(T, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/union/index.js
var require_union2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_union_evaluated(), exports);
  __exportStar(require_union_type(), exports);
  __exportStar(require_union(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralParserError = undefined;
  exports.TemplateLiteralParse = TemplateLiteralParse;
  exports.TemplateLiteralParseExact = TemplateLiteralParseExact;
  var index_1 = require_error2();

  class TemplateLiteralParserError extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralParserError = TemplateLiteralParserError;
  function Unescape(pattern) {
    return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  }
  function IsNonEscaped(pattern, index, char) {
    return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
  }
  function IsOpenParen(pattern, index) {
    return IsNonEscaped(pattern, index, "(");
  }
  function IsCloseParen(pattern, index) {
    return IsNonEscaped(pattern, index, ")");
  }
  function IsSeparator(pattern, index) {
    return IsNonEscaped(pattern, index, "|");
  }
  function IsGroup(pattern) {
    if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
      return false;
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (count === 0 && index !== pattern.length - 1)
        return false;
    }
    return true;
  }
  function InGroup(pattern) {
    return pattern.slice(1, pattern.length - 1);
  }
  function IsPrecedenceOr(pattern) {
    let count = 0;
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (IsSeparator(pattern, index) && count === 0)
        return true;
    }
    return false;
  }
  function IsPrecedenceAnd(pattern) {
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        return true;
    }
    return false;
  }
  function Or(pattern) {
    let [count, start] = [0, 0];
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index))
        count += 1;
      if (IsCloseParen(pattern, index))
        count -= 1;
      if (IsSeparator(pattern, index) && count === 0) {
        const range2 = pattern.slice(start, index);
        if (range2.length > 0)
          expressions.push(TemplateLiteralParse(range2));
        start = index + 1;
      }
    }
    const range = pattern.slice(start);
    if (range.length > 0)
      expressions.push(TemplateLiteralParse(range));
    if (expressions.length === 0)
      return { type: "const", const: "" };
    if (expressions.length === 1)
      return expressions[0];
    return { type: "or", expr: expressions };
  }
  function And(pattern) {
    function Group(value, index) {
      if (!IsOpenParen(value, index))
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
      let count = 0;
      for (let scan = index;scan < value.length; scan++) {
        if (IsOpenParen(value, scan))
          count += 1;
        if (IsCloseParen(value, scan))
          count -= 1;
        if (count === 0)
          return [index, scan];
      }
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
    }
    function Range(pattern2, index) {
      for (let scan = index;scan < pattern2.length; scan++) {
        if (IsOpenParen(pattern2, scan))
          return [index, scan];
      }
      return [index, pattern2.length];
    }
    const expressions = [];
    for (let index = 0;index < pattern.length; index++) {
      if (IsOpenParen(pattern, index)) {
        const [start, end] = Group(pattern, index);
        const range = pattern.slice(start, end + 1);
        expressions.push(TemplateLiteralParse(range));
        index = end;
      } else {
        const [start, end] = Range(pattern, index);
        const range = pattern.slice(start, end);
        if (range.length > 0)
          expressions.push(TemplateLiteralParse(range));
        index = end - 1;
      }
    }
    return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
  }
  function TemplateLiteralParse(pattern) {
    return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
  }
  function TemplateLiteralParseExact(pattern) {
    return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/finite.js
var require_finite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralFiniteError = undefined;
  exports.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
  exports.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralFiniteError extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
  function IsNumberExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
  }
  function IsBooleanExpression(expression) {
    return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
  }
  function IsStringExpression(expression) {
    return expression.type === "const" && expression.const === ".*";
  }
  function IsTemplateLiteralExpressionFinite(expression) {
    return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
      throw new TemplateLiteralFiniteError(`Unknown expression type`);
    })();
  }
  function IsTemplateLiteralFinite(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return IsTemplateLiteralExpressionFinite(expression);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/generate.js
var require_generate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralGenerateError = undefined;
  exports.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
  exports.TemplateLiteralGenerate = TemplateLiteralGenerate;
  var finite_1 = require_finite();
  var parse_1 = require_parse();
  var index_1 = require_error2();

  class TemplateLiteralGenerateError extends index_1.TypeBoxError {
  }
  exports.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
  function* GenerateReduce(buffer) {
    if (buffer.length === 1)
      return yield* buffer[0];
    for (const left of buffer[0]) {
      for (const right of GenerateReduce(buffer.slice(1))) {
        yield `${left}${right}`;
      }
    }
  }
  function* GenerateAnd(expression) {
    return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
  }
  function* GenerateOr(expression) {
    for (const expr of expression.expr)
      yield* TemplateLiteralExpressionGenerate(expr);
  }
  function* GenerateConst(expression) {
    return yield expression.const;
  }
  function* TemplateLiteralExpressionGenerate(expression) {
    return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
      throw new TemplateLiteralGenerateError("Unknown expression");
    })();
  }
  function TemplateLiteralGenerate(schema) {
    const expression = (0, parse_1.TemplateLiteralParseExact)(schema.pattern);
    return (0, finite_1.IsTemplateLiteralExpressionFinite)(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/literal.js
var require_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Literal = Literal;
  var index_1 = require_symbols2();
  function Literal(value, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Literal",
      const: value,
      type: typeof value
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/literal/index.js
var require_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_literal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/boolean.js
var require_boolean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Boolean = Boolean2;
  var index_1 = require_symbols2();
  function Boolean2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Boolean",
      type: "boolean"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/boolean/index.js
var require_boolean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_boolean(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/bigint.js
var require_bigint = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BigInt = BigInt2;
  var index_1 = require_symbols2();
  function BigInt2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "BigInt",
      type: "bigint"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/bigint/index.js
var require_bigint2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_bigint(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/number/number.js
var require_number = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Number = Number2;
  var index_1 = require_symbols2();
  function Number2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Number",
      type: "number"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/number/index.js
var require_number2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_number(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/string/string.js
var require_string = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.String = String2;
  var index_1 = require_symbols2();
  function String2(options = {}) {
    return { ...options, [index_1.Kind]: "String", type: "string" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/string/index.js
var require_string2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_string(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/syntax.js
var require_syntax = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralSyntax = TemplateLiteralSyntax;
  var index_1 = require_literal2();
  var index_2 = require_boolean2();
  var index_3 = require_bigint2();
  var index_4 = require_number2();
  var index_5 = require_string2();
  var index_6 = require_union2();
  var index_7 = require_never2();
  function* FromUnion(syntax) {
    const trim = syntax.trim().replace(/"|'/g, "");
    return trim === "boolean" ? yield (0, index_2.Boolean)() : trim === "number" ? yield (0, index_4.Number)() : trim === "bigint" ? yield (0, index_3.BigInt)() : trim === "string" ? yield (0, index_5.String)() : yield (() => {
      const literals = trim.split("|").map((literal) => (0, index_1.Literal)(literal.trim()));
      return literals.length === 0 ? (0, index_7.Never)() : literals.length === 1 ? literals[0] : (0, index_6.UnionEvaluated)(literals);
    })();
  }
  function* FromTerminal(syntax) {
    if (syntax[1] !== "{") {
      const L = (0, index_1.Literal)("$");
      const R = FromSyntax(syntax.slice(1));
      return yield* [L, ...R];
    }
    for (let i = 2;i < syntax.length; i++) {
      if (syntax[i] === "}") {
        const L = FromUnion(syntax.slice(2, i));
        const R = FromSyntax(syntax.slice(i + 1));
        return yield* [...L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function* FromSyntax(syntax) {
    for (let i = 0;i < syntax.length; i++) {
      if (syntax[i] === "$") {
        const L = (0, index_1.Literal)(syntax.slice(0, i));
        const R = FromTerminal(syntax.slice(i));
        return yield* [L, ...R];
      }
    }
    yield (0, index_1.Literal)(syntax);
  }
  function TemplateLiteralSyntax(syntax) {
    return [...FromSyntax(syntax)];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/patterns.js
var require_patterns = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PatternNeverExact = exports.PatternStringExact = exports.PatternNumberExact = exports.PatternBooleanExact = exports.PatternNever = exports.PatternString = exports.PatternNumber = exports.PatternBoolean = undefined;
  exports.PatternBoolean = "(true|false)";
  exports.PatternNumber = "(0|[1-9][0-9]*)";
  exports.PatternString = "(.*)";
  exports.PatternNever = "(?!.*)";
  exports.PatternBooleanExact = `^${exports.PatternBoolean}$`;
  exports.PatternNumberExact = `^${exports.PatternNumber}$`;
  exports.PatternStringExact = `^${exports.PatternString}$`;
  exports.PatternNeverExact = `^${exports.PatternNever}$`;
});

// node_modules/@sinclair/typebox/build/cjs/type/patterns/index.js
var require_patterns2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_patterns(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/pattern.js
var require_pattern = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralPatternError = undefined;
  exports.TemplateLiteralPattern = TemplateLiteralPattern;
  var index_1 = require_patterns2();
  var index_2 = require_symbols2();
  var index_3 = require_error2();
  var kind_1 = require_kind();

  class TemplateLiteralPatternError extends index_3.TypeBoxError {
  }
  exports.TemplateLiteralPatternError = TemplateLiteralPatternError;
  function Escape(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function Visit(schema, acc) {
    return (0, kind_1.IsTemplateLiteral)(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : (0, kind_1.IsUnion)(schema) ? `(${schema.anyOf.map((schema2) => Visit(schema2, acc)).join("|")})` : (0, kind_1.IsNumber)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsInteger)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsBigInt)(schema) ? `${acc}${index_1.PatternNumber}` : (0, kind_1.IsString)(schema) ? `${acc}${index_1.PatternString}` : (0, kind_1.IsLiteral)(schema) ? `${acc}${Escape(schema.const.toString())}` : (0, kind_1.IsBoolean)(schema) ? `${acc}${index_1.PatternBoolean}` : (() => {
      throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[index_2.Kind]}'`);
    })();
  }
  function TemplateLiteralPattern(kinds) {
    return `^${kinds.map((schema) => Visit(schema, "")).join("")}$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/union.js
var require_union3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteralToUnion = TemplateLiteralToUnion;
  var index_1 = require_union2();
  var index_2 = require_literal2();
  var generate_1 = require_generate();
  function TemplateLiteralToUnion(schema) {
    const R = (0, generate_1.TemplateLiteralGenerate)(schema);
    const L = R.map((S) => (0, index_2.Literal)(S));
    return (0, index_1.UnionEvaluated)(L);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/template-literal.js
var require_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TemplateLiteral = TemplateLiteral;
  var syntax_1 = require_syntax();
  var pattern_1 = require_pattern();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function TemplateLiteral(unresolved, options = {}) {
    const pattern = (0, value_1.IsString)(unresolved) ? (0, pattern_1.TemplateLiteralPattern)((0, syntax_1.TemplateLiteralSyntax)(unresolved)) : (0, pattern_1.TemplateLiteralPattern)(unresolved);
    return { ...options, [index_1.Kind]: "TemplateLiteral", type: "string", pattern };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/template-literal/index.js
var require_template_literal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_finite(), exports);
  __exportStar(require_generate(), exports);
  __exportStar(require_syntax(), exports);
  __exportStar(require_parse(), exports);
  __exportStar(require_pattern(), exports);
  __exportStar(require_union3(), exports);
  __exportStar(require_template_literal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-property-keys.js
var require_indexed_property_keys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexPropertyKeys = IndexPropertyKeys;
  var index_1 = require_template_literal2();
  var kind_1 = require_kind();
  function FromTemplateLiteral(T) {
    const R = (0, index_1.TemplateLiteralGenerate)(T);
    return R.map((S) => S.toString());
  }
  function FromUnion(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...IndexPropertyKeys(L));
    return Acc;
  }
  function FromLiteral(T) {
    return [T.toString()];
  }
  function IndexPropertyKeys(T) {
    return [...new Set((0, kind_1.IsTemplateLiteral)(T) ? FromTemplateLiteral(T) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsLiteral)(T) ? FromLiteral(T.const) : (0, kind_1.IsNumber)(T) ? ["[number]"] : (0, kind_1.IsInteger)(T) ? ["[number]"] : [])];
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-result.js
var require_indexed_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedResult = IndexFromMappedResult;
  var index_1 = require_mapped2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var index_2 = require_indexed2();
  function FromProperties(T, P, options) {
    const Acc = {};
    for (const K2 of Object.getOwnPropertyNames(P)) {
      Acc[K2] = (0, index_2.Index)(T, (0, indexed_property_keys_1.IndexPropertyKeys)(P[K2]), options);
    }
    return Acc;
  }
  function FromMappedResult(T, R, options) {
    return FromProperties(T, R.properties, options);
  }
  function IndexFromMappedResult(T, R, options) {
    const P = FromMappedResult(T, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed.js
var require_indexed = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromPropertyKey = IndexFromPropertyKey;
  exports.IndexFromPropertyKeys = IndexFromPropertyKeys;
  exports.Index = Index;
  var index_1 = require_never2();
  var index_2 = require_intersect2();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var indexed_property_keys_1 = require_indexed_property_keys();
  var indexed_from_mapped_key_1 = require_indexed_from_mapped_key();
  var indexed_from_mapped_result_1 = require_indexed_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T, K) {
    return T.map((L) => IndexFromPropertyKey(L, K));
  }
  function FromIntersectRest(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function FromIntersect(T, K) {
    return (0, index_2.IntersectEvaluated)(FromIntersectRest(FromRest(T, K)));
  }
  function FromUnionRest(T) {
    return T.some((L) => (0, kind_1.IsNever)(L)) ? [] : T;
  }
  function FromUnion(T, K) {
    return (0, index_3.UnionEvaluated)(FromUnionRest(FromRest(T, K)));
  }
  function FromTuple(T, K) {
    return K in T ? T[K] : K === "[number]" ? (0, index_3.UnionEvaluated)(T) : (0, index_1.Never)();
  }
  function FromArray(T, K) {
    return K === "[number]" ? T : (0, index_1.Never)();
  }
  function FromProperty(T, K) {
    return K in T ? T[K] : (0, index_1.Never)();
  }
  function IndexFromPropertyKey(T, K) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf, K) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf, K) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? [], K) : (0, kind_1.IsArray)(T) ? FromArray(T.items, K) : (0, kind_1.IsObject)(T) ? FromProperty(T.properties, K) : (0, index_1.Never)();
  }
  function IndexFromPropertyKeys(T, K) {
    return K.map((L) => IndexFromPropertyKey(T, L));
  }
  function FromSchema(T, K) {
    return (0, index_3.UnionEvaluated)(IndexFromPropertyKeys(T, K));
  }
  function Index(T, K, options = {}) {
    return (0, kind_1.IsMappedResult)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_result_1.IndexFromMappedResult)(T, K, options)) : (0, kind_1.IsMappedKey)(K) ? (0, type_1.CloneType)((0, indexed_from_mapped_key_1.IndexFromMappedKey)(T, K, options)) : (0, kind_1.IsSchema)(K) ? (0, type_1.CloneType)(FromSchema(T, (0, indexed_property_keys_1.IndexPropertyKeys)(K)), options) : (0, type_1.CloneType)(FromSchema(T, K), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/indexed-from-mapped-key.js
var require_indexed_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexFromMappedKey = IndexFromMappedKey;
  var indexed_1 = require_indexed();
  var index_1 = require_mapped2();
  function MappedIndexPropertyKey(T, K, options) {
    return { [K]: (0, indexed_1.Index)(T, [K], options) };
  }
  function MappedIndexPropertyKeys(T, K, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
    }, {});
  }
  function MappedIndexProperties(T, K, options) {
    return MappedIndexPropertyKeys(T, K.keys, options);
  }
  function IndexFromMappedKey(T, K, options) {
    const P = MappedIndexProperties(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/indexed/index.js
var require_indexed2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_indexed_from_mapped_key(), exports);
  __exportStar(require_indexed_from_mapped_result(), exports);
  __exportStar(require_indexed_property_keys(), exports);
  __exportStar(require_indexed(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/iterator.js
var require_iterator = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Iterator = Iterator;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Iterator(items, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Iterator",
      type: "Iterator",
      items: (0, type_1.CloneType)(items)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/iterator/index.js
var require_iterator2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_iterator(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/object/object.js
var require_object = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Object = undefined;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  var kind_1 = require_kind();
  function _Object(properties, options = {}) {
    const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
    const optionalKeys = propertyKeys.filter((key) => (0, kind_1.IsOptional)(properties[key]));
    const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
    const clonedAdditionalProperties = (0, kind_1.IsSchema)(options.additionalProperties) ? { additionalProperties: (0, type_1.CloneType)(options.additionalProperties) } : {};
    const clonedProperties = {};
    for (const key of propertyKeys)
      clonedProperties[key] = (0, type_1.CloneType)(properties[key]);
    return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [index_1.Kind]: "Object", type: "object", properties: clonedProperties };
  }
  exports.Object = _Object;
});

// node_modules/@sinclair/typebox/build/cjs/type/object/index.js
var require_object2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_object(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/promise.js
var require_promise = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Promise = Promise2;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Promise2(item, options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Promise",
      type: "Promise",
      item: (0, type_1.CloneType)(item)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/promise/index.js
var require_promise2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_promise(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly.js
var require_readonly = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Readonly = Readonly;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var readonly_from_mapped_result_1 = require_readonly_from_mapped_result();
  var kind_1 = require_kind();
  function RemoveReadonly(schema) {
    return (0, index_2.Discard)((0, type_1.CloneType)(schema), [index_1.ReadonlyKind]);
  }
  function AddReadonly(schema) {
    return { ...(0, type_1.CloneType)(schema), [index_1.ReadonlyKind]: "Readonly" };
  }
  function ReadonlyWithFlag(schema, F) {
    return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
  }
  function Readonly(schema, enable) {
    const F = enable ?? true;
    return (0, kind_1.IsMappedResult)(schema) ? (0, readonly_from_mapped_result_1.ReadonlyFromMappedResult)(schema, F) : ReadonlyWithFlag(schema, F);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/readonly-from-mapped-result.js
var require_readonly_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
  var index_1 = require_mapped2();
  var readonly_1 = require_readonly();
  function FromProperties(K, F) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, readonly_1.Readonly)(K[K2], F);
    return Acc;
  }
  function FromMappedResult(R, F) {
    return FromProperties(R.properties, F);
  }
  function ReadonlyFromMappedResult(R, F) {
    const P = FromMappedResult(R, F);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly/index.js
var require_readonly2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_from_mapped_result(), exports);
  __exportStar(require_readonly(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/tuple.js
var require_tuple = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Tuple = Tuple;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Tuple(items, options = {}) {
    const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
    return items.length > 0 ? { ...options, [index_1.Kind]: "Tuple", type: "array", items: (0, type_1.CloneRest)(items), additionalItems, minItems, maxItems } : { ...options, [index_1.Kind]: "Tuple", type: "array", minItems, maxItems };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/tuple/index.js
var require_tuple2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_tuple(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/set.js
var require_set = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SetIncludes = SetIncludes;
  exports.SetIsSubset = SetIsSubset;
  exports.SetDistinct = SetDistinct;
  exports.SetIntersect = SetIntersect;
  exports.SetUnion = SetUnion;
  exports.SetComplement = SetComplement;
  exports.SetIntersectMany = SetIntersectMany;
  exports.SetUnionMany = SetUnionMany;
  function SetIncludes(T, S) {
    return T.includes(S);
  }
  function SetIsSubset(T, S) {
    return T.every((L) => SetIncludes(S, L));
  }
  function SetDistinct(T) {
    return [...new Set(T)];
  }
  function SetIntersect(T, S) {
    return T.filter((L) => S.includes(L));
  }
  function SetUnion(T, S) {
    return [...T, ...S];
  }
  function SetComplement(T, S) {
    return T.filter((L) => !S.includes(L));
  }
  function SetIntersectManyResolve(T, Init) {
    return T.reduce((Acc, L) => {
      return SetIntersect(Acc, L);
    }, Init);
  }
  function SetIntersectMany(T) {
    return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
  }
  function SetUnionMany(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...L);
    return Acc;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/sets/index.js
var require_sets = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_set(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/mapped.js
var require_mapped = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MappedFunctionReturnType = MappedFunctionReturnType;
  exports.Mapped = Mapped;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var index_2 = require_discard2();
  var index_3 = require_array2();
  var index_4 = require_async_iterator2();
  var index_5 = require_constructor2();
  var index_6 = require_function2();
  var index_7 = require_indexed2();
  var index_8 = require_intersect2();
  var index_9 = require_iterator2();
  var index_10 = require_literal2();
  var index_11 = require_object2();
  var index_12 = require_optional2();
  var index_13 = require_promise2();
  var index_14 = require_readonly2();
  var index_15 = require_tuple2();
  var index_16 = require_union2();
  var index_17 = require_sets();
  var mapped_result_1 = require_mapped_result();
  var kind_1 = require_kind();
  function FromMappedResult(K, P) {
    return K in P ? FromSchemaType(K, P[K]) : (0, mapped_result_1.MappedResult)(P);
  }
  function MappedKeyToKnownMappedResultProperties(K) {
    return { [K]: (0, index_10.Literal)(K) };
  }
  function MappedKeyToUnknownMappedResultProperties(P) {
    const Acc = {};
    for (const L of P)
      Acc[L] = (0, index_10.Literal)(L);
    return Acc;
  }
  function MappedKeyToMappedResultProperties(K, P) {
    return (0, index_17.SetIncludes)(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
  }
  function FromMappedKey(K, P) {
    const R = MappedKeyToMappedResultProperties(K, P);
    return FromMappedResult(K, R);
  }
  function FromRest(K, T) {
    return T.map((L) => FromSchemaType(K, L));
  }
  function FromProperties(K, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(T))
      Acc[K2] = FromSchemaType(K, T[K2]);
    return Acc;
  }
  function FromSchemaType(K, T) {
    return (0, kind_1.IsOptional)(T) ? (0, index_12.Optional)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.OptionalKind]))) : (0, kind_1.IsReadonly)(T) ? (0, index_14.Readonly)(FromSchemaType(K, (0, index_2.Discard)(T, [index_1.ReadonlyKind]))) : (0, kind_1.IsMappedResult)(T) ? FromMappedResult(K, T.properties) : (0, kind_1.IsMappedKey)(T) ? FromMappedKey(K, T.keys) : (0, kind_1.IsConstructor)(T) ? (0, index_5.Constructor)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) : (0, kind_1.IsFunction)(T) ? (0, index_6.Function)(FromRest(K, T.parameters), FromSchemaType(K, T.returns)) : (0, kind_1.IsAsyncIterator)(T) ? (0, index_4.AsyncIterator)(FromSchemaType(K, T.items)) : (0, kind_1.IsIterator)(T) ? (0, index_9.Iterator)(FromSchemaType(K, T.items)) : (0, kind_1.IsIntersect)(T) ? (0, index_8.Intersect)(FromRest(K, T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_16.Union)(FromRest(K, T.anyOf)) : (0, kind_1.IsTuple)(T) ? (0, index_15.Tuple)(FromRest(K, T.items ?? [])) : (0, kind_1.IsObject)(T) ? (0, index_11.Object)(FromProperties(K, T.properties)) : (0, kind_1.IsArray)(T) ? (0, index_3.Array)(FromSchemaType(K, T.items)) : (0, kind_1.IsPromise)(T) ? (0, index_13.Promise)(FromSchemaType(K, T.item)) : T;
  }
  function MappedFunctionReturnType(K, T) {
    const Acc = {};
    for (const L of K)
      Acc[L] = FromSchemaType(L, T);
    return Acc;
  }
  function Mapped(key, map, options = {}) {
    const K = (0, kind_1.IsSchema)(key) ? (0, index_7.IndexPropertyKeys)(key) : key;
    const RT = map({ [index_1.Kind]: "MappedKey", keys: K });
    const R = MappedFunctionReturnType(K, RT);
    return (0, type_1.CloneType)((0, index_11.Object)(R), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/mapped/index.js
var require_mapped2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mapped_key(), exports);
  __exportStar(require_mapped_result(), exports);
  __exportStar(require_mapped(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-keys.js
var require_keyof_property_keys = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyKeys = KeyOfPropertyKeys;
  exports.KeyOfPattern = KeyOfPattern;
  var index_1 = require_sets();
  var kind_1 = require_kind();
  function FromRest(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(KeyOfPropertyKeys(L));
    return Acc;
  }
  function FromIntersect(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetUnionMany)(C);
    return R;
  }
  function FromUnion(T) {
    const C = FromRest(T);
    const R = (0, index_1.SetIntersectMany)(C);
    return R;
  }
  function FromTuple(T) {
    return T.map((_, I) => I.toString());
  }
  function FromArray(_) {
    return ["[number]"];
  }
  function FromProperties(T) {
    return globalThis.Object.getOwnPropertyNames(T);
  }
  function FromPatternProperties(patternProperties) {
    if (!includePatternProperties)
      return [];
    const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
    return patternPropertyKeys.map((key) => {
      return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
    });
  }
  function KeyOfPropertyKeys(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsTuple)(T) ? FromTuple(T.items ?? []) : (0, kind_1.IsArray)(T) ? FromArray(T.items) : (0, kind_1.IsObject)(T) ? FromProperties(T.properties) : (0, kind_1.IsRecord)(T) ? FromPatternProperties(T.patternProperties) : [];
  }
  var includePatternProperties = false;
  function KeyOfPattern(schema) {
    includePatternProperties = true;
    const keys = KeyOfPropertyKeys(schema);
    includePatternProperties = false;
    const pattern = keys.map((key) => `(${key})`);
    return `^(${pattern.join("|")})$`;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof.js
var require_keyof = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
  exports.KeyOf = KeyOf;
  var index_1 = require_literal2();
  var index_2 = require_number2();
  var keyof_property_keys_1 = require_keyof_property_keys();
  var index_3 = require_union2();
  var type_1 = require_type2();
  var keyof_from_mapped_result_1 = require_keyof_from_mapped_result();
  var kind_1 = require_kind();
  function KeyOfPropertyKeysToRest(T) {
    return T.map((L) => L === "[number]" ? (0, index_2.Number)() : (0, index_1.Literal)(L));
  }
  function KeyOf(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, keyof_from_mapped_result_1.KeyOfFromMappedResult)(T, options);
    } else {
      const K = (0, keyof_property_keys_1.KeyOfPropertyKeys)(T);
      const S = KeyOfPropertyKeysToRest(K);
      const U = (0, index_3.UnionEvaluated)(S);
      return (0, type_1.CloneType)(U, options);
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-from-mapped-result.js
var require_keyof_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfFromMappedResult = KeyOfFromMappedResult;
  var index_1 = require_mapped2();
  var keyof_1 = require_keyof();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, keyof_1.KeyOf)(K[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function KeyOfFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/keyof-property-entries.js
var require_keyof_property_entries = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.KeyOfPropertyEntries = KeyOfPropertyEntries;
  var indexed_1 = require_indexed();
  var keyof_property_keys_1 = require_keyof_property_keys();
  function KeyOfPropertyEntries(schema) {
    const keys = (0, keyof_property_keys_1.KeyOfPropertyKeys)(schema);
    const schemas = (0, indexed_1.IndexFromPropertyKeys)(schema, keys);
    return keys.map((_, index) => [keys[index], schemas[index]]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/keyof/index.js
var require_keyof2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_keyof_from_mapped_result(), exports);
  __exportStar(require_keyof_property_entries(), exports);
  __exportStar(require_keyof_property_keys(), exports);
  __exportStar(require_keyof(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-undefined.js
var require_extends_undefined = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
  var index_1 = require_symbols2();
  function Intersect(schema) {
    return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
  }
  function Union(schema) {
    return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
  }
  function Not(schema) {
    return !ExtendsUndefinedCheck(schema.not);
  }
  function ExtendsUndefinedCheck(schema) {
    return schema[index_1.Kind] === "Intersect" ? Intersect(schema) : schema[index_1.Kind] === "Union" ? Union(schema) : schema[index_1.Kind] === "Not" ? Not(schema) : schema[index_1.Kind] === "Undefined" ? true : false;
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/function.js
var require_function3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DefaultErrorFunction = DefaultErrorFunction;
  exports.SetErrorFunction = SetErrorFunction;
  exports.GetErrorFunction = GetErrorFunction;
  var index_1 = require_symbols2();
  var errors_1 = require_errors();
  function DefaultErrorFunction(error) {
    switch (error.errorType) {
      case errors_1.ValueErrorType.ArrayContains:
        return "Expected array to contain at least one matching value";
      case errors_1.ValueErrorType.ArrayMaxContains:
        return `Expected array to contain no more than ${error.schema.maxContains} matching values`;
      case errors_1.ValueErrorType.ArrayMinContains:
        return `Expected array to contain at least ${error.schema.minContains} matching values`;
      case errors_1.ValueErrorType.ArrayMaxItems:
        return `Expected array length to be less or equal to ${error.schema.maxItems}`;
      case errors_1.ValueErrorType.ArrayMinItems:
        return `Expected array length to be greater or equal to ${error.schema.minItems}`;
      case errors_1.ValueErrorType.ArrayUniqueItems:
        return "Expected array elements to be unique";
      case errors_1.ValueErrorType.Array:
        return "Expected array";
      case errors_1.ValueErrorType.AsyncIterator:
        return "Expected AsyncIterator";
      case errors_1.ValueErrorType.BigIntExclusiveMaximum:
        return `Expected bigint to be less than ${error.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.BigIntExclusiveMinimum:
        return `Expected bigint to be greater than ${error.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.BigIntMaximum:
        return `Expected bigint to be less or equal to ${error.schema.maximum}`;
      case errors_1.ValueErrorType.BigIntMinimum:
        return `Expected bigint to be greater or equal to ${error.schema.minimum}`;
      case errors_1.ValueErrorType.BigIntMultipleOf:
        return `Expected bigint to be a multiple of ${error.schema.multipleOf}`;
      case errors_1.ValueErrorType.BigInt:
        return "Expected bigint";
      case errors_1.ValueErrorType.Boolean:
        return "Expected boolean";
      case errors_1.ValueErrorType.DateExclusiveMinimumTimestamp:
        return `Expected Date timestamp to be greater than ${error.schema.exclusiveMinimumTimestamp}`;
      case errors_1.ValueErrorType.DateExclusiveMaximumTimestamp:
        return `Expected Date timestamp to be less than ${error.schema.exclusiveMaximumTimestamp}`;
      case errors_1.ValueErrorType.DateMinimumTimestamp:
        return `Expected Date timestamp to be greater or equal to ${error.schema.minimumTimestamp}`;
      case errors_1.ValueErrorType.DateMaximumTimestamp:
        return `Expected Date timestamp to be less or equal to ${error.schema.maximumTimestamp}`;
      case errors_1.ValueErrorType.DateMultipleOfTimestamp:
        return `Expected Date timestamp to be a multiple of ${error.schema.multipleOfTimestamp}`;
      case errors_1.ValueErrorType.Date:
        return "Expected Date";
      case errors_1.ValueErrorType.Function:
        return "Expected function";
      case errors_1.ValueErrorType.IntegerExclusiveMaximum:
        return `Expected integer to be less than ${error.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.IntegerExclusiveMinimum:
        return `Expected integer to be greater than ${error.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.IntegerMaximum:
        return `Expected integer to be less or equal to ${error.schema.maximum}`;
      case errors_1.ValueErrorType.IntegerMinimum:
        return `Expected integer to be greater or equal to ${error.schema.minimum}`;
      case errors_1.ValueErrorType.IntegerMultipleOf:
        return `Expected integer to be a multiple of ${error.schema.multipleOf}`;
      case errors_1.ValueErrorType.Integer:
        return "Expected integer";
      case errors_1.ValueErrorType.IntersectUnevaluatedProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.Intersect:
        return "Expected all values to match";
      case errors_1.ValueErrorType.Iterator:
        return "Expected Iterator";
      case errors_1.ValueErrorType.Literal:
        return `Expected ${typeof error.schema.const === "string" ? `'${error.schema.const}'` : error.schema.const}`;
      case errors_1.ValueErrorType.Never:
        return "Never";
      case errors_1.ValueErrorType.Not:
        return "Value should not match";
      case errors_1.ValueErrorType.Null:
        return "Expected null";
      case errors_1.ValueErrorType.NumberExclusiveMaximum:
        return `Expected number to be less than ${error.schema.exclusiveMaximum}`;
      case errors_1.ValueErrorType.NumberExclusiveMinimum:
        return `Expected number to be greater than ${error.schema.exclusiveMinimum}`;
      case errors_1.ValueErrorType.NumberMaximum:
        return `Expected number to be less or equal to ${error.schema.maximum}`;
      case errors_1.ValueErrorType.NumberMinimum:
        return `Expected number to be greater or equal to ${error.schema.minimum}`;
      case errors_1.ValueErrorType.NumberMultipleOf:
        return `Expected number to be a multiple of ${error.schema.multipleOf}`;
      case errors_1.ValueErrorType.Number:
        return "Expected number";
      case errors_1.ValueErrorType.Object:
        return "Expected object";
      case errors_1.ValueErrorType.ObjectAdditionalProperties:
        return "Unexpected property";
      case errors_1.ValueErrorType.ObjectMaxProperties:
        return `Expected object to have no more than ${error.schema.maxProperties} properties`;
      case errors_1.ValueErrorType.ObjectMinProperties:
        return `Expected object to have at least ${error.schema.minProperties} properties`;
      case errors_1.ValueErrorType.ObjectRequiredProperty:
        return "Expected required property";
      case errors_1.ValueErrorType.Promise:
        return "Expected Promise";
      case errors_1.ValueErrorType.RegExp:
        return "Expected string to match regular expression";
      case errors_1.ValueErrorType.StringFormatUnknown:
        return `Unknown format '${error.schema.format}'`;
      case errors_1.ValueErrorType.StringFormat:
        return `Expected string to match '${error.schema.format}' format`;
      case errors_1.ValueErrorType.StringMaxLength:
        return `Expected string length less or equal to ${error.schema.maxLength}`;
      case errors_1.ValueErrorType.StringMinLength:
        return `Expected string length greater or equal to ${error.schema.minLength}`;
      case errors_1.ValueErrorType.StringPattern:
        return `Expected string to match '${error.schema.pattern}'`;
      case errors_1.ValueErrorType.String:
        return "Expected string";
      case errors_1.ValueErrorType.Symbol:
        return "Expected symbol";
      case errors_1.ValueErrorType.TupleLength:
        return `Expected tuple to have ${error.schema.maxItems || 0} elements`;
      case errors_1.ValueErrorType.Tuple:
        return "Expected tuple";
      case errors_1.ValueErrorType.Uint8ArrayMaxByteLength:
        return `Expected byte length less or equal to ${error.schema.maxByteLength}`;
      case errors_1.ValueErrorType.Uint8ArrayMinByteLength:
        return `Expected byte length greater or equal to ${error.schema.minByteLength}`;
      case errors_1.ValueErrorType.Uint8Array:
        return "Expected Uint8Array";
      case errors_1.ValueErrorType.Undefined:
        return "Expected undefined";
      case errors_1.ValueErrorType.Union:
        return "Expected union value";
      case errors_1.ValueErrorType.Void:
        return "Expected void";
      case errors_1.ValueErrorType.Kind:
        return `Expected kind '${error.schema[index_1.Kind]}'`;
      default:
        return "Unknown error type";
    }
  }
  var errorFunction = DefaultErrorFunction;
  function SetErrorFunction(callback) {
    errorFunction = callback;
  }
  function GetErrorFunction() {
    return errorFunction;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/deref.js
var require_deref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeDereferenceError = undefined;
  exports.Deref = Deref;
  var index_1 = require_error2();
  var index_2 = require_symbols2();

  class TypeDereferenceError extends index_1.TypeBoxError {
    constructor(schema) {
      super(`Unable to dereference schema with $id '${schema.$id}'`);
      this.schema = schema;
    }
  }
  exports.TypeDereferenceError = TypeDereferenceError;
  function Resolve(schema, references) {
    const target = references.find((target2) => target2.$id === schema.$ref);
    if (target === undefined)
      throw new TypeDereferenceError(schema);
    return Deref(target, references);
  }
  function Deref(schema, references) {
    return schema[index_2.Kind] === "This" || schema[index_2.Kind] === "Ref" ? Resolve(schema, references) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/deref/index.js
var require_deref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/hash.js
var require_hash = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueHashError = undefined;
  exports.Hash = Hash;
  var index_1 = require_guard2();
  var index_2 = require_error2();

  class ValueHashError extends index_2.TypeBoxError {
    constructor(value) {
      super(`Unable to hash value`);
      this.value = value;
    }
  }
  exports.ValueHashError = ValueHashError;
  var ByteMarker;
  (function(ByteMarker2) {
    ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
    ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
    ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
    ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
    ByteMarker2[ByteMarker2["String"] = 4] = "String";
    ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
    ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
    ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
    ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
    ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
    ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
  })(ByteMarker || (ByteMarker = {}));
  var Accumulator = BigInt("14695981039346656037");
  var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
  var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
  var F64 = new Float64Array(1);
  var F64In = new DataView(F64.buffer);
  var F64Out = new Uint8Array(F64.buffer);
  function* NumberToBytes(value) {
    const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
    for (let i = 0;i < byteCount; i++) {
      yield value >> 8 * (byteCount - 1 - i) & 255;
    }
  }
  function ArrayType(value) {
    FNV1A64(ByteMarker.Array);
    for (const item of value) {
      Visit(item);
    }
  }
  function BooleanType(value) {
    FNV1A64(ByteMarker.Boolean);
    FNV1A64(value ? 1 : 0);
  }
  function BigIntType(value) {
    FNV1A64(ByteMarker.BigInt);
    F64In.setBigInt64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function DateType(value) {
    FNV1A64(ByteMarker.Date);
    Visit(value.getTime());
  }
  function NullType(value) {
    FNV1A64(ByteMarker.Null);
  }
  function NumberType(value) {
    FNV1A64(ByteMarker.Number);
    F64In.setFloat64(0, value);
    for (const byte of F64Out) {
      FNV1A64(byte);
    }
  }
  function ObjectType(value) {
    FNV1A64(ByteMarker.Object);
    for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
      Visit(key);
      Visit(value[key]);
    }
  }
  function StringType(value) {
    FNV1A64(ByteMarker.String);
    for (let i = 0;i < value.length; i++) {
      for (const byte of NumberToBytes(value.charCodeAt(i))) {
        FNV1A64(byte);
      }
    }
  }
  function SymbolType(value) {
    FNV1A64(ByteMarker.Symbol);
    Visit(value.description);
  }
  function Uint8ArrayType(value) {
    FNV1A64(ByteMarker.Uint8Array);
    for (let i = 0;i < value.length; i++) {
      FNV1A64(value[i]);
    }
  }
  function UndefinedType(value) {
    return FNV1A64(ByteMarker.Undefined);
  }
  function Visit(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType(value);
    if ((0, index_1.IsBoolean)(value))
      return BooleanType(value);
    if ((0, index_1.IsBigInt)(value))
      return BigIntType(value);
    if ((0, index_1.IsDate)(value))
      return DateType(value);
    if ((0, index_1.IsNull)(value))
      return NullType(value);
    if ((0, index_1.IsNumber)(value))
      return NumberType(value);
    if ((0, index_1.IsStandardObject)(value))
      return ObjectType(value);
    if ((0, index_1.IsString)(value))
      return StringType(value);
    if ((0, index_1.IsSymbol)(value))
      return SymbolType(value);
    if ((0, index_1.IsUint8Array)(value))
      return Uint8ArrayType(value);
    if ((0, index_1.IsUndefined)(value))
      return UndefinedType(value);
    throw new ValueHashError(value);
  }
  function FNV1A64(byte) {
    Accumulator = Accumulator ^ Bytes[byte];
    Accumulator = Accumulator * Prime % Size;
  }
  function Hash(value) {
    Accumulator = BigInt("14695981039346656037");
    Visit(value);
    return Accumulator;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/hash/index.js
var require_hash2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_hash(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/errors/errors.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorsUnknownTypeError = exports.ValueErrorType = undefined;
  exports.Errors = Errors;
  var index_1 = require_system2();
  var index_2 = require_keyof2();
  var index_3 = require_registry();
  var extends_undefined_1 = require_extends_undefined();
  var function_1 = require_function3();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_never2();
  var index_9 = require_guard2();
  var ValueErrorType;
  (function(ValueErrorType2) {
    ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
    ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
    ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
    ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
    ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
    ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
    ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
    ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
    ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
    ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
    ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
    ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
    ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
    ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
    ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
    ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
    ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
    ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
    ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
    ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
    ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
    ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
    ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
    ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
    ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
    ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
    ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
    ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
    ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
    ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
    ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
    ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
    ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
    ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
    ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
    ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
    ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
    ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
    ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
    ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
    ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
    ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
    ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
    ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
    ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
    ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
    ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
    ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
    ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
    ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
    ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
    ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
  })(ValueErrorType || (exports.ValueErrorType = ValueErrorType = {}));

  class ValueErrorsUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
  function EscapeKey(key) {
    return key.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function IsDefined(value) {
    return value !== undefined;
  }

  class ValueErrorIterator {
    constructor(iterator) {
      this.iterator = iterator;
    }
    [Symbol.iterator]() {
      return this.iterator;
    }
    First() {
      const next = this.iterator.next();
      return next.done ? undefined : next.value;
    }
  }
  exports.ValueErrorIterator = ValueErrorIterator;
  function Create(errorType, schema, path, value) {
    return { type: errorType, schema, path, value, message: (0, function_1.GetErrorFunction)()({ errorType, path, schema, value }) };
  }
  function* FromAny(schema, references, path, value) {}
  function* FromArray(schema, references, path, value) {
    if (!(0, index_9.IsArray)(value)) {
      return yield Create(ValueErrorType.Array, schema, path, value);
    }
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
    }
    for (let i = 0;i < value.length; i++) {
      yield* Visit(schema.items, references, `${path}/${i}`, value[i]);
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, index_6.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
    }
    if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
      return;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_8.Never)();
    const containsCount = value.reduce((acc, value2, index) => Visit(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      yield Create(ValueErrorType.ArrayContains, schema, path, value);
    }
    if ((0, index_9.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
    }
    if ((0, index_9.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
    }
  }
  function* FromAsyncIterator(schema, references, path, value) {
    if (!(0, index_9.IsAsyncIterator)(value))
      yield Create(ValueErrorType.AsyncIterator, schema, path, value);
  }
  function* FromBigInt(schema, references, path, value) {
    if (!(0, index_9.IsBigInt)(value))
      return yield Create(ValueErrorType.BigInt, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
    }
  }
  function* FromBoolean(schema, references, path, value) {
    if (!(0, index_9.IsBoolean)(value))
      yield Create(ValueErrorType.Boolean, schema, path, value);
  }
  function* FromConstructor(schema, references, path, value) {
    yield* Visit(schema.returns, references, path, value.prototype);
  }
  function* FromDate(schema, references, path, value) {
    if (!(0, index_9.IsDate)(value))
      return yield Create(ValueErrorType.Date, schema, path, value);
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
    }
  }
  function* FromFunction(schema, references, path, value) {
    if (!(0, index_9.IsFunction)(value))
      yield Create(ValueErrorType.Function, schema, path, value);
  }
  function* FromInteger(schema, references, path, value) {
    if (!(0, index_9.IsInteger)(value))
      return yield Create(ValueErrorType.Integer, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
    }
  }
  function* FromIntersect(schema, references, path, value) {
    for (const inner of schema.allOf) {
      const next = Visit(inner, references, path, value).next();
      if (!next.done) {
        yield Create(ValueErrorType.Intersect, schema, path, value);
        yield next.value;
      }
    }
    if (schema.unevaluatedProperties === false) {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
        }
      }
    }
    if (typeof schema.unevaluatedProperties === "object") {
      const keyCheck = new RegExp((0, index_2.KeyOfPattern)(schema));
      for (const valueKey of Object.getOwnPropertyNames(value)) {
        if (!keyCheck.test(valueKey)) {
          const next = Visit(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
          if (!next.done)
            yield next.value;
        }
      }
    }
  }
  function* FromIterator(schema, references, path, value) {
    if (!(0, index_9.IsIterator)(value))
      yield Create(ValueErrorType.Iterator, schema, path, value);
  }
  function* FromLiteral(schema, references, path, value) {
    if (!(value === schema.const))
      yield Create(ValueErrorType.Literal, schema, path, value);
  }
  function* FromNever(schema, references, path, value) {
    yield Create(ValueErrorType.Never, schema, path, value);
  }
  function* FromNot(schema, references, path, value) {
    if (Visit(schema.not, references, path, value).next().done === true)
      yield Create(ValueErrorType.Not, schema, path, value);
  }
  function* FromNull(schema, references, path, value) {
    if (!(0, index_9.IsNull)(value))
      yield Create(ValueErrorType.Null, schema, path, value);
  }
  function* FromNumber(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return yield Create(ValueErrorType.Number, schema, path, value);
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      yield Create(ValueErrorType.NumberMaximum, schema, path, value);
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      yield Create(ValueErrorType.NumberMinimum, schema, path, value);
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
    }
  }
  function* FromObject(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    const unknownKeys = Object.getOwnPropertyNames(value);
    for (const requiredKey of requiredKeys) {
      if (unknownKeys.includes(requiredKey))
        continue;
      yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
    }
    if (schema.additionalProperties === false) {
      for (const valueKey of unknownKeys) {
        if (!knownKeys.includes(valueKey)) {
          yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
        }
      }
    }
    if (typeof schema.additionalProperties === "object") {
      for (const valueKey of unknownKeys) {
        if (knownKeys.includes(valueKey))
          continue;
        yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        if ((0, extends_undefined_1.ExtendsUndefinedCheck)(schema) && !(knownKey in value)) {
          yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
          yield* Visit(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
        }
      }
    }
  }
  function* FromPromise(schema, references, path, value) {
    if (!(0, index_9.IsPromise)(value))
      yield Create(ValueErrorType.Promise, schema, path, value);
  }
  function* FromRecord(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value))
      return yield Create(ValueErrorType.Object, schema, path, value);
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        yield* Visit(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
    if (typeof schema.additionalProperties === "object") {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (!regex.test(propertyKey))
          yield* Visit(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
    if (schema.additionalProperties === false) {
      for (const [propertyKey, propertyValue] of Object.entries(value)) {
        if (regex.test(propertyKey))
          continue;
        return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
      }
    }
  }
  function* FromRef(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromRegExp(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    const regex = new RegExp(schema.source, schema.flags);
    if (!regex.test(value)) {
      return yield Create(ValueErrorType.RegExp, schema, path, value);
    }
  }
  function* FromString(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
      yield Create(ValueErrorType.StringMinLength, schema, path, value);
    }
    if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
      yield Create(ValueErrorType.StringMaxLength, schema, path, value);
    }
    if ((0, index_9.IsString)(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value)) {
        yield Create(ValueErrorType.StringPattern, schema, path, value);
      }
    }
    if ((0, index_9.IsString)(schema.format)) {
      if (!index_3.FormatRegistry.Has(schema.format)) {
        yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
      } else {
        const format = index_3.FormatRegistry.Get(schema.format);
        if (!format(value)) {
          yield Create(ValueErrorType.StringFormat, schema, path, value);
        }
      }
    }
  }
  function* FromSymbol(schema, references, path, value) {
    if (!(0, index_9.IsSymbol)(value))
      yield Create(ValueErrorType.Symbol, schema, path, value);
  }
  function* FromTemplateLiteral(schema, references, path, value) {
    if (!(0, index_9.IsString)(value))
      return yield Create(ValueErrorType.String, schema, path, value);
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  function* FromThis(schema, references, path, value) {
    yield* Visit((0, index_5.Deref)(schema, references), references, path, value);
  }
  function* FromTuple(schema, references, path, value) {
    if (!(0, index_9.IsArray)(value))
      return yield Create(ValueErrorType.Tuple, schema, path, value);
    if (schema.items === undefined && !(value.length === 0)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!(value.length === schema.maxItems)) {
      return yield Create(ValueErrorType.TupleLength, schema, path, value);
    }
    if (!schema.items) {
      return;
    }
    for (let i = 0;i < schema.items.length; i++) {
      yield* Visit(schema.items[i], references, `${path}/${i}`, value[i]);
    }
  }
  function* FromUndefined(schema, references, path, value) {
    if (!(0, index_9.IsUndefined)(value))
      yield Create(ValueErrorType.Undefined, schema, path, value);
  }
  function* FromUnion(schema, references, path, value) {
    let count = 0;
    for (const subschema of schema.anyOf) {
      const errors = [...Visit(subschema, references, path, value)];
      if (errors.length === 0)
        return;
      count += errors.length;
    }
    if (count > 0) {
      yield Create(ValueErrorType.Union, schema, path, value);
    }
  }
  function* FromUint8Array(schema, references, path, value) {
    if (!(0, index_9.IsUint8Array)(value))
      return yield Create(ValueErrorType.Uint8Array, schema, path, value);
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
    }
  }
  function* FromUnknown(schema, references, path, value) {}
  function* FromVoid(schema, references, path, value) {
    if (!index_1.TypeSystemPolicy.IsVoidLike(value))
      yield Create(ValueErrorType.Void, schema, path, value);
  }
  function* FromKind(schema, references, path, value) {
    const check = index_3.TypeRegistry.Get(schema[index_7.Kind]);
    if (!check(schema, value))
      yield Create(ValueErrorType.Kind, schema, path, value);
  }
  function* Visit(schema, references, path, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_7.Kind]) {
      case "Any":
        return yield* FromAny(schema_, references_, path, value);
      case "Array":
        return yield* FromArray(schema_, references_, path, value);
      case "AsyncIterator":
        return yield* FromAsyncIterator(schema_, references_, path, value);
      case "BigInt":
        return yield* FromBigInt(schema_, references_, path, value);
      case "Boolean":
        return yield* FromBoolean(schema_, references_, path, value);
      case "Constructor":
        return yield* FromConstructor(schema_, references_, path, value);
      case "Date":
        return yield* FromDate(schema_, references_, path, value);
      case "Function":
        return yield* FromFunction(schema_, references_, path, value);
      case "Integer":
        return yield* FromInteger(schema_, references_, path, value);
      case "Intersect":
        return yield* FromIntersect(schema_, references_, path, value);
      case "Iterator":
        return yield* FromIterator(schema_, references_, path, value);
      case "Literal":
        return yield* FromLiteral(schema_, references_, path, value);
      case "Never":
        return yield* FromNever(schema_, references_, path, value);
      case "Not":
        return yield* FromNot(schema_, references_, path, value);
      case "Null":
        return yield* FromNull(schema_, references_, path, value);
      case "Number":
        return yield* FromNumber(schema_, references_, path, value);
      case "Object":
        return yield* FromObject(schema_, references_, path, value);
      case "Promise":
        return yield* FromPromise(schema_, references_, path, value);
      case "Record":
        return yield* FromRecord(schema_, references_, path, value);
      case "Ref":
        return yield* FromRef(schema_, references_, path, value);
      case "RegExp":
        return yield* FromRegExp(schema_, references_, path, value);
      case "String":
        return yield* FromString(schema_, references_, path, value);
      case "Symbol":
        return yield* FromSymbol(schema_, references_, path, value);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral(schema_, references_, path, value);
      case "This":
        return yield* FromThis(schema_, references_, path, value);
      case "Tuple":
        return yield* FromTuple(schema_, references_, path, value);
      case "Undefined":
        return yield* FromUndefined(schema_, references_, path, value);
      case "Union":
        return yield* FromUnion(schema_, references_, path, value);
      case "Uint8Array":
        return yield* FromUint8Array(schema_, references_, path, value);
      case "Unknown":
        return yield* FromUnknown(schema_, references_, path, value);
      case "Void":
        return yield* FromVoid(schema_, references_, path, value);
      default:
        if (!index_3.TypeRegistry.Has(schema_[index_7.Kind]))
          throw new ValueErrorsUnknownTypeError(schema);
        return yield* FromKind(schema_, references_, path, value);
    }
  }
  function Errors(...args) {
    const iterator = args.length === 3 ? Visit(args[0], args[1], "", args[2]) : Visit(args[0], [], "", args[1]);
    return new ValueErrorIterator(iterator);
  }
});

// node_modules/@sinclair/typebox/build/cjs/errors/index.js
var require_errors2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_errors(), exports);
  __exportStar(require_function3(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/any/any.js
var require_any = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Any = Any;
  var index_1 = require_symbols2();
  function Any(options = {}) {
    return { ...options, [index_1.Kind]: "Any" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/any/index.js
var require_any2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_any(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/unknown.js
var require_unknown = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Unknown = Unknown;
  var index_1 = require_symbols2();
  function Unknown(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Unknown"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/unknown/index.js
var require_unknown2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_unknown(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/type.js
var require_type3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeGuardUnknownTypeError = undefined;
  exports.IsReadonly = IsReadonly;
  exports.IsOptional = IsOptional;
  exports.IsAny = IsAny;
  exports.IsArray = IsArray;
  exports.IsAsyncIterator = IsAsyncIterator;
  exports.IsBigInt = IsBigInt;
  exports.IsBoolean = IsBoolean;
  exports.IsConstructor = IsConstructor;
  exports.IsDate = IsDate;
  exports.IsFunction = IsFunction;
  exports.IsInteger = IsInteger;
  exports.IsProperties = IsProperties;
  exports.IsIntersect = IsIntersect;
  exports.IsIterator = IsIterator;
  exports.IsKindOf = IsKindOf;
  exports.IsLiteralString = IsLiteralString;
  exports.IsLiteralNumber = IsLiteralNumber;
  exports.IsLiteralBoolean = IsLiteralBoolean;
  exports.IsLiteral = IsLiteral;
  exports.IsLiteralValue = IsLiteralValue;
  exports.IsMappedKey = IsMappedKey;
  exports.IsMappedResult = IsMappedResult;
  exports.IsNever = IsNever;
  exports.IsNot = IsNot;
  exports.IsNull = IsNull;
  exports.IsNumber = IsNumber;
  exports.IsObject = IsObject;
  exports.IsPromise = IsPromise;
  exports.IsRecord = IsRecord;
  exports.IsRecursive = IsRecursive;
  exports.IsRef = IsRef;
  exports.IsRegExp = IsRegExp;
  exports.IsString = IsString;
  exports.IsSymbol = IsSymbol;
  exports.IsTemplateLiteral = IsTemplateLiteral;
  exports.IsThis = IsThis;
  exports.IsTransform = IsTransform;
  exports.IsTuple = IsTuple;
  exports.IsUndefined = IsUndefined;
  exports.IsUnionLiteral = IsUnionLiteral;
  exports.IsUnion = IsUnion;
  exports.IsUint8Array = IsUint8Array;
  exports.IsUnknown = IsUnknown;
  exports.IsUnsafe = IsUnsafe;
  exports.IsVoid = IsVoid;
  exports.IsKind = IsKind;
  exports.IsSchema = IsSchema;
  var ValueGuard = require_value();
  var index_1 = require_symbols2();
  var index_2 = require_error2();

  class TypeGuardUnknownTypeError extends index_2.TypeBoxError {
  }
  exports.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
  var KnownTypes = [
    "Any",
    "Array",
    "AsyncIterator",
    "BigInt",
    "Boolean",
    "Constructor",
    "Date",
    "Enum",
    "Function",
    "Integer",
    "Intersect",
    "Iterator",
    "Literal",
    "MappedKey",
    "MappedResult",
    "Not",
    "Null",
    "Number",
    "Object",
    "Promise",
    "Record",
    "Ref",
    "RegExp",
    "String",
    "Symbol",
    "TemplateLiteral",
    "This",
    "Tuple",
    "Undefined",
    "Union",
    "Uint8Array",
    "Unknown",
    "Void"
  ];
  function IsPattern(value) {
    try {
      new RegExp(value);
      return true;
    } catch {
      return false;
    }
  }
  function IsControlCharacterFree(value) {
    if (!ValueGuard.IsString(value))
      return false;
    for (let i = 0;i < value.length; i++) {
      const code = value.charCodeAt(i);
      if (code >= 7 && code <= 13 || code === 27 || code === 127) {
        return false;
      }
    }
    return true;
  }
  function IsAdditionalProperties(value) {
    return IsOptionalBoolean(value) || IsSchema(value);
  }
  function IsOptionalBigInt(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBigInt(value);
  }
  function IsOptionalNumber(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsNumber(value);
  }
  function IsOptionalBoolean(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsBoolean(value);
  }
  function IsOptionalString(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value);
  }
  function IsOptionalPattern(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value) && IsPattern(value);
  }
  function IsOptionalFormat(value) {
    return ValueGuard.IsUndefined(value) || ValueGuard.IsString(value) && IsControlCharacterFree(value);
  }
  function IsOptionalSchema(value) {
    return ValueGuard.IsUndefined(value) || IsSchema(value);
  }
  function IsReadonly(value) {
    return ValueGuard.IsObject(value) && value[index_1.ReadonlyKind] === "Readonly";
  }
  function IsOptional(value) {
    return ValueGuard.IsObject(value) && value[index_1.OptionalKind] === "Optional";
  }
  function IsAny(value) {
    return IsKindOf(value, "Any") && IsOptionalString(value.$id);
  }
  function IsArray(value) {
    return IsKindOf(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
  }
  function IsAsyncIterator(value) {
    return IsKindOf(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema(value.items);
  }
  function IsBigInt(value) {
    return IsKindOf(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
  }
  function IsBoolean(value) {
    return IsKindOf(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
  }
  function IsConstructor(value) {
    return IsKindOf(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
  }
  function IsDate(value) {
    return IsKindOf(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
  }
  function IsFunction(value) {
    return IsKindOf(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && ValueGuard.IsArray(value.parameters) && value.parameters.every((schema) => IsSchema(schema)) && IsSchema(value.returns);
  }
  function IsInteger(value) {
    return IsKindOf(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
  }
  function IsProperties(value) {
    return ValueGuard.IsObject(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
  }
  function IsIntersect(value) {
    return IsKindOf(value, "Intersect") && (ValueGuard.IsString(value.type) && value.type !== "object" ? false : true) && ValueGuard.IsArray(value.allOf) && value.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
  }
  function IsIterator(value) {
    return IsKindOf(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema(value.items);
  }
  function IsKindOf(value, kind) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && value[index_1.Kind] === kind;
  }
  function IsLiteralString(value) {
    return IsLiteral(value) && ValueGuard.IsString(value.const);
  }
  function IsLiteralNumber(value) {
    return IsLiteral(value) && ValueGuard.IsNumber(value.const);
  }
  function IsLiteralBoolean(value) {
    return IsLiteral(value) && ValueGuard.IsBoolean(value.const);
  }
  function IsLiteral(value) {
    return IsKindOf(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
  }
  function IsLiteralValue(value) {
    return ValueGuard.IsBoolean(value) || ValueGuard.IsNumber(value) || ValueGuard.IsString(value);
  }
  function IsMappedKey(value) {
    return IsKindOf(value, "MappedKey") && ValueGuard.IsArray(value.keys) && value.keys.every((key) => ValueGuard.IsNumber(key) || ValueGuard.IsString(key));
  }
  function IsMappedResult(value) {
    return IsKindOf(value, "MappedResult") && IsProperties(value.properties);
  }
  function IsNever(value) {
    return IsKindOf(value, "Never") && ValueGuard.IsObject(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
  }
  function IsNot(value) {
    return IsKindOf(value, "Not") && IsSchema(value.not);
  }
  function IsNull(value) {
    return IsKindOf(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
  }
  function IsNumber(value) {
    return IsKindOf(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
  }
  function IsObject(value) {
    return IsKindOf(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
  }
  function IsPromise(value) {
    return IsKindOf(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema(value.item);
  }
  function IsRecord(value) {
    return IsKindOf(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && ValueGuard.IsObject(value.patternProperties) && ((schema) => {
      const keys = Object.getOwnPropertyNames(schema.patternProperties);
      return keys.length === 1 && IsPattern(keys[0]) && ValueGuard.IsObject(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
    })(value);
  }
  function IsRecursive(value) {
    return ValueGuard.IsObject(value) && index_1.Hint in value && value[index_1.Hint] === "Recursive";
  }
  function IsRef(value) {
    return IsKindOf(value, "Ref") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsRegExp(value) {
    return IsKindOf(value, "RegExp") && IsOptionalString(value.$id) && ValueGuard.IsString(value.source) && ValueGuard.IsString(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
  }
  function IsString(value) {
    return IsKindOf(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
  }
  function IsSymbol(value) {
    return IsKindOf(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
  }
  function IsTemplateLiteral(value) {
    return IsKindOf(value, "TemplateLiteral") && value.type === "string" && ValueGuard.IsString(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
  }
  function IsThis(value) {
    return IsKindOf(value, "This") && IsOptionalString(value.$id) && ValueGuard.IsString(value.$ref);
  }
  function IsTransform(value) {
    return ValueGuard.IsObject(value) && index_1.TransformKind in value;
  }
  function IsTuple(value) {
    return IsKindOf(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && ValueGuard.IsNumber(value.minItems) && ValueGuard.IsNumber(value.maxItems) && value.minItems === value.maxItems && (ValueGuard.IsUndefined(value.items) && ValueGuard.IsUndefined(value.additionalItems) && value.minItems === 0 || ValueGuard.IsArray(value.items) && value.items.every((schema) => IsSchema(schema)));
  }
  function IsUndefined(value) {
    return IsKindOf(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
  }
  function IsUnionLiteral(value) {
    return IsUnion(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
  }
  function IsUnion(value) {
    return IsKindOf(value, "Union") && IsOptionalString(value.$id) && ValueGuard.IsObject(value) && ValueGuard.IsArray(value.anyOf) && value.anyOf.every((schema) => IsSchema(schema));
  }
  function IsUint8Array(value) {
    return IsKindOf(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
  }
  function IsUnknown(value) {
    return IsKindOf(value, "Unknown") && IsOptionalString(value.$id);
  }
  function IsUnsafe(value) {
    return IsKindOf(value, "Unsafe");
  }
  function IsVoid(value) {
    return IsKindOf(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
  }
  function IsKind(value) {
    return ValueGuard.IsObject(value) && index_1.Kind in value && ValueGuard.IsString(value[index_1.Kind]) && !KnownTypes.includes(value[index_1.Kind]);
  }
  function IsSchema(value) {
    return ValueGuard.IsObject(value) && (IsAny(value) || IsArray(value) || IsBoolean(value) || IsBigInt(value) || IsAsyncIterator(value) || IsConstructor(value) || IsDate(value) || IsFunction(value) || IsInteger(value) || IsIntersect(value) || IsIterator(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull(value) || IsNumber(value) || IsObject(value) || IsPromise(value) || IsRecord(value) || IsRef(value) || IsRegExp(value) || IsString(value) || IsSymbol(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined(value) || IsUnion(value) || IsUint8Array(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/guard/index.js
var require_guard3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueGuard = exports.TypeGuard = exports.KindGuard = undefined;
  exports.KindGuard = require_kind();
  exports.TypeGuard = require_type3();
  exports.ValueGuard = require_value();
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-check.js
var require_extends_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsResult = exports.ExtendsResolverError = undefined;
  exports.ExtendsCheck = ExtendsCheck;
  var index_1 = require_any2();
  var index_2 = require_function2();
  var index_3 = require_number2();
  var index_4 = require_string2();
  var index_5 = require_unknown2();
  var index_6 = require_template_literal2();
  var index_7 = require_patterns2();
  var index_8 = require_symbols2();
  var index_9 = require_error2();
  var index_10 = require_guard3();

  class ExtendsResolverError extends index_9.TypeBoxError {
  }
  exports.ExtendsResolverError = ExtendsResolverError;
  var ExtendsResult;
  (function(ExtendsResult2) {
    ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
    ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
    ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
  })(ExtendsResult || (exports.ExtendsResult = ExtendsResult = {}));
  function IntoBooleanResult(result) {
    return result === ExtendsResult.False ? result : ExtendsResult.True;
  }
  function Throw(message) {
    throw new ExtendsResolverError(message);
  }
  function IsStructuralRight(right) {
    return index_10.TypeGuard.IsNever(right) || index_10.TypeGuard.IsIntersect(right) || index_10.TypeGuard.IsUnion(right) || index_10.TypeGuard.IsUnknown(right) || index_10.TypeGuard.IsAny(right);
  }
  function StructuralRight(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
  }
  function FromAnyRight(left, right) {
    return ExtendsResult.True;
  }
  function FromAny(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) && right.anyOf.some((schema) => index_10.TypeGuard.IsAny(schema) || index_10.TypeGuard.IsUnknown(schema)) ? ExtendsResult.True : index_10.TypeGuard.IsUnion(right) ? ExtendsResult.Union : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : index_10.TypeGuard.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
  }
  function FromArrayRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromArray(left, right) {
    return index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromAsyncIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromBigInt(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBooleanRight(left, right) {
    return index_10.TypeGuard.IsLiteralBoolean(left) ? ExtendsResult.True : index_10.TypeGuard.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromBoolean(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromConstructor(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromDate(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromFunction(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit(left.returns, right.returns));
  }
  function FromIntegerRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsNumber(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromInteger(left, right) {
    return index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
  }
  function FromIntersectRight(left, right) {
    return right.allOf.every((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIntersect(left, right) {
    return left.allOf.some((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromIterator(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : !index_10.TypeGuard.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.items, right.items));
  }
  function FromLiteral(left, right) {
    return index_10.TypeGuard.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
  }
  function FromNeverRight(left, right) {
    return ExtendsResult.False;
  }
  function FromNever(left, right) {
    return ExtendsResult.True;
  }
  function UnwrapTNot(schema) {
    let [current, depth] = [schema, 0];
    while (true) {
      if (!index_10.TypeGuard.IsNot(current))
        break;
      current = current.not;
      depth += 1;
    }
    return depth % 2 === 0 ? current : (0, index_5.Unknown)();
  }
  function FromNot(left, right) {
    return index_10.TypeGuard.IsNot(left) ? Visit(UnwrapTNot(left), right) : index_10.TypeGuard.IsNot(right) ? Visit(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
  }
  function FromNull(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumberRight(left, right) {
    return index_10.TypeGuard.IsLiteralNumber(left) ? ExtendsResult.True : index_10.TypeGuard.IsNumber(left) || index_10.TypeGuard.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromNumber(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsInteger(right) || index_10.TypeGuard.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function IsObjectPropertyCount(schema, count) {
    return Object.getOwnPropertyNames(schema.properties).length === count;
  }
  function IsObjectStringLike(schema) {
    return IsObjectArrayLike(schema);
  }
  function IsObjectSymbolLike(schema) {
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && index_10.TypeGuard.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (index_10.TypeGuard.IsString(schema.properties.description.anyOf[0]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[1]) || index_10.TypeGuard.IsString(schema.properties.description.anyOf[1]) && index_10.TypeGuard.IsUndefined(schema.properties.description.anyOf[0]));
  }
  function IsObjectNumberLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectBooleanLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectBigIntLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectDateLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectUint8ArrayLike(schema) {
    return IsObjectArrayLike(schema);
  }
  function IsObjectFunctionLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectConstructorLike(schema) {
    return IsObjectPropertyCount(schema, 0);
  }
  function IsObjectArrayLike(schema) {
    const length = (0, index_3.Number)();
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit(schema.properties["length"], length)) === ExtendsResult.True;
  }
  function IsObjectPromiseLike(schema) {
    const then = (0, index_2.Function)([(0, index_1.Any)()], (0, index_1.Any)());
    return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit(schema.properties["then"], then)) === ExtendsResult.True;
  }
  function Property(left, right) {
    return Visit(left, right) === ExtendsResult.False ? ExtendsResult.False : index_10.TypeGuard.IsOptional(left) && !index_10.TypeGuard.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
  }
  function FromObjectRight(left, right) {
    return index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : index_10.TypeGuard.IsNever(left) || index_10.TypeGuard.IsLiteralString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsLiteralNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsBigInt(left) && IsObjectBigIntLike(right) || index_10.TypeGuard.IsString(left) && IsObjectStringLike(right) || index_10.TypeGuard.IsSymbol(left) && IsObjectSymbolLike(right) || index_10.TypeGuard.IsNumber(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsInteger(left) && IsObjectNumberLike(right) || index_10.TypeGuard.IsBoolean(left) && IsObjectBooleanLike(right) || index_10.TypeGuard.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || index_10.TypeGuard.IsDate(left) && IsObjectDateLike(right) || index_10.TypeGuard.IsConstructor(left) && IsObjectConstructorLike(right) || index_10.TypeGuard.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsString(RecordKey(left)) ? (() => {
      return right[index_8.Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
    })() : index_10.TypeGuard.IsRecord(left) && index_10.TypeGuard.IsNumber(RecordKey(left)) ? (() => {
      return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
    })() : ExtendsResult.False;
  }
  function FromObject(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : !index_10.TypeGuard.IsObject(right) ? ExtendsResult.False : (() => {
      for (const key of Object.getOwnPropertyNames(right.properties)) {
        if (!(key in left.properties) && !index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.False;
        }
        if (index_10.TypeGuard.IsOptional(right.properties[key])) {
          return ExtendsResult.True;
        }
        if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })();
  }
  function FromPromise(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !index_10.TypeGuard.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit(left.item, right.item));
  }
  function RecordKey(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? (0, index_3.Number)() : (index_7.PatternStringExact in schema.patternProperties) ? (0, index_4.String)() : Throw("Unknown record key pattern");
  }
  function RecordValue(schema) {
    return index_7.PatternNumberExact in schema.patternProperties ? schema.patternProperties[index_7.PatternNumberExact] : (index_7.PatternStringExact in schema.patternProperties) ? schema.patternProperties[index_7.PatternStringExact] : Throw("Unable to get record value schema");
  }
  function FromRecordRight(left, right) {
    const [Key, Value] = [RecordKey(right), RecordValue(right)];
    return index_10.TypeGuard.IsLiteralString(left) && index_10.TypeGuard.IsNumber(Key) && IntoBooleanResult(Visit(left, Value)) === ExtendsResult.True ? ExtendsResult.True : index_10.TypeGuard.IsUint8Array(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsString(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsArray(left) && index_10.TypeGuard.IsNumber(Key) ? Visit(left, Value) : index_10.TypeGuard.IsObject(left) ? (() => {
      for (const key of Object.getOwnPropertyNames(left.properties)) {
        if (Property(Value, left.properties[key]) === ExtendsResult.False) {
          return ExtendsResult.False;
        }
      }
      return ExtendsResult.True;
    })() : ExtendsResult.False;
  }
  function FromRecord(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : !index_10.TypeGuard.IsRecord(right) ? ExtendsResult.False : Visit(RecordValue(left), RecordValue(right));
  }
  function FromRegExp(left, right) {
    const L = index_10.TypeGuard.IsRegExp(left) ? (0, index_4.String)() : left;
    const R = index_10.TypeGuard.IsRegExp(right) ? (0, index_4.String)() : right;
    return Visit(L, R);
  }
  function FromStringRight(left, right) {
    return index_10.TypeGuard.IsLiteral(left) && index_10.ValueGuard.IsString(left.const) ? ExtendsResult.True : index_10.TypeGuard.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromString(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromSymbol(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromTemplateLiteral(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) ? Visit((0, index_6.TemplateLiteralToUnion)(left), right) : index_10.TypeGuard.IsTemplateLiteral(right) ? Visit(left, (0, index_6.TemplateLiteralToUnion)(right)) : Throw("Invalid fallthrough for TemplateLiteral");
  }
  function IsArrayOfTuple(left, right) {
    return index_10.TypeGuard.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit(schema, right.items) === ExtendsResult.True);
  }
  function FromTupleRight(left, right) {
    return index_10.TypeGuard.IsNever(left) ? ExtendsResult.True : index_10.TypeGuard.IsUnknown(left) ? ExtendsResult.False : index_10.TypeGuard.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
  }
  function FromTuple(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : index_10.TypeGuard.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !index_10.TypeGuard.IsTuple(right) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) || !index_10.ValueGuard.IsUndefined(left.items) && index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.False : index_10.ValueGuard.IsUndefined(left.items) && !index_10.ValueGuard.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUint8Array(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUndefined(left, right) {
    return IsStructuralRight(right) ? StructuralRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsRecord(right) ? FromRecordRight(left, right) : index_10.TypeGuard.IsVoid(right) ? FromVoidRight(left, right) : index_10.TypeGuard.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnionRight(left, right) {
    return right.anyOf.some((schema) => Visit(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnion(left, right) {
    return left.anyOf.every((schema) => Visit(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromUnknownRight(left, right) {
    return ExtendsResult.True;
  }
  function FromUnknown(left, right) {
    return index_10.TypeGuard.IsNever(right) ? FromNeverRight(left, right) : index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsString(right) ? FromStringRight(left, right) : index_10.TypeGuard.IsNumber(right) ? FromNumberRight(left, right) : index_10.TypeGuard.IsInteger(right) ? FromIntegerRight(left, right) : index_10.TypeGuard.IsBoolean(right) ? FromBooleanRight(left, right) : index_10.TypeGuard.IsArray(right) ? FromArrayRight(left, right) : index_10.TypeGuard.IsTuple(right) ? FromTupleRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoidRight(left, right) {
    return index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : index_10.TypeGuard.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
  }
  function FromVoid(left, right) {
    return index_10.TypeGuard.IsIntersect(right) ? FromIntersectRight(left, right) : index_10.TypeGuard.IsUnion(right) ? FromUnionRight(left, right) : index_10.TypeGuard.IsUnknown(right) ? FromUnknownRight(left, right) : index_10.TypeGuard.IsAny(right) ? FromAnyRight(left, right) : index_10.TypeGuard.IsObject(right) ? FromObjectRight(left, right) : index_10.TypeGuard.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
  }
  function Visit(left, right) {
    return index_10.TypeGuard.IsTemplateLiteral(left) || index_10.TypeGuard.IsTemplateLiteral(right) ? FromTemplateLiteral(left, right) : index_10.TypeGuard.IsRegExp(left) || index_10.TypeGuard.IsRegExp(right) ? FromRegExp(left, right) : index_10.TypeGuard.IsNot(left) || index_10.TypeGuard.IsNot(right) ? FromNot(left, right) : index_10.TypeGuard.IsAny(left) ? FromAny(left, right) : index_10.TypeGuard.IsArray(left) ? FromArray(left, right) : index_10.TypeGuard.IsBigInt(left) ? FromBigInt(left, right) : index_10.TypeGuard.IsBoolean(left) ? FromBoolean(left, right) : index_10.TypeGuard.IsAsyncIterator(left) ? FromAsyncIterator(left, right) : index_10.TypeGuard.IsConstructor(left) ? FromConstructor(left, right) : index_10.TypeGuard.IsDate(left) ? FromDate(left, right) : index_10.TypeGuard.IsFunction(left) ? FromFunction(left, right) : index_10.TypeGuard.IsInteger(left) ? FromInteger(left, right) : index_10.TypeGuard.IsIntersect(left) ? FromIntersect(left, right) : index_10.TypeGuard.IsIterator(left) ? FromIterator(left, right) : index_10.TypeGuard.IsLiteral(left) ? FromLiteral(left, right) : index_10.TypeGuard.IsNever(left) ? FromNever(left, right) : index_10.TypeGuard.IsNull(left) ? FromNull(left, right) : index_10.TypeGuard.IsNumber(left) ? FromNumber(left, right) : index_10.TypeGuard.IsObject(left) ? FromObject(left, right) : index_10.TypeGuard.IsRecord(left) ? FromRecord(left, right) : index_10.TypeGuard.IsString(left) ? FromString(left, right) : index_10.TypeGuard.IsSymbol(left) ? FromSymbol(left, right) : index_10.TypeGuard.IsTuple(left) ? FromTuple(left, right) : index_10.TypeGuard.IsPromise(left) ? FromPromise(left, right) : index_10.TypeGuard.IsUint8Array(left) ? FromUint8Array(left, right) : index_10.TypeGuard.IsUndefined(left) ? FromUndefined(left, right) : index_10.TypeGuard.IsUnion(left) ? FromUnion(left, right) : index_10.TypeGuard.IsUnknown(left) ? FromUnknown(left, right) : index_10.TypeGuard.IsVoid(left) ? FromVoid(left, right) : Throw(`Unknown left type operand '${left[index_8.Kind]}'`);
  }
  function ExtendsCheck(left, right) {
    return Visit(left, right);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-result.js
var require_extends_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedResult = ExtendsFromMappedResult;
  var index_1 = require_mapped2();
  var extends_1 = require_extends();
  function FromProperties(P, Right, True, False, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extends_1.Extends)(P[K2], Right, True, False, options);
    return Acc;
  }
  function FromMappedResult(Left, Right, True, False, options) {
    return FromProperties(Left.properties, Right, True, False, options);
  }
  function ExtendsFromMappedResult(Left, Right, True, False, options) {
    const P = FromMappedResult(Left, Right, True, False, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends.js
var require_extends = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extends = Extends;
  var index_1 = require_union2();
  var extends_check_1 = require_extends_check();
  var type_1 = require_type2();
  var extends_from_mapped_key_1 = require_extends_from_mapped_key();
  var extends_from_mapped_result_1 = require_extends_from_mapped_result();
  var kind_1 = require_kind();
  function ExtendsResolve(left, right, trueType, falseType) {
    const R = (0, extends_check_1.ExtendsCheck)(left, right);
    return R === extends_check_1.ExtendsResult.Union ? (0, index_1.Union)([trueType, falseType]) : R === extends_check_1.ExtendsResult.True ? trueType : falseType;
  }
  function Extends(L, R, T, F, options = {}) {
    return (0, kind_1.IsMappedResult)(L) ? (0, extends_from_mapped_result_1.ExtendsFromMappedResult)(L, R, T, F, options) : (0, kind_1.IsMappedKey)(L) ? (0, type_1.CloneType)((0, extends_from_mapped_key_1.ExtendsFromMappedKey)(L, R, T, F, options)) : (0, type_1.CloneType)(ExtendsResolve(L, R, T, F), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/extends-from-mapped-key.js
var require_extends_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtendsFromMappedKey = ExtendsFromMappedKey;
  var index_1 = require_mapped2();
  var index_2 = require_literal2();
  var extends_1 = require_extends();
  function FromPropertyKey(K, U, L, R, options) {
    return {
      [K]: (0, extends_1.Extends)((0, index_2.Literal)(K), U, L, R, options)
    };
  }
  function FromPropertyKeys(K, U, L, R, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
    }, {});
  }
  function FromMappedKey(K, U, L, R, options) {
    return FromPropertyKeys(K.keys, U, L, R, options);
  }
  function ExtendsFromMappedKey(T, U, L, R, options) {
    const P = FromMappedKey(T, U, L, R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extends/index.js
var require_extends2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extends_check(), exports);
  __exportStar(require_extends_from_mapped_key(), exports);
  __exportStar(require_extends_from_mapped_result(), exports);
  __exportStar(require_extends_undefined(), exports);
  __exportStar(require_extends(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/check/check.js
var require_check = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCheckUnknownTypeError = undefined;
  exports.Check = Check;
  var index_1 = require_system2();
  var index_2 = require_deref2();
  var index_3 = require_hash2();
  var index_4 = require_symbols2();
  var index_5 = require_keyof2();
  var index_6 = require_extends2();
  var index_7 = require_registry();
  var index_8 = require_error2();
  var index_9 = require_never2();
  var index_10 = require_guard2();
  var type_1 = require_type3();

  class ValueCheckUnknownTypeError extends index_8.TypeBoxError {
    constructor(schema) {
      super(`Unknown type`);
      this.schema = schema;
    }
  }
  exports.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
  function IsAnyOrUnknown(schema) {
    return schema[index_4.Kind] === "Any" || schema[index_4.Kind] === "Unknown";
  }
  function IsDefined(value) {
    return value !== undefined;
  }
  function FromAny(schema, references, value) {
    return true;
  }
  function FromArray(schema, references, value) {
    if (!(0, index_10.IsArray)(value))
      return false;
    if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
      return false;
    }
    if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
      return false;
    }
    if (!value.every((value2) => Visit(schema.items, references, value2))) {
      return false;
    }
    if (schema.uniqueItems === true && !function() {
      const set = new Set;
      for (const element of value) {
        const hashed = (0, index_3.Hash)(element);
        if (set.has(hashed)) {
          return false;
        } else {
          set.add(hashed);
        }
      }
      return true;
    }()) {
      return false;
    }
    if (!(IsDefined(schema.contains) || (0, index_10.IsNumber)(schema.minContains) || (0, index_10.IsNumber)(schema.maxContains))) {
      return true;
    }
    const containsSchema = IsDefined(schema.contains) ? schema.contains : (0, index_9.Never)();
    const containsCount = value.reduce((acc, value2) => Visit(containsSchema, references, value2) ? acc + 1 : acc, 0);
    if (containsCount === 0) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.minContains) && containsCount < schema.minContains) {
      return false;
    }
    if ((0, index_10.IsNumber)(schema.maxContains) && containsCount > schema.maxContains) {
      return false;
    }
    return true;
  }
  function FromAsyncIterator(schema, references, value) {
    return (0, index_10.IsAsyncIterator)(value);
  }
  function FromBigInt(schema, references, value) {
    if (!(0, index_10.IsBigInt)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
      return false;
    }
    return true;
  }
  function FromBoolean(schema, references, value) {
    return (0, index_10.IsBoolean)(value);
  }
  function FromConstructor(schema, references, value) {
    return Visit(schema.returns, references, value.prototype);
  }
  function FromDate(schema, references, value) {
    if (!(0, index_10.IsDate)(value))
      return false;
    if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
      return false;
    }
    if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
      return false;
    }
    return true;
  }
  function FromFunction(schema, references, value) {
    return (0, index_10.IsFunction)(value);
  }
  function FromInteger(schema, references, value) {
    if (!(0, index_10.IsInteger)(value)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromIntersect(schema, references, value) {
    const check1 = schema.allOf.every((schema2) => Visit(schema2, references, value));
    if (schema.unevaluatedProperties === false) {
      const keyPattern = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
      return check1 && check2;
    } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
      const keyCheck = new RegExp((0, index_5.KeyOfPattern)(schema));
      const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit(schema.unevaluatedProperties, references, value[key]));
      return check1 && check2;
    } else {
      return check1;
    }
  }
  function FromIterator(schema, references, value) {
    return (0, index_10.IsIterator)(value);
  }
  function FromLiteral(schema, references, value) {
    return value === schema.const;
  }
  function FromNever(schema, references, value) {
    return false;
  }
  function FromNot(schema, references, value) {
    return !Visit(schema.not, references, value);
  }
  function FromNull(schema, references, value) {
    return (0, index_10.IsNull)(value);
  }
  function FromNumber(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsNumberLike(value))
      return false;
    if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
      return false;
    }
    if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
      return false;
    }
    if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
      return false;
    }
    if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
      return false;
    }
    if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
      return false;
    }
    return true;
  }
  function FromObject(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsObjectLike(value))
      return false;
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const knownKeys = Object.getOwnPropertyNames(schema.properties);
    for (const knownKey of knownKeys) {
      const property = schema.properties[knownKey];
      if (schema.required && schema.required.includes(knownKey)) {
        if (!Visit(property, references, value[knownKey])) {
          return false;
        }
        if (((0, index_6.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
          return false;
        }
      } else {
        if (index_1.TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit(property, references, value[knownKey])) {
          return false;
        }
      }
    }
    if (schema.additionalProperties === false) {
      const valueKeys = Object.getOwnPropertyNames(value);
      if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
        return true;
      } else {
        return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
      }
    } else if (typeof schema.additionalProperties === "object") {
      const valueKeys = Object.getOwnPropertyNames(value);
      return valueKeys.every((key) => knownKeys.includes(key) || Visit(schema.additionalProperties, references, value[key]));
    } else {
      return true;
    }
  }
  function FromPromise(schema, references, value) {
    return (0, index_10.IsPromise)(value);
  }
  function FromRecord(schema, references, value) {
    if (!index_1.TypeSystemPolicy.IsRecordLike(value)) {
      return false;
    }
    if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
      return false;
    }
    if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
      return false;
    }
    const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
    const regex = new RegExp(patternKey);
    const check1 = Object.entries(value).every(([key, value2]) => {
      return regex.test(key) ? Visit(patternSchema, references, value2) : true;
    });
    const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
      return !regex.test(key) ? Visit(schema.additionalProperties, references, value2) : true;
    }) : true;
    const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
      return regex.test(key);
    }) : true;
    return check1 && check2 && check3;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
  }
  function FromRegExp(schema, references, value) {
    const regex = new RegExp(schema.source, schema.flags);
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    return regex.test(value);
  }
  function FromString(schema, references, value) {
    if (!(0, index_10.IsString)(value)) {
      return false;
    }
    if (IsDefined(schema.minLength)) {
      if (!(value.length >= schema.minLength))
        return false;
    }
    if (IsDefined(schema.maxLength)) {
      if (!(value.length <= schema.maxLength))
        return false;
    }
    if (IsDefined(schema.pattern)) {
      const regex = new RegExp(schema.pattern);
      if (!regex.test(value))
        return false;
    }
    if (IsDefined(schema.format)) {
      if (!index_7.FormatRegistry.Has(schema.format))
        return false;
      const func = index_7.FormatRegistry.Get(schema.format);
      return func(value);
    }
    return true;
  }
  function FromSymbol(schema, references, value) {
    return (0, index_10.IsSymbol)(value);
  }
  function FromTemplateLiteral(schema, references, value) {
    return (0, index_10.IsString)(value) && new RegExp(schema.pattern).test(value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_2.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if (!(0, index_10.IsArray)(value)) {
      return false;
    }
    if (schema.items === undefined && !(value.length === 0)) {
      return false;
    }
    if (!(value.length === schema.maxItems)) {
      return false;
    }
    if (!schema.items) {
      return true;
    }
    for (let i = 0;i < schema.items.length; i++) {
      if (!Visit(schema.items[i], references, value[i]))
        return false;
    }
    return true;
  }
  function FromUndefined(schema, references, value) {
    return (0, index_10.IsUndefined)(value);
  }
  function FromUnion(schema, references, value) {
    return schema.anyOf.some((inner) => Visit(inner, references, value));
  }
  function FromUint8Array(schema, references, value) {
    if (!(0, index_10.IsUint8Array)(value)) {
      return false;
    }
    if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
      return false;
    }
    if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
      return false;
    }
    return true;
  }
  function FromUnknown(schema, references, value) {
    return true;
  }
  function FromVoid(schema, references, value) {
    return index_1.TypeSystemPolicy.IsVoidLike(value);
  }
  function FromKind(schema, references, value) {
    if (!index_7.TypeRegistry.Has(schema[index_4.Kind]))
      return false;
    const func = index_7.TypeRegistry.Get(schema[index_4.Kind]);
    return func(schema, value);
  }
  function Visit(schema, references, value) {
    const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Any":
        return FromAny(schema_, references_, value);
      case "Array":
        return FromArray(schema_, references_, value);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_, value);
      case "BigInt":
        return FromBigInt(schema_, references_, value);
      case "Boolean":
        return FromBoolean(schema_, references_, value);
      case "Constructor":
        return FromConstructor(schema_, references_, value);
      case "Date":
        return FromDate(schema_, references_, value);
      case "Function":
        return FromFunction(schema_, references_, value);
      case "Integer":
        return FromInteger(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Iterator":
        return FromIterator(schema_, references_, value);
      case "Literal":
        return FromLiteral(schema_, references_, value);
      case "Never":
        return FromNever(schema_, references_, value);
      case "Not":
        return FromNot(schema_, references_, value);
      case "Null":
        return FromNull(schema_, references_, value);
      case "Number":
        return FromNumber(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Promise":
        return FromPromise(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "RegExp":
        return FromRegExp(schema_, references_, value);
      case "String":
        return FromString(schema_, references_, value);
      case "Symbol":
        return FromSymbol(schema_, references_, value);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Undefined":
        return FromUndefined(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      case "Uint8Array":
        return FromUint8Array(schema_, references_, value);
      case "Unknown":
        return FromUnknown(schema_, references_, value);
      case "Void":
        return FromVoid(schema_, references_, value);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_4.Kind]))
          throw new ValueCheckUnknownTypeError(schema_);
        return FromKind(schema_, references_, value);
    }
  }
  function Check(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/check/index.js
var require_check2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_check(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/clone.js
var require_clone = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clone = Clone;
  var index_1 = require_guard2();
  function ObjectType(value) {
    const Acc = {};
    for (const key of Object.getOwnPropertyNames(value)) {
      Acc[key] = Clone(value[key]);
    }
    for (const key of Object.getOwnPropertySymbols(value)) {
      Acc[key] = Clone(value[key]);
    }
    return Acc;
  }
  function ArrayType(value) {
    return value.map((element) => Clone(element));
  }
  function TypedArrayType(value) {
    return value.slice();
  }
  function DateType(value) {
    return new Date(value.toISOString());
  }
  function ValueType(value) {
    return value;
  }
  function Clone(value) {
    if ((0, index_1.IsArray)(value))
      return ArrayType(value);
    if ((0, index_1.IsDate)(value))
      return DateType(value);
    if ((0, index_1.IsStandardObject)(value))
      return ObjectType(value);
    if ((0, index_1.IsTypedArray)(value))
      return TypedArrayType(value);
    if ((0, index_1.IsValueType)(value))
      return ValueType(value);
    throw new Error("ValueClone: Unable to clone value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clone/index.js
var require_clone2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/create/create.js
var require_create = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCreateError = undefined;
  exports.Create = Create;
  var index_1 = require_guard2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_template_literal2();
  var index_6 = require_patterns2();
  var index_7 = require_registry();
  var index_8 = require_symbols2();
  var index_9 = require_error2();

  class ValueCreateError extends index_9.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports.ValueCreateError = ValueCreateError;
  function FromDefault(value) {
    return typeof value === "function" ? value : (0, index_3.Clone)(value);
  }
  function FromAny(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return {};
    }
  }
  function FromArray(schema, references) {
    if (schema.uniqueItems === true && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
    } else if ("contains" in schema && !(0, index_1.HasPropertyKey)(schema, "default")) {
      throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
    } else if ("default" in schema) {
      return FromDefault(schema.default);
    } else if (schema.minItems !== undefined) {
      return Array.from({ length: schema.minItems }).map((item) => {
        return Visit(schema.items, references);
      });
    } else {
      return [];
    }
  }
  function FromAsyncIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return async function* () {}();
    }
  }
  function FromBigInt(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return BigInt(0);
    }
  }
  function FromBoolean(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return false;
    }
  }
  function FromConstructor(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const value = Visit(schema.returns, references);
      if (typeof value === "object" && !Array.isArray(value)) {
        return class {
          constructor() {
            for (const [key, val] of Object.entries(value)) {
              const self2 = this;
              self2[key] = val;
            }
          }
        };
      } else {
        return class {
        };
      }
    }
  }
  function FromDate(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimumTimestamp !== undefined) {
      return new Date(schema.minimumTimestamp);
    } else {
      return new Date;
    }
  }
  function FromFunction(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return () => Visit(schema.returns, references);
    }
  }
  function FromInteger(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromIntersect(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const value = schema.allOf.reduce((acc, schema2) => {
        const next = Visit(schema2, references);
        return typeof next === "object" ? { ...acc, ...next } : next;
      }, {});
      if (!(0, index_2.Check)(schema, references, value))
        throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
      return value;
    }
  }
  function FromIterator(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return function* () {}();
    }
  }
  function FromLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return schema.const;
    }
  }
  function FromNever(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
    }
  }
  function FromNot(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "Not types must have a default value");
    }
  }
  function FromNull(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return null;
    }
  }
  function FromNumber(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minimum !== undefined) {
      return schema.minimum;
    } else {
      return 0;
    }
  }
  function FromObject(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      const required = new Set(schema.required);
      const Acc = {};
      for (const [key, subschema] of Object.entries(schema.properties)) {
        if (!required.has(key))
          continue;
        Acc[key] = Visit(subschema, references);
      }
      return Acc;
    }
  }
  function FromPromise(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Promise.resolve(Visit(schema.item, references));
    }
  }
  function FromRecord(schema, references) {
    const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (!(keyPattern === index_6.PatternStringExact || keyPattern === index_6.PatternNumberExact)) {
      const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
      const Acc = {};
      for (const key of propertyKeys)
        Acc[key] = Visit(valueSchema, references);
      return Acc;
    } else {
      return {};
    }
  }
  function FromRef(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Visit((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromRegExp(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
    }
  }
  function FromString(schema, references) {
    if (schema.pattern !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError(schema, "String types with patterns must specify a default value");
      } else {
        return FromDefault(schema.default);
      }
    } else if (schema.format !== undefined) {
      if (!(0, index_1.HasPropertyKey)(schema, "default")) {
        throw new ValueCreateError(schema, "String types with formats must specify a default value");
      } else {
        return FromDefault(schema.default);
      }
    } else {
      if ((0, index_1.HasPropertyKey)(schema, "default")) {
        return FromDefault(schema.default);
      } else if (schema.minLength !== undefined) {
        return Array.from({ length: schema.minLength }).map(() => " ").join("");
      } else {
        return "";
      }
    }
  }
  function FromSymbol(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if ("value" in schema) {
      return Symbol.for(schema.value);
    } else {
      return Symbol();
    }
  }
  function FromTemplateLiteral(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    }
    if (!(0, index_5.IsTemplateLiteralFinite)(schema))
      throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
    const generated = (0, index_5.TemplateLiteralGenerate)(schema);
    return generated[0];
  }
  function FromThis(schema, references) {
    if (recursiveDepth++ > recursiveMaxDepth)
      throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return Visit((0, index_4.Deref)(schema, references), references);
    }
  }
  function FromTuple(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    }
    if (schema.items === undefined) {
      return [];
    } else {
      return Array.from({ length: schema.minItems }).map((_, index) => Visit(schema.items[index], references));
    }
  }
  function FromUndefined(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return;
    }
  }
  function FromUnion(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.anyOf.length === 0) {
      throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
    } else {
      return Visit(schema.anyOf[0], references);
    }
  }
  function FromUint8Array(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minByteLength !== undefined) {
      return new Uint8Array(schema.minByteLength);
    } else {
      return new Uint8Array(0);
    }
  }
  function FromUnknown(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return {};
    }
  }
  function FromVoid(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      return;
    }
  }
  function FromKind(schema, references) {
    if ((0, index_1.HasPropertyKey)(schema, "default")) {
      return FromDefault(schema.default);
    } else {
      throw new Error("User defined types must specify a default value");
    }
  }
  function Visit(schema, references) {
    const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_8.Kind]) {
      case "Any":
        return FromAny(schema_, references_);
      case "Array":
        return FromArray(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_);
      case "BigInt":
        return FromBigInt(schema_, references_);
      case "Boolean":
        return FromBoolean(schema_, references_);
      case "Constructor":
        return FromConstructor(schema_, references_);
      case "Date":
        return FromDate(schema_, references_);
      case "Function":
        return FromFunction(schema_, references_);
      case "Integer":
        return FromInteger(schema_, references_);
      case "Intersect":
        return FromIntersect(schema_, references_);
      case "Iterator":
        return FromIterator(schema_, references_);
      case "Literal":
        return FromLiteral(schema_, references_);
      case "Never":
        return FromNever(schema_, references_);
      case "Not":
        return FromNot(schema_, references_);
      case "Null":
        return FromNull(schema_, references_);
      case "Number":
        return FromNumber(schema_, references_);
      case "Object":
        return FromObject(schema_, references_);
      case "Promise":
        return FromPromise(schema_, references_);
      case "Record":
        return FromRecord(schema_, references_);
      case "Ref":
        return FromRef(schema_, references_);
      case "RegExp":
        return FromRegExp(schema_, references_);
      case "String":
        return FromString(schema_, references_);
      case "Symbol":
        return FromSymbol(schema_, references_);
      case "TemplateLiteral":
        return FromTemplateLiteral(schema_, references_);
      case "This":
        return FromThis(schema_, references_);
      case "Tuple":
        return FromTuple(schema_, references_);
      case "Undefined":
        return FromUndefined(schema_, references_);
      case "Union":
        return FromUnion(schema_, references_);
      case "Uint8Array":
        return FromUint8Array(schema_, references_);
      case "Unknown":
        return FromUnknown(schema_, references_);
      case "Void":
        return FromVoid(schema_, references_);
      default:
        if (!index_7.TypeRegistry.Has(schema_[index_8.Kind]))
          throw new ValueCreateError(schema_, "Unknown type");
        return FromKind(schema_, references_);
    }
  }
  var recursiveMaxDepth = 512;
  var recursiveDepth = 0;
  function Create(...args) {
    recursiveDepth = 0;
    return args.length === 2 ? Visit(args[0], args[1]) : Visit(args[0], []);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/create/index.js
var require_create2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_create(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/cast.js
var require_cast = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueCastError = undefined;
  exports.Cast = Cast;
  var index_1 = require_guard2();
  var index_2 = require_error2();
  var index_3 = require_symbols2();
  var index_4 = require_create2();
  var index_5 = require_check2();
  var index_6 = require_clone2();
  var index_7 = require_deref2();

  class ValueCastError extends index_2.TypeBoxError {
    constructor(schema, message) {
      super(message);
      this.schema = schema;
    }
  }
  exports.ValueCastError = ValueCastError;
  function ScoreUnion(schema, references, value) {
    if (schema[index_3.Kind] === "Object" && typeof value === "object" && !(0, index_1.IsNull)(value)) {
      const object = schema;
      const keys = Object.getOwnPropertyNames(value);
      const entries = Object.entries(object.properties);
      const [point, max] = [1 / entries.length, entries.length];
      return entries.reduce((acc, [key, schema2]) => {
        const literal = schema2[index_3.Kind] === "Literal" && schema2.const === value[key] ? max : 0;
        const checks = (0, index_5.Check)(schema2, references, value[key]) ? point : 0;
        const exists = keys.includes(key) ? point : 0;
        return acc + (literal + checks + exists);
      }, 0);
    } else {
      return (0, index_5.Check)(schema, references, value) ? 1 : 0;
    }
  }
  function SelectUnion(union, references, value) {
    const schemas = union.anyOf.map((schema) => (0, index_7.Deref)(schema, references));
    let [select, best] = [schemas[0], 0];
    for (const schema of schemas) {
      const score = ScoreUnion(schema, references, value);
      if (score > best) {
        select = schema;
        best = score;
      }
    }
    return select;
  }
  function CastUnion(union, references, value) {
    if ("default" in union) {
      return typeof value === "function" ? union.default : (0, index_6.Clone)(union.default);
    } else {
      const schema = SelectUnion(union, references, value);
      return Cast(schema, references, value);
    }
  }
  function DefaultClone(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
  }
  function Default(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? value : (0, index_4.Create)(schema, references);
  }
  function FromArray(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    const created = (0, index_1.IsArray)(value) ? (0, index_6.Clone)(value) : (0, index_4.Create)(schema, references);
    const minimum = (0, index_1.IsNumber)(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
    const maximum = (0, index_1.IsNumber)(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
    const casted = maximum.map((value2) => Visit(schema.items, references, value2));
    if (schema.uniqueItems !== true)
      return casted;
    const unique = [...new Set(casted)];
    if (!(0, index_5.Check)(schema, references, unique))
      throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
    return unique;
  }
  function FromConstructor(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.returns.required || []);
    const result = function() {};
    for (const [key, property] of Object.entries(schema.returns.properties)) {
      if (!required.has(key) && value.prototype[key] === undefined)
        continue;
      result.prototype[key] = Visit(property, references, value.prototype[key]);
    }
    return result;
  }
  function FromIntersect(schema, references, value) {
    const created = (0, index_4.Create)(schema, references);
    const mapped = (0, index_1.IsStandardObject)(created) && (0, index_1.IsStandardObject)(value) ? { ...created, ...value } : value;
    return (0, index_5.Check)(schema, references, mapped) ? mapped : (0, index_4.Create)(schema, references);
  }
  function FromNever(schema, references, value) {
    throw new ValueCastError(schema, "Never types cannot be cast");
  }
  function FromObject(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return value;
    if (value === null || typeof value !== "object")
      return (0, index_4.Create)(schema, references);
    const required = new Set(schema.required || []);
    const result = {};
    for (const [key, property] of Object.entries(schema.properties)) {
      if (!required.has(key) && value[key] === undefined)
        continue;
      result[key] = Visit(property, references, value[key]);
    }
    if (typeof schema.additionalProperties === "object") {
      const propertyNames = Object.getOwnPropertyNames(schema.properties);
      for (const propertyName of Object.getOwnPropertyNames(value)) {
        if (propertyNames.includes(propertyName))
          continue;
        result[propertyName] = Visit(schema.additionalProperties, references, value[propertyName]);
      }
    }
    return result;
  }
  function FromRecord(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
      return (0, index_4.Create)(schema, references);
    const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const subschema = schema.patternProperties[subschemaPropertyName];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(subschema, references, propValue);
    }
    return result;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_7.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if ((0, index_5.Check)(schema, references, value))
      return (0, index_6.Clone)(value);
    if (!(0, index_1.IsArray)(value))
      return (0, index_4.Create)(schema, references);
    if (schema.items === undefined)
      return [];
    return schema.items.map((schema2, index) => Visit(schema2, references, value[index]));
  }
  function FromUnion(schema, references, value) {
    return (0, index_5.Check)(schema, references, value) ? (0, index_6.Clone)(value) : CastUnion(schema, references, value);
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_1.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_3.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Constructor":
        return FromConstructor(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Never":
        return FromNever(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      case "Date":
      case "Symbol":
      case "Uint8Array":
        return DefaultClone(schema, references, value);
      default:
        return Default(schema_, references_, value);
    }
  }
  function Cast(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/cast/index.js
var require_cast2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_cast(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/clean.js
var require_clean = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Clean = Clean;
  var index_1 = require_keyof2();
  var index_2 = require_check2();
  var index_3 = require_clone2();
  var index_4 = require_deref2();
  var index_5 = require_symbols2();
  var index_6 = require_guard2();
  var type_1 = require_type3();
  function IsCheckable(schema) {
    return (0, type_1.IsSchema)(schema) && schema[index_5.Kind] !== "Unsafe";
  }
  function FromArray(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    return value.map((value2) => Visit(schema.items, references, value2));
  }
  function FromIntersect(schema, references, value) {
    const unevaluatedProperties = schema.unevaluatedProperties;
    const intersections = schema.allOf.map((schema2) => Visit(schema2, references, (0, index_3.Clone)(value)));
    const composite = intersections.reduce((acc, value2) => (0, index_6.IsObject)(value2) ? { ...acc, ...value2 } : value2, {});
    if (!(0, index_6.IsObject)(value) || !(0, index_6.IsObject)(composite) || !(0, type_1.IsSchema)(unevaluatedProperties))
      return composite;
    const knownkeys = (0, index_1.KeyOfPropertyKeys)(schema);
    for (const key of Object.getOwnPropertyNames(value)) {
      if (knownkeys.includes(key))
        continue;
      if ((0, index_2.Check)(unevaluatedProperties, references, value[key])) {
        composite[key] = Visit(unevaluatedProperties, references, value[key]);
      }
    }
    return composite;
  }
  function FromObject(schema, references, value) {
    if (!(0, index_6.IsObject)(value) || (0, index_6.IsArray)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    for (const key of Object.getOwnPropertyNames(value)) {
      if (key in schema.properties) {
        value[key] = Visit(schema.properties[key], references, value[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRecord(schema, references, value) {
    if (!(0, index_6.IsObject)(value))
      return value;
    const additionalProperties = schema.additionalProperties;
    const propertyKeys = Object.getOwnPropertyNames(value);
    const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
    const propertyKeyTest = new RegExp(propertyKey);
    for (const key of propertyKeys) {
      if (propertyKeyTest.test(key)) {
        value[key] = Visit(propertySchema, references, value[key]);
        continue;
      }
      if ((0, type_1.IsSchema)(additionalProperties) && (0, index_2.Check)(additionalProperties, references, value[key])) {
        value[key] = Visit(additionalProperties, references, value[key]);
        continue;
      }
      delete value[key];
    }
    return value;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_4.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    if (!(0, index_6.IsArray)(value))
      return value;
    if ((0, index_6.IsUndefined)(schema.items))
      return [];
    const length = Math.min(value.length, schema.items.length);
    for (let i = 0;i < length; i++) {
      value[i] = Visit(schema.items[i], references, value[i]);
    }
    return value.length > length ? value.slice(0, length) : value;
  }
  function FromUnion(schema, references, value) {
    for (const inner of schema.anyOf) {
      if (IsCheckable(inner) && (0, index_2.Check)(inner, references, value)) {
        return Visit(inner, references, value);
      }
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_6.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_5.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return value;
    }
  }
  function Clean(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/clean/index.js
var require_clean2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clean(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/convert.js
var require_convert = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Convert = Convert;
  var index_1 = require_clone2();
  var index_2 = require_check2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  function IsStringNumeric(value) {
    return (0, index_5.IsString)(value) && !isNaN(value) && !isNaN(parseFloat(value));
  }
  function IsValueToString(value) {
    return (0, index_5.IsBigInt)(value) || (0, index_5.IsBoolean)(value) || (0, index_5.IsNumber)(value);
  }
  function IsValueTrue(value) {
    return value === true || (0, index_5.IsNumber)(value) && value === 1 || (0, index_5.IsBigInt)(value) && value === BigInt("1") || (0, index_5.IsString)(value) && (value.toLowerCase() === "true" || value === "1");
  }
  function IsValueFalse(value) {
    return value === false || (0, index_5.IsNumber)(value) && (value === 0 || Object.is(value, -0)) || (0, index_5.IsBigInt)(value) && value === BigInt("0") || (0, index_5.IsString)(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
  }
  function IsTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateTimeStringWithTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
  }
  function IsDateTimeStringWithoutTimeZone(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
  }
  function IsDateString(value) {
    return (0, index_5.IsString)(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
  }
  function TryConvertLiteralString(value, target) {
    const conversion = TryConvertString(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralNumber(value, target) {
    const conversion = TryConvertNumber(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteralBoolean(value, target) {
    const conversion = TryConvertBoolean(value);
    return conversion === target ? conversion : value;
  }
  function TryConvertLiteral(schema, value) {
    return (0, index_5.IsString)(schema.const) ? TryConvertLiteralString(value, schema.const) : (0, index_5.IsNumber)(schema.const) ? TryConvertLiteralNumber(value, schema.const) : (0, index_5.IsBoolean)(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : (0, index_1.Clone)(value);
  }
  function TryConvertBoolean(value) {
    return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
  }
  function TryConvertBigInt(value) {
    return IsStringNumeric(value) ? BigInt(parseInt(value)) : (0, index_5.IsNumber)(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
  }
  function TryConvertString(value) {
    return IsValueToString(value) ? value.toString() : (0, index_5.IsSymbol)(value) && value.description !== undefined ? value.description.toString() : value;
  }
  function TryConvertNumber(value) {
    return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertInteger(value) {
    return IsStringNumeric(value) ? parseInt(value) : (0, index_5.IsNumber)(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
  }
  function TryConvertNull(value) {
    return (0, index_5.IsString)(value) && value.toLowerCase() === "null" ? null : value;
  }
  function TryConvertUndefined(value) {
    return (0, index_5.IsString)(value) && value === "undefined" ? undefined : value;
  }
  function TryConvertDate(value) {
    return (0, index_5.IsDate)(value) ? value : (0, index_5.IsNumber)(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
  }
  function Default(value) {
    return value;
  }
  function FromArray(schema, references, value) {
    const elements = (0, index_5.IsArray)(value) ? value : [value];
    return elements.map((element) => Visit(schema.items, references, element));
  }
  function FromBigInt(schema, references, value) {
    return TryConvertBigInt(value);
  }
  function FromBoolean(schema, references, value) {
    return TryConvertBoolean(value);
  }
  function FromDate(schema, references, value) {
    return TryConvertDate(value);
  }
  function FromInteger(schema, references, value) {
    return TryConvertInteger(value);
  }
  function FromIntersect(schema, references, value) {
    return schema.allOf.reduce((value2, schema2) => Visit(schema2, references, value2), value);
  }
  function FromLiteral(schema, references, value) {
    return TryConvertLiteral(schema, value);
  }
  function FromNull(schema, references, value) {
    return TryConvertNull(value);
  }
  function FromNumber(schema, references, value) {
    return TryConvertNumber(value);
  }
  function FromObject(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const result = {};
    for (const key of Object.keys(value)) {
      result[key] = (0, index_5.HasPropertyKey)(schema.properties, key) ? Visit(schema.properties[key], references, value[key]) : value[key];
    }
    return result;
  }
  function FromRecord(schema, references, value) {
    const isConvertable = (0, index_5.IsObject)(value);
    if (!isConvertable)
      return value;
    const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[propertyKey];
    const result = {};
    for (const [propKey, propValue] of Object.entries(value)) {
      result[propKey] = Visit(property, references, propValue);
    }
    return result;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromString(schema, references, value) {
    return TryConvertString(value);
  }
  function FromSymbol(schema, references, value) {
    return (0, index_5.IsString)(value) || (0, index_5.IsNumber)(value) ? Symbol(value) : value;
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    const isConvertable = (0, index_5.IsArray)(value) && !(0, index_5.IsUndefined)(schema.items);
    if (!isConvertable)
      return value;
    return value.map((value2, index) => {
      return index < schema.items.length ? Visit(schema.items[index], references, value2) : value2;
    });
  }
  function FromUndefined(schema, references, value) {
    return TryConvertUndefined(value);
  }
  function FromUnion(schema, references, value) {
    for (const subschema of schema.anyOf) {
      const converted = Visit(subschema, references, value);
      if (!(0, index_2.Check)(subschema, references, converted))
        continue;
      return converted;
    }
    return value;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_4.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "BigInt":
        return FromBigInt(schema_, references_, value);
      case "Boolean":
        return FromBoolean(schema_, references_, value);
      case "Date":
        return FromDate(schema_, references_, value);
      case "Integer":
        return FromInteger(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Literal":
        return FromLiteral(schema_, references_, value);
      case "Null":
        return FromNull(schema_, references_, value);
      case "Number":
        return FromNumber(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "String":
        return FromString(schema_, references_, value);
      case "Symbol":
        return FromSymbol(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Undefined":
        return FromUndefined(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return Default(value);
    }
  }
  function Convert(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/convert/index.js
var require_convert2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_convert(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/default/default.js
var require_default = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Default = Default;
  var index_1 = require_check2();
  var index_2 = require_clone2();
  var index_3 = require_deref2();
  var index_4 = require_symbols2();
  var index_5 = require_guard2();
  var type_1 = require_type3();
  function ValueOrDefault(schema, value) {
    return value === undefined && "default" in schema ? (0, index_2.Clone)(schema.default) : value;
  }
  function IsCheckable(schema) {
    return (0, type_1.IsSchema)(schema) && schema[index_4.Kind] !== "Unsafe";
  }
  function IsDefaultSchema(value) {
    return (0, type_1.IsSchema)(value) && "default" in value;
  }
  function FromArray(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted))
      return defaulted;
    for (let i = 0;i < defaulted.length; i++) {
      defaulted[i] = Visit(schema.items, references, defaulted[i]);
    }
    return defaulted;
  }
  function FromIntersect(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    return schema.allOf.reduce((acc, schema2) => {
      const next = Visit(schema2, references, defaulted);
      return (0, index_5.IsObject)(next) ? { ...acc, ...next } : next;
    }, {});
  }
  function FromObject(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
    for (const key of knownPropertyKeys) {
      if (!IsDefaultSchema(schema.properties[key]))
        continue;
      defaulted[key] = Visit(schema.properties[key], references, defaulted[key]);
    }
    if (!IsDefaultSchema(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKeys.includes(key))
        continue;
      defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRecord(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsObject)(defaulted))
      return defaulted;
    const additionalPropertiesSchema = schema.additionalProperties;
    const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
    const knownPropertyKey = new RegExp(propertyKeyPattern);
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
        continue;
      defaulted[key] = Visit(propertySchema, references, defaulted[key]);
    }
    if (!IsDefaultSchema(additionalPropertiesSchema))
      return defaulted;
    for (const key of Object.getOwnPropertyNames(defaulted)) {
      if (knownPropertyKey.test(key))
        continue;
      defaulted[key] = Visit(additionalPropertiesSchema, references, defaulted[key]);
    }
    return defaulted;
  }
  function FromRef(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, ValueOrDefault(schema, value));
  }
  function FromThis(schema, references, value) {
    return Visit((0, index_3.Deref)(schema, references), references, value);
  }
  function FromTuple(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    if (!(0, index_5.IsArray)(defaulted) || (0, index_5.IsUndefined)(schema.items))
      return defaulted;
    const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
    for (let i = 0;i < max; i++) {
      if (i < items.length)
        defaulted[i] = Visit(items[i], references, defaulted[i]);
    }
    return defaulted;
  }
  function FromUnion(schema, references, value) {
    const defaulted = ValueOrDefault(schema, value);
    for (const inner of schema.anyOf) {
      const result = Visit(inner, references, defaulted);
      if (IsCheckable(inner) && (0, index_1.Check)(inner, result)) {
        return result;
      }
    }
    return defaulted;
  }
  function Visit(schema, references, value) {
    const references_ = (0, index_5.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema_[index_4.Kind]) {
      case "Array":
        return FromArray(schema_, references_, value);
      case "Intersect":
        return FromIntersect(schema_, references_, value);
      case "Object":
        return FromObject(schema_, references_, value);
      case "Record":
        return FromRecord(schema_, references_, value);
      case "Ref":
        return FromRef(schema_, references_, value);
      case "This":
        return FromThis(schema_, references_, value);
      case "Tuple":
        return FromTuple(schema_, references_, value);
      case "Union":
        return FromUnion(schema_, references_, value);
      default:
        return ValueOrDefault(schema_, value);
    }
  }
  function Default(...args) {
    return args.length === 3 ? Visit(args[0], args[1], args[2]) : Visit(args[0], [], args[1]);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/default/index.js
var require_default2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_default(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/pointer.js
var require_pointer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointerRootDeleteError = exports.ValuePointerRootSetError = undefined;
  exports.Format = Format;
  exports.Set = Set2;
  exports.Delete = Delete;
  exports.Has = Has;
  exports.Get = Get;
  var index_1 = require_error2();

  class ValuePointerRootSetError extends index_1.TypeBoxError {
    constructor(value, path, update) {
      super("Cannot set root value");
      this.value = value;
      this.path = path;
      this.update = update;
    }
  }
  exports.ValuePointerRootSetError = ValuePointerRootSetError;

  class ValuePointerRootDeleteError extends index_1.TypeBoxError {
    constructor(value, path) {
      super("Cannot delete root value");
      this.value = value;
      this.path = path;
    }
  }
  exports.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
  function Escape(component) {
    return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
  }
  function* Format(pointer) {
    if (pointer === "")
      return;
    let [start, end] = [0, 0];
    for (let i = 0;i < pointer.length; i++) {
      const char = pointer.charAt(i);
      if (char === "/") {
        if (i === 0) {
          start = i + 1;
        } else {
          end = i;
          yield Escape(pointer.slice(start, end));
          start = i + 1;
        }
      } else {
        end = i;
      }
    }
    yield Escape(pointer.slice(start));
  }
  function Set2(value, pointer, update) {
    if (pointer === "")
      throw new ValuePointerRootSetError(value, pointer, update);
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined)
        next[component] = {};
      owner = next;
      next = next[component];
      key = component;
    }
    owner[key] = update;
  }
  function Delete(value, pointer) {
    if (pointer === "")
      throw new ValuePointerRootDeleteError(value, pointer);
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined || next[component] === null)
        return;
      owner = next;
      next = next[component];
      key = component;
    }
    if (Array.isArray(owner)) {
      const index = parseInt(key);
      owner.splice(index, 1);
    } else {
      delete owner[key];
    }
  }
  function Has(value, pointer) {
    if (pointer === "")
      return true;
    let [owner, next, key] = [null, value, ""];
    for (const component of Format(pointer)) {
      if (next[component] === undefined)
        return false;
      owner = next;
      next = next[component];
      key = component;
    }
    return Object.getOwnPropertyNames(owner).includes(key);
  }
  function Get(value, pointer) {
    if (pointer === "")
      return value;
    let current = value;
    for (const component of Format(pointer)) {
      if (current[component] === undefined)
        return;
      current = current[component];
    }
    return current;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/pointer/index.js
var require_pointer2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValuePointer = undefined;
  exports.ValuePointer = require_pointer();
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/delta.js
var require_delta = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueDeltaSymbolError = exports.ValueDeltaError = exports.Edit = exports.Delete = exports.Update = exports.Insert = undefined;
  exports.Diff = Diff;
  exports.Patch = Patch;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();
  var index_5 = require_literal2();
  var index_6 = require_object2();
  var index_7 = require_string2();
  var index_8 = require_unknown2();
  var index_9 = require_union2();
  exports.Insert = (0, index_6.Object)({
    type: (0, index_5.Literal)("insert"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Update = (0, index_6.Object)({
    type: (0, index_5.Literal)("update"),
    path: (0, index_7.String)(),
    value: (0, index_8.Unknown)()
  });
  exports.Delete = (0, index_6.Object)({
    type: (0, index_5.Literal)("delete"),
    path: (0, index_7.String)()
  });
  exports.Edit = (0, index_9.Union)([exports.Insert, exports.Update, exports.Delete]);

  class ValueDeltaError extends index_4.TypeBoxError {
    constructor(value, message) {
      super(message);
      this.value = value;
    }
  }
  exports.ValueDeltaError = ValueDeltaError;

  class ValueDeltaSymbolError extends ValueDeltaError {
    constructor(value) {
      super(value, "Cannot diff objects with symbol keys");
      this.value = value;
    }
  }
  exports.ValueDeltaSymbolError = ValueDeltaSymbolError;
  function CreateUpdate(path, value) {
    return { type: "update", path, value };
  }
  function CreateInsert(path, value) {
    return { type: "insert", path, value };
  }
  function CreateDelete(path) {
    return { type: "delete", path };
  }
  function* ObjectType(path, current, next) {
    if (!(0, index_1.IsStandardObject)(next))
      return yield CreateUpdate(path, next);
    const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
    const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
    for (const key of currentKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(next[key]) && nextKeys.includes(key))
        yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsUndefined)(current[key]) || (0, index_1.IsUndefined)(next[key]))
        continue;
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      yield* Visit(`${path}/${globalThis.String(key)}`, current[key], next[key]);
    }
    for (const key of nextKeys) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(current[key]))
        yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
    }
    for (const key of currentKeys.reverse()) {
      if ((0, index_1.IsSymbol)(key))
        throw new ValueDeltaSymbolError(key);
      if ((0, index_1.IsUndefined)(next[key]) && !nextKeys.includes(key))
        yield CreateDelete(`${path}/${globalThis.String(key)}`);
    }
  }
  function* ArrayType(path, current, next) {
    if (!(0, index_1.IsArray)(next))
      return yield CreateUpdate(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
    for (let i = 0;i < next.length; i++) {
      if (i < current.length)
        continue;
      yield CreateInsert(`${path}/${i}`, next[i]);
    }
    for (let i = current.length - 1;i >= 0; i--) {
      if (i < next.length)
        continue;
      yield CreateDelete(`${path}/${i}`);
    }
  }
  function* TypedArrayType(path, current, next) {
    if (!(0, index_1.IsTypedArray)(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
      return yield CreateUpdate(path, next);
    for (let i = 0;i < Math.min(current.length, next.length); i++) {
      yield* Visit(`${path}/${i}`, current[i], next[i]);
    }
  }
  function* ValueType(path, current, next) {
    if (current === next)
      return;
    yield CreateUpdate(path, next);
  }
  function* Visit(path, current, next) {
    if ((0, index_1.IsStandardObject)(current))
      return yield* ObjectType(path, current, next);
    if ((0, index_1.IsArray)(current))
      return yield* ArrayType(path, current, next);
    if ((0, index_1.IsTypedArray)(current))
      return yield* TypedArrayType(path, current, next);
    if ((0, index_1.IsValueType)(current))
      return yield* ValueType(path, current, next);
    throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
  }
  function Diff(current, next) {
    return [...Visit("", current, next)];
  }
  function IsRootUpdate(edits) {
    return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
  }
  function IsIdentity(edits) {
    return edits.length === 0;
  }
  function Patch(current, edits) {
    if (IsRootUpdate(edits)) {
      return (0, index_3.Clone)(edits[0].value);
    }
    if (IsIdentity(edits)) {
      return (0, index_3.Clone)(current);
    }
    const clone = (0, index_3.Clone)(current);
    for (const edit of edits) {
      switch (edit.type) {
        case "insert": {
          index_2.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "update": {
          index_2.ValuePointer.Set(clone, edit.path, edit.value);
          break;
        }
        case "delete": {
          index_2.ValuePointer.Delete(clone, edit.path);
          break;
        }
      }
    }
    return clone;
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/delta/index.js
var require_delta2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_delta(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/equal.js
var require_equal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Equal = Equal;
  var index_1 = require_guard2();
  function ObjectType(left, right) {
    if (!(0, index_1.IsStandardObject)(right))
      return false;
    const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
    const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
    if (leftKeys.length !== rightKeys.length)
      return false;
    return leftKeys.every((key) => Equal(left[key], right[key]));
  }
  function DateType(left, right) {
    return (0, index_1.IsDate)(right) && left.getTime() === right.getTime();
  }
  function ArrayType(left, right) {
    if (!(0, index_1.IsArray)(right) || left.length !== right.length)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function TypedArrayType(left, right) {
    if (!(0, index_1.IsTypedArray)(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
      return false;
    return left.every((value, index) => Equal(value, right[index]));
  }
  function ValueType(left, right) {
    return left === right;
  }
  function Equal(left, right) {
    if ((0, index_1.IsStandardObject)(left))
      return ObjectType(left, right);
    if ((0, index_1.IsDate)(left))
      return DateType(left, right);
    if ((0, index_1.IsTypedArray)(left))
      return TypedArrayType(left, right);
    if ((0, index_1.IsArray)(left))
      return ArrayType(left, right);
    if ((0, index_1.IsValueType)(left))
      return ValueType(left, right);
    throw new Error("ValueEquals: Unable to compare value");
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/equal/index.js
var require_equal2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_equal(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/mutate.js
var require_mutate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueMutateError = undefined;
  exports.Mutate = Mutate;
  var index_1 = require_guard2();
  var index_2 = require_pointer2();
  var index_3 = require_clone2();
  var index_4 = require_error2();

  class ValueMutateError extends index_4.TypeBoxError {
    constructor(message) {
      super(message);
    }
  }
  exports.ValueMutateError = ValueMutateError;
  function ObjectType(root, path, current, next) {
    if (!(0, index_1.IsStandardObject)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      const currentKeys = Object.getOwnPropertyNames(current);
      const nextKeys = Object.getOwnPropertyNames(next);
      for (const currentKey of currentKeys) {
        if (!nextKeys.includes(currentKey)) {
          delete current[currentKey];
        }
      }
      for (const nextKey of nextKeys) {
        if (!currentKeys.includes(nextKey)) {
          current[nextKey] = null;
        }
      }
      for (const nextKey of nextKeys) {
        Visit(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
      }
    }
  }
  function ArrayType(root, path, current, next) {
    if (!(0, index_1.IsArray)(current)) {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    } else {
      for (let index = 0;index < next.length; index++) {
        Visit(root, `${path}/${index}`, current[index], next[index]);
      }
      current.splice(next.length);
    }
  }
  function TypedArrayType(root, path, current, next) {
    if ((0, index_1.IsTypedArray)(current) && current.length === next.length) {
      for (let i = 0;i < current.length; i++) {
        current[i] = next[i];
      }
    } else {
      index_2.ValuePointer.Set(root, path, (0, index_3.Clone)(next));
    }
  }
  function ValueType(root, path, current, next) {
    if (current === next)
      return;
    index_2.ValuePointer.Set(root, path, next);
  }
  function Visit(root, path, current, next) {
    if ((0, index_1.IsArray)(next))
      return ArrayType(root, path, current, next);
    if ((0, index_1.IsTypedArray)(next))
      return TypedArrayType(root, path, current, next);
    if ((0, index_1.IsStandardObject)(next))
      return ObjectType(root, path, current, next);
    if ((0, index_1.IsValueType)(next))
      return ValueType(root, path, current, next);
  }
  function IsNonMutableValue(value) {
    return (0, index_1.IsTypedArray)(value) || (0, index_1.IsValueType)(value);
  }
  function IsMismatchedValue(current, next) {
    return (0, index_1.IsStandardObject)(current) && (0, index_1.IsArray)(next) || (0, index_1.IsArray)(current) && (0, index_1.IsStandardObject)(next);
  }
  function Mutate(current, next) {
    if (IsNonMutableValue(current) || IsNonMutableValue(next))
      throw new ValueMutateError("Only object and array types can be mutated at the root level");
    if (IsMismatchedValue(current, next))
      throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
    Visit(current, "", current, next);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/mutate/index.js
var require_mutate2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_mutate(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/decode.js
var require_decode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformDecodeError = exports.TransformDecodeCheckError = undefined;
  exports.TransformDecode = TransformDecode;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var type_1 = require_type3();

  class TransformDecodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error) {
      super(`Unable to decode value as it does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error;
    }
  }
  exports.TransformDecodeCheckError = TransformDecodeCheckError;

  class TransformDecodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error) {
      super(error instanceof Error ? error.message : "Unknown error");
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error;
    }
  }
  exports.TransformDecodeError = TransformDecodeError;
  function Default(schema, path, value) {
    try {
      return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Decode(value) : value;
    } catch (error) {
      throw new TransformDecodeError(schema, path, value, error);
    }
  }
  function FromArray(schema, references, path, value) {
    return (0, index_6.IsArray)(value) ? Default(schema, path, value.map((value2, index) => Visit(schema.items, references, `${path}/${index}`, value2))) : Default(schema, path, value);
  }
  function FromIntersect(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
      return Default(schema, path, value);
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...value };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromNot(schema, references, path, value) {
    return Default(schema, path, Visit(schema.not, references, path, value));
  }
  function FromObject(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value))
      return Default(schema, path, value);
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...value };
    for (const key of knownKeys)
      if (key in knownProperties) {
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromRecord(schema, references, path, value) {
    if (!(0, index_6.IsStandardObject)(value))
      return Default(schema, path, value);
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...value };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const unknownProperties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        unknownProperties[key] = Default(additionalProperties, `${path}/${key}`, unknownProperties[key]);
      }
    return Default(schema, path, unknownProperties);
  }
  function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
  }
  function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    return Default(schema, path, Visit(target, references, path, value));
  }
  function FromTuple(schema, references, path, value) {
    return (0, index_6.IsArray)(value) && (0, index_6.IsArray)(schema.items) ? Default(schema, path, schema.items.map((schema2, index) => Visit(schema2, references, `${path}/${index}`, value[index]))) : Default(schema, path, value);
  }
  function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const decoded = Visit(subschema, references, path, value);
      return Default(schema, path, decoded);
    }
    return Default(schema, path, value);
  }
  function Visit(schema, references, path, value) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect(schema_, references_, path, value);
      case "Not":
        return FromNot(schema_, references_, path, value);
      case "Object":
        return FromObject(schema_, references_, path, value);
      case "Record":
        return FromRecord(schema_, references_, path, value);
      case "Ref":
        return FromRef(schema_, references_, path, value);
      case "Symbol":
        return Default(schema_, path, value);
      case "This":
        return FromThis(schema_, references_, path, value);
      case "Tuple":
        return FromTuple(schema_, references_, path, value);
      case "Union":
        return FromUnion(schema_, references_, path, value);
      default:
        return Default(schema_, path, value);
    }
  }
  function TransformDecode(schema, references, value) {
    return Visit(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/encode.js
var require_encode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncodeError = exports.TransformEncodeCheckError = undefined;
  exports.TransformEncode = TransformEncode;
  var index_1 = require_symbols2();
  var index_2 = require_error2();
  var index_3 = require_keyof2();
  var index_4 = require_deref2();
  var index_5 = require_check2();
  var index_6 = require_guard2();
  var type_1 = require_type3();

  class TransformEncodeCheckError extends index_2.TypeBoxError {
    constructor(schema, value, error) {
      super(`The encoded value does not match the expected schema`);
      this.schema = schema;
      this.value = value;
      this.error = error;
    }
  }
  exports.TransformEncodeCheckError = TransformEncodeCheckError;

  class TransformEncodeError extends index_2.TypeBoxError {
    constructor(schema, path, value, error) {
      super(`${error instanceof Error ? error.message : "Unknown error"}`);
      this.schema = schema;
      this.path = path;
      this.value = value;
      this.error = error;
    }
  }
  exports.TransformEncodeError = TransformEncodeError;
  function Default(schema, path, value) {
    try {
      return (0, type_1.IsTransform)(schema) ? schema[index_1.TransformKind].Encode(value) : value;
    } catch (error) {
      throw new TransformEncodeError(schema, path, value, error);
    }
  }
  function FromArray(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    return (0, index_6.IsArray)(defaulted) ? defaulted.map((value2, index) => Visit(schema.items, references, `${path}/${index}`, value2)) : defaulted;
  }
  function FromIntersect(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(value) || (0, index_6.IsValueType)(value))
      return defaulted;
    const knownEntries = (0, index_3.KeyOfPropertyEntries)(schema);
    const knownKeys = knownEntries.map((entry) => entry[0]);
    const knownProperties = { ...defaulted };
    for (const [knownKey, knownSchema] of knownEntries)
      if (knownKey in knownProperties) {
        knownProperties[knownKey] = Visit(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
      }
    if (!(0, type_1.IsTransform)(schema.unevaluatedProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const unevaluatedProperties = schema.unevaluatedProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default(unevaluatedProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromNot(schema, references, path, value) {
    return Default(schema.not, path, Default(schema, path, value));
  }
  function FromObject(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(defaulted))
      return defaulted;
    const knownKeys = (0, index_3.KeyOfPropertyKeys)(schema);
    const knownProperties = { ...defaulted };
    for (const key of knownKeys)
      if (key in knownProperties) {
        knownProperties[key] = Visit(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return knownProperties;
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.includes(key)) {
        properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRecord(schema, references, path, value) {
    const defaulted = Default(schema, path, value);
    if (!(0, index_6.IsStandardObject)(value))
      return defaulted;
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const knownKeys = new RegExp(pattern);
    const knownProperties = { ...defaulted };
    for (const key of Object.getOwnPropertyNames(value))
      if (knownKeys.test(key)) {
        knownProperties[key] = Visit(schema.patternProperties[pattern], references, `${path}/${key}`, knownProperties[key]);
      }
    if (!(0, type_1.IsSchema)(schema.additionalProperties)) {
      return Default(schema, path, knownProperties);
    }
    const unknownKeys = Object.getOwnPropertyNames(knownProperties);
    const additionalProperties = schema.additionalProperties;
    const properties = { ...knownProperties };
    for (const key of unknownKeys)
      if (!knownKeys.test(key)) {
        properties[key] = Default(additionalProperties, `${path}/${key}`, properties[key]);
      }
    return properties;
  }
  function FromRef(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
  }
  function FromThis(schema, references, path, value) {
    const target = (0, index_4.Deref)(schema, references);
    const resolved = Visit(target, references, path, value);
    return Default(schema, path, resolved);
  }
  function FromTuple(schema, references, path, value) {
    const value1 = Default(schema, path, value);
    return (0, index_6.IsArray)(schema.items) ? schema.items.map((schema2, index) => Visit(schema2, references, `${path}/${index}`, value1[index])) : [];
  }
  function FromUnion(schema, references, path, value) {
    for (const subschema of schema.anyOf) {
      if (!(0, index_5.Check)(subschema, references, value))
        continue;
      const value1 = Visit(subschema, references, path, value);
      return Default(schema, path, value1);
    }
    for (const subschema of schema.anyOf) {
      const value1 = Visit(subschema, references, path, value);
      if (!(0, index_5.Check)(schema, references, value1))
        continue;
      return Default(schema, path, value1);
    }
    return Default(schema, path, value);
  }
  function Visit(schema, references, path, value) {
    const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
    const schema_ = schema;
    switch (schema[index_1.Kind]) {
      case "Array":
        return FromArray(schema_, references_, path, value);
      case "Intersect":
        return FromIntersect(schema_, references_, path, value);
      case "Not":
        return FromNot(schema_, references_, path, value);
      case "Object":
        return FromObject(schema_, references_, path, value);
      case "Record":
        return FromRecord(schema_, references_, path, value);
      case "Ref":
        return FromRef(schema_, references_, path, value);
      case "This":
        return FromThis(schema_, references_, path, value);
      case "Tuple":
        return FromTuple(schema_, references_, path, value);
      case "Union":
        return FromUnion(schema_, references_, path, value);
      default:
        return Default(schema_, path, value);
    }
  }
  function TransformEncode(schema, references, value) {
    return Visit(schema, references, "", value);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/has.js
var require_has = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HasTransform = HasTransform;
  var index_1 = require_deref2();
  var index_2 = require_symbols2();
  var type_1 = require_type3();
  var index_3 = require_guard2();
  function FromArray(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromAsyncIterator(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromConstructor(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
  }
  function FromFunction(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.returns, references) || schema.parameters.some((schema2) => Visit(schema2, references));
  }
  function FromIntersect(schema, references) {
    return (0, type_1.IsTransform)(schema) || (0, type_1.IsTransform)(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit(schema2, references));
  }
  function FromIterator(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.items, references);
  }
  function FromNot(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.not, references);
  }
  function FromObject(schema, references) {
    return (0, type_1.IsTransform)(schema) || Object.values(schema.properties).some((schema2) => Visit(schema2, references)) || (0, type_1.IsSchema)(schema.additionalProperties) && Visit(schema.additionalProperties, references);
  }
  function FromPromise(schema, references) {
    return (0, type_1.IsTransform)(schema) || Visit(schema.item, references);
  }
  function FromRecord(schema, references) {
    const pattern = Object.getOwnPropertyNames(schema.patternProperties)[0];
    const property = schema.patternProperties[pattern];
    return (0, type_1.IsTransform)(schema) || Visit(property, references) || (0, type_1.IsSchema)(schema.additionalProperties) && (0, type_1.IsTransform)(schema.additionalProperties);
  }
  function FromRef(schema, references) {
    if ((0, type_1.IsTransform)(schema))
      return true;
    return Visit((0, index_1.Deref)(schema, references), references);
  }
  function FromThis(schema, references) {
    if ((0, type_1.IsTransform)(schema))
      return true;
    return Visit((0, index_1.Deref)(schema, references), references);
  }
  function FromTuple(schema, references) {
    return (0, type_1.IsTransform)(schema) || !(0, index_3.IsUndefined)(schema.items) && schema.items.some((schema2) => Visit(schema2, references));
  }
  function FromUnion(schema, references) {
    return (0, type_1.IsTransform)(schema) || schema.anyOf.some((schema2) => Visit(schema2, references));
  }
  function Visit(schema, references) {
    const references_ = (0, index_3.IsString)(schema.$id) ? [...references, schema] : references;
    const schema_ = schema;
    if (schema.$id && visited.has(schema.$id))
      return false;
    if (schema.$id)
      visited.add(schema.$id);
    switch (schema[index_2.Kind]) {
      case "Array":
        return FromArray(schema_, references_);
      case "AsyncIterator":
        return FromAsyncIterator(schema_, references_);
      case "Constructor":
        return FromConstructor(schema_, references_);
      case "Function":
        return FromFunction(schema_, references_);
      case "Intersect":
        return FromIntersect(schema_, references_);
      case "Iterator":
        return FromIterator(schema_, references_);
      case "Not":
        return FromNot(schema_, references_);
      case "Object":
        return FromObject(schema_, references_);
      case "Promise":
        return FromPromise(schema_, references_);
      case "Record":
        return FromRecord(schema_, references_);
      case "Ref":
        return FromRef(schema_, references_);
      case "This":
        return FromThis(schema_, references_);
      case "Tuple":
        return FromTuple(schema_, references_);
      case "Union":
        return FromUnion(schema_, references_);
      default:
        return (0, type_1.IsTransform)(schema);
    }
  }
  var visited = new Set;
  function HasTransform(schema, references) {
    visited.clear();
    return Visit(schema, references);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/transform/index.js
var require_transform = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_decode(), exports);
  __exportStar(require_encode(), exports);
  __exportStar(require_has(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/value/value/value.js
var require_value3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Cast = Cast;
  exports.Create = Create;
  exports.Check = Check;
  exports.Clean = Clean;
  exports.Convert = Convert;
  exports.Clone = Clone;
  exports.Decode = Decode;
  exports.Default = Default;
  exports.Encode = Encode;
  exports.Errors = Errors;
  exports.Equal = Equal;
  exports.Diff = Diff;
  exports.Hash = Hash;
  exports.Patch = Patch;
  exports.Mutate = Mutate;
  var index_1 = require_transform();
  var index_2 = require_mutate2();
  var index_3 = require_hash2();
  var index_4 = require_equal2();
  var index_5 = require_cast2();
  var index_6 = require_clone2();
  var index_7 = require_convert2();
  var index_8 = require_create2();
  var index_9 = require_clean2();
  var index_10 = require_check2();
  var index_11 = require_default2();
  var index_12 = require_delta2();
  var index_13 = require_errors2();
  function Cast(...args) {
    return index_5.Cast.apply(index_5.Cast, args);
  }
  function Create(...args) {
    return index_8.Create.apply(index_8.Create, args);
  }
  function Check(...args) {
    return index_10.Check.apply(index_10.Check, args);
  }
  function Clean(...args) {
    return index_9.Clean.apply(index_9.Clean, args);
  }
  function Convert(...args) {
    return index_7.Convert.apply(index_7.Convert, args);
  }
  function Clone(value) {
    return (0, index_6.Clone)(value);
  }
  function Decode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    if (!Check(schema, references, value))
      throw new index_1.TransformDecodeCheckError(schema, value, Errors(schema, references, value).First());
    return (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformDecode)(schema, references, value) : value;
  }
  function Default(...args) {
    return index_11.Default.apply(index_11.Default, args);
  }
  function Encode(...args) {
    const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
    const encoded = (0, index_1.HasTransform)(schema, references) ? (0, index_1.TransformEncode)(schema, references, value) : value;
    if (!Check(schema, references, encoded))
      throw new index_1.TransformEncodeCheckError(schema, encoded, Errors(schema, references, encoded).First());
    return encoded;
  }
  function Errors(...args) {
    return index_13.Errors.apply(index_13.Errors, args);
  }
  function Equal(left, right) {
    return (0, index_4.Equal)(left, right);
  }
  function Diff(current, next) {
    return (0, index_12.Diff)(current, next);
  }
  function Hash(value) {
    return (0, index_3.Hash)(value);
  }
  function Patch(current, edits) {
    return (0, index_12.Patch)(current, edits);
  }
  function Mutate(current, next) {
    (0, index_2.Mutate)(current, next);
  }
});

// node_modules/@sinclair/typebox/build/cjs/value/value/index.js
var require_value4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = undefined;
  exports.Value = require_value3();
});

// node_modules/@sinclair/typebox/build/cjs/value/index.js
var require_value5 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Value = exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_guard2(), exports);
  __exportStar(require_cast2(), exports);
  __exportStar(require_check2(), exports);
  __exportStar(require_clean2(), exports);
  __exportStar(require_clone2(), exports);
  __exportStar(require_convert2(), exports);
  __exportStar(require_create2(), exports);
  __exportStar(require_default2(), exports);
  __exportStar(require_delta2(), exports);
  __exportStar(require_equal2(), exports);
  __exportStar(require_hash2(), exports);
  __exportStar(require_mutate2(), exports);
  __exportStar(require_pointer2(), exports);
  __exportStar(require_transform(), exports);
  var index_2 = require_value4();
  Object.defineProperty(exports, "Value", { enumerable: true, get: function() {
    return index_2.Value;
  } });
});

// node_modules/@sinclair/typebox/build/cjs/type/clone/index.js
var require_clone3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_type2(), exports);
  __exportStar(require_value2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/helpers.js
var require_helpers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Increment = Increment;
  function Increment(T) {
    return (parseInt(T) + 1).toString();
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/helpers/index.js
var require_helpers2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_helpers(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/awaited.js
var require_awaited = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Awaited = Awaited;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => AwaitedResolve(L));
  }
  function FromIntersect(T) {
    return (0, index_1.Intersect)(FromRest(T));
  }
  function FromUnion(T) {
    return (0, index_2.Union)(FromRest(T));
  }
  function FromPromise(T) {
    return AwaitedResolve(T);
  }
  function AwaitedResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? FromIntersect(T.allOf) : (0, kind_1.IsUnion)(T) ? FromUnion(T.anyOf) : (0, kind_1.IsPromise)(T) ? FromPromise(T.item) : T;
  }
  function Awaited(T, options = {}) {
    return (0, type_1.CloneType)(AwaitedResolve(T), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/awaited/index.js
var require_awaited2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_awaited(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/composite.js
var require_composite = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composite = Composite;
  var index_1 = require_intersect2();
  var index_2 = require_indexed2();
  var index_3 = require_keyof2();
  var index_4 = require_object2();
  var index_5 = require_sets();
  var kind_1 = require_kind();
  function CompositeKeys(T) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_3.KeyOfPropertyKeys)(L));
    return (0, index_5.SetDistinct)(Acc);
  }
  function FilterNever(T) {
    return T.filter((L) => !(0, kind_1.IsNever)(L));
  }
  function CompositeProperty(T, K) {
    const Acc = [];
    for (const L of T)
      Acc.push(...(0, index_2.IndexFromPropertyKeys)(L, [K]));
    return FilterNever(Acc);
  }
  function CompositeProperties(T, K) {
    const Acc = {};
    for (const L of K) {
      Acc[L] = (0, index_1.IntersectEvaluated)(CompositeProperty(T, L));
    }
    return Acc;
  }
  function Composite(T, options = {}) {
    const K = CompositeKeys(T);
    const P = CompositeProperties(T, K);
    const R = (0, index_4.Object)(P, options);
    return R;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/composite/index.js
var require_composite2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_composite(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/date/date.js
var require_date = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Date = Date2;
  var index_1 = require_symbols2();
  function Date2(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Date",
      type: "Date"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/date/index.js
var require_date2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_date(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/null/null.js
var require_null = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Null = Null;
  var index_1 = require_symbols2();
  function Null(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Null",
      type: "null"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/null/index.js
var require_null2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_null(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/symbol.js
var require_symbol = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Symbol = Symbol2;
  var index_1 = require_symbols2();
  function Symbol2(options) {
    return { ...options, [index_1.Kind]: "Symbol", type: "symbol" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/symbol/index.js
var require_symbol2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_symbol(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/undefined.js
var require_undefined = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Undefined = Undefined;
  var index_1 = require_symbols2();
  function Undefined(options = {}) {
    return { ...options, [index_1.Kind]: "Undefined", type: "undefined" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/undefined/index.js
var require_undefined2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_undefined(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/uint8array.js
var require_uint8array = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uint8Array = Uint8Array2;
  var index_1 = require_symbols2();
  function Uint8Array2(options = {}) {
    return { ...options, [index_1.Kind]: "Uint8Array", type: "Uint8Array" };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/uint8array/index.js
var require_uint8array2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_uint8array(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/const/const.js
var require_const = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Const = Const;
  var index_1 = require_any2();
  var index_2 = require_bigint2();
  var index_3 = require_date2();
  var index_4 = require_function2();
  var index_5 = require_literal2();
  var index_6 = require_null2();
  var index_7 = require_object2();
  var index_8 = require_symbol2();
  var index_9 = require_tuple2();
  var index_10 = require_readonly2();
  var index_11 = require_undefined2();
  var index_12 = require_uint8array2();
  var index_13 = require_unknown2();
  var index_14 = require_clone3();
  var value_1 = require_value();
  function FromArray(T) {
    return T.map((L) => FromValue(L, false));
  }
  function FromProperties(value) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(value))
      Acc[K] = (0, index_10.Readonly)(FromValue(value[K], false));
    return Acc;
  }
  function ConditionalReadonly(T, root) {
    return root === true ? T : (0, index_10.Readonly)(T);
  }
  function FromValue(value, root) {
    return (0, value_1.IsAsyncIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsIterator)(value) ? ConditionalReadonly((0, index_1.Any)(), root) : (0, value_1.IsArray)(value) ? (0, index_10.Readonly)((0, index_9.Tuple)(FromArray(value))) : (0, value_1.IsUint8Array)(value) ? (0, index_12.Uint8Array)() : (0, value_1.IsDate)(value) ? (0, index_3.Date)() : (0, value_1.IsObject)(value) ? ConditionalReadonly((0, index_7.Object)(FromProperties(value)), root) : (0, value_1.IsFunction)(value) ? ConditionalReadonly((0, index_4.Function)([], (0, index_13.Unknown)()), root) : (0, value_1.IsUndefined)(value) ? (0, index_11.Undefined)() : (0, value_1.IsNull)(value) ? (0, index_6.Null)() : (0, value_1.IsSymbol)(value) ? (0, index_8.Symbol)() : (0, value_1.IsBigInt)(value) ? (0, index_2.BigInt)() : (0, value_1.IsNumber)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsBoolean)(value) ? (0, index_5.Literal)(value) : (0, value_1.IsString)(value) ? (0, index_5.Literal)(value) : (0, index_7.Object)({});
  }
  function Const(T, options = {}) {
    return (0, index_14.CloneType)(FromValue(T, true), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/const/index.js
var require_const2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_const(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/constructor-parameters.js
var require_constructor_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConstructorParameters = ConstructorParameters;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  function ConstructorParameters(schema, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/constructor-parameters/index.js
var require_constructor_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_constructor_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/deref.js
var require_deref3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Deref = Deref;
  var type_1 = require_type2();
  var index_1 = require_discard2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function FromRest(schema, references) {
    return schema.map((schema2) => Deref(schema2, references));
  }
  function FromProperties(properties, references) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
      Acc[K] = Deref(properties[K], references);
    }
    return Acc;
  }
  function FromConstructor(schema, references) {
    schema.parameters = FromRest(schema.parameters, references);
    schema.returns = Deref(schema.returns, references);
    return schema;
  }
  function FromFunction(schema, references) {
    schema.parameters = FromRest(schema.parameters, references);
    schema.returns = Deref(schema.returns, references);
    return schema;
  }
  function FromIntersect(schema, references) {
    schema.allOf = FromRest(schema.allOf, references);
    return schema;
  }
  function FromUnion(schema, references) {
    schema.anyOf = FromRest(schema.anyOf, references);
    return schema;
  }
  function FromTuple(schema, references) {
    if ((0, value_1.IsUndefined)(schema.items))
      return schema;
    schema.items = FromRest(schema.items, references);
    return schema;
  }
  function FromArray(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromObject(schema, references) {
    schema.properties = FromProperties(schema.properties, references);
    return schema;
  }
  function FromPromise(schema, references) {
    schema.item = Deref(schema.item, references);
    return schema;
  }
  function FromAsyncIterator(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromIterator(schema, references) {
    schema.items = Deref(schema.items, references);
    return schema;
  }
  function FromRef(schema, references) {
    const target = references.find((remote) => remote.$id === schema.$ref);
    if (target === undefined)
      throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
    const discard = (0, index_1.Discard)(target, ["$id"]);
    return Deref(discard, references);
  }
  function DerefResolve(schema, references) {
    return (0, kind_1.IsConstructor)(schema) ? FromConstructor(schema, references) : (0, kind_1.IsFunction)(schema) ? FromFunction(schema, references) : (0, kind_1.IsIntersect)(schema) ? FromIntersect(schema, references) : (0, kind_1.IsUnion)(schema) ? FromUnion(schema, references) : (0, kind_1.IsTuple)(schema) ? FromTuple(schema, references) : (0, kind_1.IsArray)(schema) ? FromArray(schema, references) : (0, kind_1.IsObject)(schema) ? FromObject(schema, references) : (0, kind_1.IsPromise)(schema) ? FromPromise(schema, references) : (0, kind_1.IsAsyncIterator)(schema) ? FromAsyncIterator(schema, references) : (0, kind_1.IsIterator)(schema) ? FromIterator(schema, references) : (0, kind_1.IsRef)(schema) ? FromRef(schema, references) : schema;
  }
  function Deref(schema, references) {
    return DerefResolve((0, type_1.CloneType)(schema), (0, type_1.CloneRest)(references));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/deref/index.js
var require_deref4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_deref3(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/enum.js
var require_enum = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Enum = Enum;
  var index_1 = require_literal2();
  var index_2 = require_symbols2();
  var index_3 = require_union2();
  var value_1 = require_value();
  function Enum(item, options = {}) {
    if ((0, value_1.IsUndefined)(item))
      throw new Error("Enum undefined or empty");
    const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
    const values2 = [...new Set(values1)];
    const anyOf = values2.map((value) => (0, index_1.Literal)(value));
    return (0, index_3.Union)(anyOf, { ...options, [index_2.Hint]: "Enum" });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/enum/index.js
var require_enum2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_enum(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-template-literal.js
var require_exclude_from_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
  var exclude_1 = require_exclude();
  var index_1 = require_template_literal2();
  function ExcludeFromTemplateLiteral(L, R) {
    return (0, exclude_1.Exclude)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude.js
var require_exclude = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Exclude = Exclude;
  var index_1 = require_union2();
  var index_2 = require_never2();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var exclude_from_mapped_result_1 = require_exclude_from_mapped_result();
  var exclude_from_template_literal_1 = require_exclude_from_template_literal();
  var kind_1 = require_kind();
  function ExcludeRest(L, R) {
    const excluded = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) === index_3.ExtendsResult.False);
    return excluded.length === 1 ? excluded[0] : (0, index_1.Union)(excluded);
  }
  function Exclude(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, exclude_from_template_literal_1.ExcludeFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, exclude_from_mapped_result_1.ExcludeFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, kind_1.IsUnion)(L) ? ExcludeRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? (0, index_2.Never)() : L, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/exclude-from-mapped-result.js
var require_exclude_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExcludeFromMappedResult = ExcludeFromMappedResult;
  var index_1 = require_mapped2();
  var exclude_1 = require_exclude();
  function FromProperties(P, U) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, exclude_1.Exclude)(P[K2], U);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExcludeFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/exclude/index.js
var require_exclude2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_exclude_from_mapped_result(), exports);
  __exportStar(require_exclude_from_template_literal(), exports);
  __exportStar(require_exclude(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-template-literal.js
var require_extract_from_template_literal = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
  var extract_1 = require_extract();
  var index_1 = require_template_literal2();
  function ExtractFromTemplateLiteral(L, R) {
    return (0, extract_1.Extract)((0, index_1.TemplateLiteralToUnion)(L), R);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract.js
var require_extract = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Extract = Extract;
  var index_1 = require_union2();
  var index_2 = require_never2();
  var index_3 = require_extends2();
  var type_1 = require_type2();
  var extract_from_mapped_result_1 = require_extract_from_mapped_result();
  var extract_from_template_literal_1 = require_extract_from_template_literal();
  var kind_1 = require_kind();
  function ExtractRest(L, R) {
    const extracted = L.filter((inner) => (0, index_3.ExtendsCheck)(inner, R) !== index_3.ExtendsResult.False);
    return extracted.length === 1 ? extracted[0] : (0, index_1.Union)(extracted);
  }
  function Extract(L, R, options = {}) {
    if ((0, kind_1.IsTemplateLiteral)(L))
      return (0, type_1.CloneType)((0, extract_from_template_literal_1.ExtractFromTemplateLiteral)(L, R), options);
    if ((0, kind_1.IsMappedResult)(L))
      return (0, type_1.CloneType)((0, extract_from_mapped_result_1.ExtractFromMappedResult)(L, R), options);
    return (0, type_1.CloneType)((0, kind_1.IsUnion)(L) ? ExtractRest(L.anyOf, R) : (0, index_3.ExtendsCheck)(L, R) !== index_3.ExtendsResult.False ? L : (0, index_2.Never)(), options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/extract-from-mapped-result.js
var require_extract_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExtractFromMappedResult = ExtractFromMappedResult;
  var index_1 = require_mapped2();
  var extract_1 = require_extract();
  function FromProperties(P, T) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, extract_1.Extract)(P[K2], T);
    return Acc;
  }
  function FromMappedResult(R, T) {
    return FromProperties(R.properties, T);
  }
  function ExtractFromMappedResult(R, T) {
    const P = FromMappedResult(R, T);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/extract/index.js
var require_extract2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_extract_from_mapped_result(), exports);
  __exportStar(require_extract_from_template_literal(), exports);
  __exportStar(require_extract(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/instance-type.js
var require_instance_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InstanceType = InstanceType;
  var type_1 = require_type2();
  function InstanceType(schema, options = {}) {
    return (0, type_1.CloneType)(schema.returns, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/instance-type/index.js
var require_instance_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_instance_type(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/integer.js
var require_integer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Integer = Integer;
  var index_1 = require_symbols2();
  function Integer(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Integer",
      type: "integer"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/integer/index.js
var require_integer2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_integer(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic-from-mapped-key.js
var require_intrinsic_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
  var index_1 = require_mapped2();
  var intrinsic_1 = require_intrinsic();
  var index_2 = require_literal2();
  function MappedIntrinsicPropertyKey(K, M, options) {
    return {
      [K]: (0, intrinsic_1.Intrinsic)((0, index_2.Literal)(K), M, options)
    };
  }
  function MappedIntrinsicPropertyKeys(K, M, options) {
    return K.reduce((Acc, L) => {
      return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
    }, {});
  }
  function MappedIntrinsicProperties(T, M, options) {
    return MappedIntrinsicPropertyKeys(T["keys"], M, options);
  }
  function IntrinsicFromMappedKey(T, M, options) {
    const P = MappedIntrinsicProperties(T, M, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/intrinsic.js
var require_intrinsic = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Intrinsic = Intrinsic;
  var index_1 = require_template_literal2();
  var intrinsic_from_mapped_key_1 = require_intrinsic_from_mapped_key();
  var index_2 = require_literal2();
  var index_3 = require_union2();
  var kind_1 = require_kind();
  function ApplyUncapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toLowerCase(), rest].join("");
  }
  function ApplyCapitalize(value) {
    const [first, rest] = [value.slice(0, 1), value.slice(1)];
    return [first.toUpperCase(), rest].join("");
  }
  function ApplyUppercase(value) {
    return value.toUpperCase();
  }
  function ApplyLowercase(value) {
    return value.toLowerCase();
  }
  function FromTemplateLiteral(schema, mode, options) {
    const expression = (0, index_1.TemplateLiteralParseExact)(schema.pattern);
    const finite = (0, index_1.IsTemplateLiteralExpressionFinite)(expression);
    if (!finite)
      return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
    const strings = [...(0, index_1.TemplateLiteralExpressionGenerate)(expression)];
    const literals = strings.map((value) => (0, index_2.Literal)(value));
    const mapped = FromRest(literals, mode);
    const union = (0, index_3.Union)(mapped);
    return (0, index_1.TemplateLiteral)([union], options);
  }
  function FromLiteralValue(value, mode) {
    return typeof value === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value) : mode === "Capitalize" ? ApplyCapitalize(value) : mode === "Uppercase" ? ApplyUppercase(value) : mode === "Lowercase" ? ApplyLowercase(value) : value : value.toString();
  }
  function FromRest(T, M) {
    return T.map((L) => Intrinsic(L, M));
  }
  function Intrinsic(schema, mode, options = {}) {
    return (0, kind_1.IsMappedKey)(schema) ? (0, intrinsic_from_mapped_key_1.IntrinsicFromMappedKey)(schema, mode, options) : (0, kind_1.IsTemplateLiteral)(schema) ? FromTemplateLiteral(schema, mode, schema) : (0, kind_1.IsUnion)(schema) ? (0, index_3.Union)(FromRest(schema.anyOf, mode), options) : (0, kind_1.IsLiteral)(schema) ? (0, index_2.Literal)(FromLiteralValue(schema.const, mode), options) : schema;
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/capitalize.js
var require_capitalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Capitalize = Capitalize;
  var intrinsic_1 = require_intrinsic();
  function Capitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Capitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/lowercase.js
var require_lowercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Lowercase = Lowercase;
  var intrinsic_1 = require_intrinsic();
  function Lowercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Lowercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uncapitalize.js
var require_uncapitalize = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uncapitalize = Uncapitalize;
  var intrinsic_1 = require_intrinsic();
  function Uncapitalize(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uncapitalize", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/uppercase.js
var require_uppercase = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Uppercase = Uppercase;
  var intrinsic_1 = require_intrinsic();
  function Uppercase(T, options = {}) {
    return (0, intrinsic_1.Intrinsic)(T, "Uppercase", options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/intrinsic/index.js
var require_intrinsic2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_capitalize(), exports);
  __exportStar(require_intrinsic_from_mapped_key(), exports);
  __exportStar(require_intrinsic(), exports);
  __exportStar(require_lowercase(), exports);
  __exportStar(require_uncapitalize(), exports);
  __exportStar(require_uppercase(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/not/not.js
var require_not = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Not = Not;
  var type_1 = require_type2();
  var index_1 = require_symbols2();
  function Not(schema, options) {
    return {
      ...options,
      [index_1.Kind]: "Not",
      not: (0, type_1.CloneType)(schema)
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/not/index.js
var require_not2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_not(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-result.js
var require_omit_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedResult = OmitFromMappedResult;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, omit_1.Omit)(P[K2], K, options);
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function OmitFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit.js
var require_omit = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Omit = Omit;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var omit_from_mapped_key_1 = require_omit_from_mapped_key();
  var omit_from_mapped_result_1 = require_omit_from_mapped_result();
  var kind_1 = require_kind();
  function FromIntersect(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => OmitResolve(T2, K));
  }
  function FromProperty(T, K) {
    const { [K]: _, ...R } = T;
    return R;
  }
  function FromProperties(T, K) {
    return K.reduce((T2, K2) => FromProperty(T2, K2), T);
  }
  function OmitResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties, K)) : (0, index_3.Object)({});
  }
  function Omit(T, K, options = {}) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, omit_from_mapped_key_1.OmitFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, omit_from_mapped_result_1.OmitFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(OmitResolve(T, I), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/omit-from-mapped-key.js
var require_omit_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OmitFromMappedKey = OmitFromMappedKey;
  var index_1 = require_mapped2();
  var omit_1 = require_omit();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, omit_1.Omit)(T, [K], options)
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function OmitFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/omit/index.js
var require_omit2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_omit_from_mapped_key(), exports);
  __exportStar(require_omit_from_mapped_result(), exports);
  __exportStar(require_omit(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/parameters.js
var require_parameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parameters = Parameters;
  var index_1 = require_tuple2();
  var type_1 = require_type2();
  function Parameters(schema, options = {}) {
    return (0, index_1.Tuple)((0, type_1.CloneRest)(schema.parameters), { ...options });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/parameters/index.js
var require_parameters2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_parameters(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial.js
var require_partial = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Partial = Partial;
  var index_1 = require_optional2();
  var index_2 = require_object2();
  var index_3 = require_intersect2();
  var index_4 = require_union2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var partial_from_mapped_result_1 = require_partial_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => PartialResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_1.Optional)(T[K]);
    return Acc;
  }
  function PartialResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_3.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_4.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? (0, index_2.Object)(FromProperties(T.properties)) : (0, index_2.Object)({});
  }
  function Partial(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T))
      return (0, partial_from_mapped_result_1.PartialFromMappedResult)(T, options);
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PartialResolve(T), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/partial-from-mapped-result.js
var require_partial_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PartialFromMappedResult = PartialFromMappedResult;
  var index_1 = require_mapped2();
  var partial_1 = require_partial();
  function FromProperties(K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(K))
      Acc[K2] = (0, partial_1.Partial)(K[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function PartialFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/partial/index.js
var require_partial2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_partial_from_mapped_result(), exports);
  __exportStar(require_partial(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-result.js
var require_pick_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedResult = PickFromMappedResult;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  function FromProperties(P, K, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, pick_1.Pick)(P[K2], K, options);
    return Acc;
  }
  function FromMappedResult(R, K, options) {
    return FromProperties(R.properties, K, options);
  }
  function PickFromMappedResult(R, K, options) {
    const P = FromMappedResult(R, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick.js
var require_pick = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pick = Pick;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_indexed2();
  var index_5 = require_discard2();
  var index_6 = require_symbols2();
  var type_1 = require_type2();
  var pick_from_mapped_key_1 = require_pick_from_mapped_key();
  var pick_from_mapped_result_1 = require_pick_from_mapped_result();
  var kind_1 = require_kind();
  function FromIntersect(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromUnion(T, K) {
    return T.map((T2) => PickResolve(T2, K));
  }
  function FromProperties(T, K) {
    const Acc = {};
    for (const K2 of K)
      if (K2 in T)
        Acc[K2] = T[K2];
    return Acc;
  }
  function PickResolve(T, K) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromIntersect(T.allOf, K)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromUnion(T.anyOf, K)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties, K)) : (0, index_3.Object)({});
  }
  function Pick(T, K, options = {}) {
    if ((0, kind_1.IsMappedKey)(K))
      return (0, pick_from_mapped_key_1.PickFromMappedKey)(T, K, options);
    if ((0, kind_1.IsMappedResult)(T))
      return (0, pick_from_mapped_result_1.PickFromMappedResult)(T, K, options);
    const I = (0, kind_1.IsSchema)(K) ? (0, index_4.IndexPropertyKeys)(K) : K;
    const D = (0, index_5.Discard)(T, [index_6.TransformKind, "$id", "required"]);
    const R = (0, type_1.CloneType)(PickResolve(T, I), options);
    return { ...D, ...R };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/pick-from-mapped-key.js
var require_pick_from_mapped_key = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PickFromMappedKey = PickFromMappedKey;
  var index_1 = require_mapped2();
  var pick_1 = require_pick();
  function FromPropertyKey(T, K, options) {
    return {
      [K]: (0, pick_1.Pick)(T, [K], options)
    };
  }
  function FromPropertyKeys(T, K, options) {
    return K.reduce((Acc, LK) => {
      return { ...Acc, ...FromPropertyKey(T, LK, options) };
    }, {});
  }
  function FromMappedKey(T, K, options) {
    return FromPropertyKeys(T, K.keys, options);
  }
  function PickFromMappedKey(T, K, options) {
    const P = FromMappedKey(T, K, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/pick/index.js
var require_pick2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_pick_from_mapped_key(), exports);
  __exportStar(require_pick_from_mapped_result(), exports);
  __exportStar(require_pick(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/readonly-optional.js
var require_readonly_optional = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReadonlyOptional = ReadonlyOptional;
  var index_1 = require_readonly2();
  var index_2 = require_optional2();
  function ReadonlyOptional(schema) {
    return (0, index_1.Readonly)((0, index_2.Optional)(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/readonly-optional/index.js
var require_readonly_optional2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_readonly_optional(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/record/record.js
var require_record = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Record = Record;
  var index_1 = require_object2();
  var index_2 = require_never2();
  var index_3 = require_union2();
  var index_4 = require_template_literal2();
  var index_5 = require_patterns2();
  var index_6 = require_indexed2();
  var index_7 = require_symbols2();
  var type_1 = require_type2();
  var value_1 = require_value();
  var kind_1 = require_kind();
  function RecordCreateFromPattern(pattern, T, options) {
    return {
      ...options,
      [index_7.Kind]: "Record",
      type: "object",
      patternProperties: { [pattern]: (0, type_1.CloneType)(T) }
    };
  }
  function RecordCreateFromKeys(K, T, options) {
    const Acc = {};
    for (const K2 of K)
      Acc[K2] = (0, type_1.CloneType)(T);
    return (0, index_1.Object)(Acc, { ...options, [index_7.Hint]: "Record" });
  }
  function FromTemplateLiteralKey(K, T, options) {
    return (0, index_4.IsTemplateLiteralFinite)(K) ? RecordCreateFromKeys((0, index_6.IndexPropertyKeys)(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
  }
  function FromUnionKey(K, T, options) {
    return RecordCreateFromKeys((0, index_6.IndexPropertyKeys)((0, index_3.Union)(K)), T, options);
  }
  function FromLiteralKey(K, T, options) {
    return RecordCreateFromKeys([K.toString()], T, options);
  }
  function FromRegExpKey(K, T, options) {
    return RecordCreateFromPattern(K.source, T, options);
  }
  function FromStringKey(K, T, options) {
    const pattern = (0, value_1.IsUndefined)(K.pattern) ? index_5.PatternStringExact : K.pattern;
    return RecordCreateFromPattern(pattern, T, options);
  }
  function FromAnyKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternStringExact, T, options);
  }
  function FromNeverKey(K, T, options) {
    return RecordCreateFromPattern(index_5.PatternNeverExact, T, options);
  }
  function FromIntegerKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function FromNumberKey(_, T, options) {
    return RecordCreateFromPattern(index_5.PatternNumberExact, T, options);
  }
  function Record(K, T, options = {}) {
    return (0, kind_1.IsUnion)(K) ? FromUnionKey(K.anyOf, T, options) : (0, kind_1.IsTemplateLiteral)(K) ? FromTemplateLiteralKey(K, T, options) : (0, kind_1.IsLiteral)(K) ? FromLiteralKey(K.const, T, options) : (0, kind_1.IsInteger)(K) ? FromIntegerKey(K, T, options) : (0, kind_1.IsNumber)(K) ? FromNumberKey(K, T, options) : (0, kind_1.IsRegExp)(K) ? FromRegExpKey(K, T, options) : (0, kind_1.IsString)(K) ? FromStringKey(K, T, options) : (0, kind_1.IsAny)(K) ? FromAnyKey(K, T, options) : (0, kind_1.IsNever)(K) ? FromNeverKey(K, T, options) : (0, index_2.Never)(options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/record/index.js
var require_record2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_record(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/recursive.js
var require_recursive = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Recursive = Recursive;
  var type_1 = require_type2();
  var value_1 = require_value();
  var index_1 = require_symbols2();
  var Ordinal = 0;
  function Recursive(callback, options = {}) {
    if ((0, value_1.IsUndefined)(options.$id))
      options.$id = `T${Ordinal++}`;
    const thisType = callback({ [index_1.Kind]: "This", $ref: `${options.$id}` });
    thisType.$id = options.$id;
    return (0, type_1.CloneType)({ ...options, [index_1.Hint]: "Recursive", ...thisType });
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/recursive/index.js
var require_recursive2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_recursive(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/ref.js
var require_ref = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Ref = Ref;
  var index_1 = require_symbols2();
  var value_1 = require_value();
  function Ref(unresolved, options = {}) {
    if ((0, value_1.IsString)(unresolved))
      return { ...options, [index_1.Kind]: "Ref", $ref: unresolved };
    if ((0, value_1.IsUndefined)(unresolved.$id))
      throw new Error("Reference target type must specify an $id");
    return {
      ...options,
      [index_1.Kind]: "Ref",
      $ref: unresolved.$id
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/ref/index.js
var require_ref2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ref(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/regexp.js
var require_regexp = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RegExp = RegExp2;
  var value_1 = require_value();
  var index_1 = require_symbols2();
  function RegExp2(unresolved, options = {}) {
    const expr = (0, value_1.IsString)(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
    return { ...options, [index_1.Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/regexp/index.js
var require_regexp2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_regexp(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required.js
var require_required = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Required = Required;
  var index_1 = require_intersect2();
  var index_2 = require_union2();
  var index_3 = require_object2();
  var index_4 = require_symbols2();
  var type_1 = require_type2();
  var index_5 = require_discard2();
  var required_from_mapped_result_1 = require_required_from_mapped_result();
  var kind_1 = require_kind();
  function FromRest(T) {
    return T.map((L) => RequiredResolve(L));
  }
  function FromProperties(T) {
    const Acc = {};
    for (const K of globalThis.Object.getOwnPropertyNames(T))
      Acc[K] = (0, index_5.Discard)(T[K], [index_4.OptionalKind]);
    return Acc;
  }
  function RequiredResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, index_1.Intersect)(FromRest(T.allOf)) : (0, kind_1.IsUnion)(T) ? (0, index_2.Union)(FromRest(T.anyOf)) : (0, kind_1.IsObject)(T) ? (0, index_3.Object)(FromProperties(T.properties)) : (0, index_3.Object)({});
  }
  function Required(T, options = {}) {
    if ((0, kind_1.IsMappedResult)(T)) {
      return (0, required_from_mapped_result_1.RequiredFromMappedResult)(T, options);
    } else {
      const D = (0, index_5.Discard)(T, [index_4.TransformKind, "$id", "required"]);
      const R = (0, type_1.CloneType)(RequiredResolve(T), options);
      return { ...D, ...R };
    }
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/required-from-mapped-result.js
var require_required_from_mapped_result = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RequiredFromMappedResult = RequiredFromMappedResult;
  var index_1 = require_mapped2();
  var required_1 = require_required();
  function FromProperties(P, options) {
    const Acc = {};
    for (const K2 of globalThis.Object.getOwnPropertyNames(P))
      Acc[K2] = (0, required_1.Required)(P[K2], options);
    return Acc;
  }
  function FromMappedResult(R, options) {
    return FromProperties(R.properties, options);
  }
  function RequiredFromMappedResult(R, options) {
    const P = FromMappedResult(R, options);
    return (0, index_1.MappedResult)(P);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/required/index.js
var require_required2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_required_from_mapped_result(), exports);
  __exportStar(require_required(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/rest.js
var require_rest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Rest = Rest;
  var type_1 = require_type2();
  var kind_1 = require_kind();
  function RestResolve(T) {
    return (0, kind_1.IsIntersect)(T) ? (0, type_1.CloneRest)(T.allOf) : (0, kind_1.IsUnion)(T) ? (0, type_1.CloneRest)(T.anyOf) : (0, kind_1.IsTuple)(T) ? (0, type_1.CloneRest)(T.items ?? []) : [];
  }
  function Rest(T) {
    return (0, type_1.CloneRest)(RestResolve(T));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/rest/index.js
var require_rest2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_rest(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/return-type.js
var require_return_type = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReturnType = ReturnType;
  var type_1 = require_type2();
  function ReturnType(schema, options = {}) {
    return (0, type_1.CloneType)(schema.returns, options);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/return-type/index.js
var require_return_type2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_return_type(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/anyschema.js
var require_anyschema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/schema.js
var require_schema = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var index_1 = require_symbols2();
});

// node_modules/@sinclair/typebox/build/cjs/type/schema/index.js
var require_schema2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_anyschema(), exports);
  __exportStar(require_schema(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/static/static.js
var require_static = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
});

// node_modules/@sinclair/typebox/build/cjs/type/static/index.js
var require_static2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_static(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/strict.js
var require_strict = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strict = Strict;
  function Strict(schema) {
    return JSON.parse(JSON.stringify(schema));
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/strict/index.js
var require_strict2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_strict(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/transform.js
var require_transform2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TransformEncodeBuilder = exports.TransformDecodeBuilder = undefined;
  exports.Transform = Transform;
  var index_1 = require_symbols2();
  var type_1 = require_type2();
  var kind_1 = require_kind();

  class TransformDecodeBuilder {
    constructor(schema) {
      this.schema = schema;
    }
    Decode(decode) {
      return new TransformEncodeBuilder(this.schema, decode);
    }
  }
  exports.TransformDecodeBuilder = TransformDecodeBuilder;

  class TransformEncodeBuilder {
    constructor(schema, decode) {
      this.schema = schema;
      this.decode = decode;
    }
    EncodeTransform(encode, schema) {
      const Encode = (value) => schema[index_1.TransformKind].Encode(encode(value));
      const Decode = (value) => this.decode(schema[index_1.TransformKind].Decode(value));
      const Codec = { Encode, Decode };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    EncodeSchema(encode, schema) {
      const Codec = { Decode: this.decode, Encode: encode };
      return { ...schema, [index_1.TransformKind]: Codec };
    }
    Encode(encode) {
      const schema = (0, type_1.CloneType)(this.schema);
      return (0, kind_1.IsTransform)(schema) ? this.EncodeTransform(encode, schema) : this.EncodeSchema(encode, schema);
    }
  }
  exports.TransformEncodeBuilder = TransformEncodeBuilder;
  function Transform(schema) {
    return new TransformDecodeBuilder(schema);
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/transform/index.js
var require_transform3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_transform2(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/void/void.js
var require_void = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Void = Void;
  var index_1 = require_symbols2();
  function Void(options = {}) {
    return {
      ...options,
      [index_1.Kind]: "Void",
      type: "void"
    };
  }
});

// node_modules/@sinclair/typebox/build/cjs/type/void/index.js
var require_void2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_void(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/type/type/json.js
var require_json = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JsonTypeBuilder = undefined;
  var index_1 = require_any2();
  var index_2 = require_array2();
  var index_3 = require_boolean2();
  var index_4 = require_composite2();
  var index_5 = require_const2();
  var index_6 = require_deref4();
  var index_7 = require_enum2();
  var index_8 = require_exclude2();
  var index_9 = require_extends2();
  var index_10 = require_extract2();
  var index_11 = require_indexed2();
  var index_12 = require_integer2();
  var index_13 = require_intersect2();
  var index_14 = require_intrinsic2();
  var index_15 = require_keyof2();
  var index_16 = require_literal2();
  var index_17 = require_mapped2();
  var index_18 = require_never2();
  var index_19 = require_not2();
  var index_20 = require_null2();
  var index_21 = require_number2();
  var index_22 = require_object2();
  var index_23 = require_omit2();
  var index_24 = require_optional2();
  var index_25 = require_partial2();
  var index_26 = require_pick2();
  var index_27 = require_readonly2();
  var index_28 = require_readonly_optional2();
  var index_29 = require_record2();
  var index_30 = require_recursive2();
  var index_31 = require_ref2();
  var index_32 = require_required2();
  var index_33 = require_rest2();
  var index_34 = require_strict2();
  var index_35 = require_string2();
  var index_36 = require_template_literal2();
  var index_37 = require_transform3();
  var index_38 = require_tuple2();
  var index_39 = require_union2();
  var index_40 = require_unknown2();
  var index_41 = require_unsafe2();

  class JsonTypeBuilder {
    Strict(schema) {
      return (0, index_34.Strict)(schema);
    }
    ReadonlyOptional(schema) {
      return (0, index_28.ReadonlyOptional)(schema);
    }
    Readonly(schema, enable) {
      return (0, index_27.Readonly)(schema, enable ?? true);
    }
    Optional(schema, enable) {
      return (0, index_24.Optional)(schema, enable ?? true);
    }
    Any(options = {}) {
      return (0, index_1.Any)(options);
    }
    Array(schema, options = {}) {
      return (0, index_2.Array)(schema, options);
    }
    Boolean(options = {}) {
      return (0, index_3.Boolean)(options);
    }
    Capitalize(schema, options = {}) {
      return (0, index_14.Capitalize)(schema, options);
    }
    Composite(schemas, options) {
      return (0, index_4.Composite)(schemas, options);
    }
    Const(value, options = {}) {
      return (0, index_5.Const)(value, options);
    }
    Deref(schema, references) {
      return (0, index_6.Deref)(schema, references);
    }
    Enum(item, options = {}) {
      return (0, index_7.Enum)(item, options);
    }
    Exclude(unionType, excludedMembers, options = {}) {
      return (0, index_8.Exclude)(unionType, excludedMembers, options);
    }
    Extends(L, R, T, F, options = {}) {
      return (0, index_9.Extends)(L, R, T, F, options);
    }
    Extract(type, union, options = {}) {
      return (0, index_10.Extract)(type, union, options);
    }
    Index(schema, unresolved, options = {}) {
      return (0, index_11.Index)(schema, unresolved, options);
    }
    Integer(options = {}) {
      return (0, index_12.Integer)(options);
    }
    Intersect(T, options = {}) {
      return (0, index_13.Intersect)(T, options);
    }
    KeyOf(schema, options = {}) {
      return (0, index_15.KeyOf)(schema, options);
    }
    Literal(value, options = {}) {
      return (0, index_16.Literal)(value, options);
    }
    Lowercase(schema, options = {}) {
      return (0, index_14.Lowercase)(schema, options);
    }
    Mapped(key, map, options = {}) {
      return (0, index_17.Mapped)(key, map, options);
    }
    Never(options = {}) {
      return (0, index_18.Never)(options);
    }
    Not(schema, options) {
      return (0, index_19.Not)(schema, options);
    }
    Null(options = {}) {
      return (0, index_20.Null)(options);
    }
    Number(options = {}) {
      return (0, index_21.Number)(options);
    }
    Object(properties, options = {}) {
      return (0, index_22.Object)(properties, options);
    }
    Omit(schema, unresolved, options = {}) {
      return (0, index_23.Omit)(schema, unresolved, options);
    }
    Partial(schema, options = {}) {
      return (0, index_25.Partial)(schema, options);
    }
    Pick(schema, unresolved, options = {}) {
      return (0, index_26.Pick)(schema, unresolved, options);
    }
    Record(key, schema, options = {}) {
      return (0, index_29.Record)(key, schema, options);
    }
    Recursive(callback, options = {}) {
      return (0, index_30.Recursive)(callback, options);
    }
    Ref(unresolved, options = {}) {
      return (0, index_31.Ref)(unresolved, options);
    }
    Required(schema, options = {}) {
      return (0, index_32.Required)(schema, options);
    }
    Rest(schema) {
      return (0, index_33.Rest)(schema);
    }
    String(options = {}) {
      return (0, index_35.String)(options);
    }
    TemplateLiteral(unresolved, options = {}) {
      return (0, index_36.TemplateLiteral)(unresolved, options);
    }
    Transform(schema) {
      return (0, index_37.Transform)(schema);
    }
    Tuple(items, options = {}) {
      return (0, index_38.Tuple)(items, options);
    }
    Uncapitalize(schema, options = {}) {
      return (0, index_14.Uncapitalize)(schema, options);
    }
    Union(schemas, options = {}) {
      return (0, index_39.Union)(schemas, options);
    }
    Unknown(options = {}) {
      return (0, index_40.Unknown)(options);
    }
    Unsafe(options = {}) {
      return (0, index_41.Unsafe)(options);
    }
    Uppercase(schema, options = {}) {
      return (0, index_14.Uppercase)(schema, options);
    }
  }
  exports.JsonTypeBuilder = JsonTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/type.js
var require_type4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Strict = exports.ReturnType = exports.Rest = exports.Required = exports.RegExp = exports.Ref = exports.Recursive = exports.Record = exports.ReadonlyOptional = exports.Readonly = exports.Promise = exports.Pick = exports.Partial = exports.Parameters = exports.Optional = exports.Omit = exports.Object = exports.Number = exports.Null = exports.Not = exports.Never = exports.Mapped = exports.Literal = exports.KeyOf = exports.Iterator = exports.Uppercase = exports.Lowercase = exports.Uncapitalize = exports.Capitalize = exports.Intersect = exports.Integer = exports.InstanceType = exports.Index = exports.Function = exports.Extract = exports.Extends = exports.Exclude = exports.Enum = exports.Deref = exports.Date = exports.ConstructorParameters = exports.Constructor = exports.Const = exports.Composite = exports.Boolean = exports.BigInt = exports.Awaited = exports.AsyncIterator = exports.Array = exports.Any = undefined;
  exports.Void = exports.Unsafe = exports.Unknown = exports.Union = exports.Undefined = exports.Uint8Array = exports.Tuple = exports.Transform = exports.TemplateLiteral = exports.Symbol = exports.String = undefined;
  var index_1 = require_any2();
  Object.defineProperty(exports, "Any", { enumerable: true, get: function() {
    return index_1.Any;
  } });
  var index_2 = require_array2();
  Object.defineProperty(exports, "Array", { enumerable: true, get: function() {
    return index_2.Array;
  } });
  var index_3 = require_async_iterator2();
  Object.defineProperty(exports, "AsyncIterator", { enumerable: true, get: function() {
    return index_3.AsyncIterator;
  } });
  var index_4 = require_awaited2();
  Object.defineProperty(exports, "Awaited", { enumerable: true, get: function() {
    return index_4.Awaited;
  } });
  var index_5 = require_bigint2();
  Object.defineProperty(exports, "BigInt", { enumerable: true, get: function() {
    return index_5.BigInt;
  } });
  var index_6 = require_boolean2();
  Object.defineProperty(exports, "Boolean", { enumerable: true, get: function() {
    return index_6.Boolean;
  } });
  var index_7 = require_composite2();
  Object.defineProperty(exports, "Composite", { enumerable: true, get: function() {
    return index_7.Composite;
  } });
  var index_8 = require_const2();
  Object.defineProperty(exports, "Const", { enumerable: true, get: function() {
    return index_8.Const;
  } });
  var index_9 = require_constructor2();
  Object.defineProperty(exports, "Constructor", { enumerable: true, get: function() {
    return index_9.Constructor;
  } });
  var index_10 = require_constructor_parameters2();
  Object.defineProperty(exports, "ConstructorParameters", { enumerable: true, get: function() {
    return index_10.ConstructorParameters;
  } });
  var index_11 = require_date2();
  Object.defineProperty(exports, "Date", { enumerable: true, get: function() {
    return index_11.Date;
  } });
  var index_12 = require_deref4();
  Object.defineProperty(exports, "Deref", { enumerable: true, get: function() {
    return index_12.Deref;
  } });
  var index_13 = require_enum2();
  Object.defineProperty(exports, "Enum", { enumerable: true, get: function() {
    return index_13.Enum;
  } });
  var index_14 = require_exclude2();
  Object.defineProperty(exports, "Exclude", { enumerable: true, get: function() {
    return index_14.Exclude;
  } });
  var index_15 = require_extends2();
  Object.defineProperty(exports, "Extends", { enumerable: true, get: function() {
    return index_15.Extends;
  } });
  var index_16 = require_extract2();
  Object.defineProperty(exports, "Extract", { enumerable: true, get: function() {
    return index_16.Extract;
  } });
  var index_17 = require_function2();
  Object.defineProperty(exports, "Function", { enumerable: true, get: function() {
    return index_17.Function;
  } });
  var index_18 = require_indexed2();
  Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
    return index_18.Index;
  } });
  var index_19 = require_instance_type2();
  Object.defineProperty(exports, "InstanceType", { enumerable: true, get: function() {
    return index_19.InstanceType;
  } });
  var index_20 = require_integer2();
  Object.defineProperty(exports, "Integer", { enumerable: true, get: function() {
    return index_20.Integer;
  } });
  var index_21 = require_intersect2();
  Object.defineProperty(exports, "Intersect", { enumerable: true, get: function() {
    return index_21.Intersect;
  } });
  var index_22 = require_intrinsic2();
  Object.defineProperty(exports, "Capitalize", { enumerable: true, get: function() {
    return index_22.Capitalize;
  } });
  Object.defineProperty(exports, "Uncapitalize", { enumerable: true, get: function() {
    return index_22.Uncapitalize;
  } });
  Object.defineProperty(exports, "Lowercase", { enumerable: true, get: function() {
    return index_22.Lowercase;
  } });
  Object.defineProperty(exports, "Uppercase", { enumerable: true, get: function() {
    return index_22.Uppercase;
  } });
  var index_23 = require_iterator2();
  Object.defineProperty(exports, "Iterator", { enumerable: true, get: function() {
    return index_23.Iterator;
  } });
  var index_24 = require_keyof2();
  Object.defineProperty(exports, "KeyOf", { enumerable: true, get: function() {
    return index_24.KeyOf;
  } });
  var index_25 = require_literal2();
  Object.defineProperty(exports, "Literal", { enumerable: true, get: function() {
    return index_25.Literal;
  } });
  var index_26 = require_mapped2();
  Object.defineProperty(exports, "Mapped", { enumerable: true, get: function() {
    return index_26.Mapped;
  } });
  var index_27 = require_never2();
  Object.defineProperty(exports, "Never", { enumerable: true, get: function() {
    return index_27.Never;
  } });
  var index_28 = require_not2();
  Object.defineProperty(exports, "Not", { enumerable: true, get: function() {
    return index_28.Not;
  } });
  var index_29 = require_null2();
  Object.defineProperty(exports, "Null", { enumerable: true, get: function() {
    return index_29.Null;
  } });
  var index_30 = require_number2();
  Object.defineProperty(exports, "Number", { enumerable: true, get: function() {
    return index_30.Number;
  } });
  var index_31 = require_object2();
  Object.defineProperty(exports, "Object", { enumerable: true, get: function() {
    return index_31.Object;
  } });
  var index_32 = require_omit2();
  Object.defineProperty(exports, "Omit", { enumerable: true, get: function() {
    return index_32.Omit;
  } });
  var index_33 = require_optional2();
  Object.defineProperty(exports, "Optional", { enumerable: true, get: function() {
    return index_33.Optional;
  } });
  var index_34 = require_parameters2();
  Object.defineProperty(exports, "Parameters", { enumerable: true, get: function() {
    return index_34.Parameters;
  } });
  var index_35 = require_partial2();
  Object.defineProperty(exports, "Partial", { enumerable: true, get: function() {
    return index_35.Partial;
  } });
  var index_36 = require_pick2();
  Object.defineProperty(exports, "Pick", { enumerable: true, get: function() {
    return index_36.Pick;
  } });
  var index_37 = require_promise2();
  Object.defineProperty(exports, "Promise", { enumerable: true, get: function() {
    return index_37.Promise;
  } });
  var index_38 = require_readonly2();
  Object.defineProperty(exports, "Readonly", { enumerable: true, get: function() {
    return index_38.Readonly;
  } });
  var index_39 = require_readonly_optional2();
  Object.defineProperty(exports, "ReadonlyOptional", { enumerable: true, get: function() {
    return index_39.ReadonlyOptional;
  } });
  var index_40 = require_record2();
  Object.defineProperty(exports, "Record", { enumerable: true, get: function() {
    return index_40.Record;
  } });
  var index_41 = require_recursive2();
  Object.defineProperty(exports, "Recursive", { enumerable: true, get: function() {
    return index_41.Recursive;
  } });
  var index_42 = require_ref2();
  Object.defineProperty(exports, "Ref", { enumerable: true, get: function() {
    return index_42.Ref;
  } });
  var index_43 = require_regexp2();
  Object.defineProperty(exports, "RegExp", { enumerable: true, get: function() {
    return index_43.RegExp;
  } });
  var index_44 = require_required2();
  Object.defineProperty(exports, "Required", { enumerable: true, get: function() {
    return index_44.Required;
  } });
  var index_45 = require_rest2();
  Object.defineProperty(exports, "Rest", { enumerable: true, get: function() {
    return index_45.Rest;
  } });
  var index_46 = require_return_type2();
  Object.defineProperty(exports, "ReturnType", { enumerable: true, get: function() {
    return index_46.ReturnType;
  } });
  var index_47 = require_strict2();
  Object.defineProperty(exports, "Strict", { enumerable: true, get: function() {
    return index_47.Strict;
  } });
  var index_48 = require_string2();
  Object.defineProperty(exports, "String", { enumerable: true, get: function() {
    return index_48.String;
  } });
  var index_49 = require_symbol2();
  Object.defineProperty(exports, "Symbol", { enumerable: true, get: function() {
    return index_49.Symbol;
  } });
  var index_50 = require_template_literal2();
  Object.defineProperty(exports, "TemplateLiteral", { enumerable: true, get: function() {
    return index_50.TemplateLiteral;
  } });
  var index_51 = require_transform3();
  Object.defineProperty(exports, "Transform", { enumerable: true, get: function() {
    return index_51.Transform;
  } });
  var index_52 = require_tuple2();
  Object.defineProperty(exports, "Tuple", { enumerable: true, get: function() {
    return index_52.Tuple;
  } });
  var index_53 = require_uint8array2();
  Object.defineProperty(exports, "Uint8Array", { enumerable: true, get: function() {
    return index_53.Uint8Array;
  } });
  var index_54 = require_undefined2();
  Object.defineProperty(exports, "Undefined", { enumerable: true, get: function() {
    return index_54.Undefined;
  } });
  var index_55 = require_union2();
  Object.defineProperty(exports, "Union", { enumerable: true, get: function() {
    return index_55.Union;
  } });
  var index_56 = require_unknown2();
  Object.defineProperty(exports, "Unknown", { enumerable: true, get: function() {
    return index_56.Unknown;
  } });
  var index_57 = require_unsafe2();
  Object.defineProperty(exports, "Unsafe", { enumerable: true, get: function() {
    return index_57.Unsafe;
  } });
  var index_58 = require_void2();
  Object.defineProperty(exports, "Void", { enumerable: true, get: function() {
    return index_58.Void;
  } });
});

// node_modules/@sinclair/typebox/build/cjs/type/type/javascript.js
var require_javascript = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.JavaScriptTypeBuilder = undefined;
  var json_1 = require_json();
  var index_1 = require_async_iterator2();
  var index_2 = require_awaited2();
  var index_3 = require_bigint2();
  var index_4 = require_constructor2();
  var index_5 = require_constructor_parameters2();
  var index_6 = require_date2();
  var index_7 = require_function2();
  var index_8 = require_instance_type2();
  var index_9 = require_iterator2();
  var index_10 = require_parameters2();
  var index_11 = require_promise2();
  var index_12 = require_regexp2();
  var index_13 = require_return_type2();
  var index_14 = require_symbol2();
  var index_15 = require_uint8array2();
  var index_16 = require_undefined2();
  var index_17 = require_void2();

  class JavaScriptTypeBuilder extends json_1.JsonTypeBuilder {
    AsyncIterator(items, options = {}) {
      return (0, index_1.AsyncIterator)(items, options);
    }
    Awaited(schema, options = {}) {
      return (0, index_2.Awaited)(schema, options);
    }
    BigInt(options = {}) {
      return (0, index_3.BigInt)(options);
    }
    ConstructorParameters(schema, options = {}) {
      return (0, index_5.ConstructorParameters)(schema, options);
    }
    Constructor(parameters, returns, options) {
      return (0, index_4.Constructor)(parameters, returns, options);
    }
    Date(options = {}) {
      return (0, index_6.Date)(options);
    }
    Function(parameters, returns, options) {
      return (0, index_7.Function)(parameters, returns, options);
    }
    InstanceType(schema, options = {}) {
      return (0, index_8.InstanceType)(schema, options);
    }
    Iterator(items, options = {}) {
      return (0, index_9.Iterator)(items, options);
    }
    Parameters(schema, options = {}) {
      return (0, index_10.Parameters)(schema, options);
    }
    Promise(item, options = {}) {
      return (0, index_11.Promise)(item, options);
    }
    RegExp(unresolved, options = {}) {
      return (0, index_12.RegExp)(unresolved, options);
    }
    ReturnType(schema, options = {}) {
      return (0, index_13.ReturnType)(schema, options);
    }
    Symbol(options) {
      return (0, index_14.Symbol)(options);
    }
    Undefined(options = {}) {
      return (0, index_16.Undefined)(options);
    }
    Uint8Array(options = {}) {
      return (0, index_15.Uint8Array)(options);
    }
    Void(options = {}) {
      return (0, index_17.Void)(options);
    }
  }
  exports.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
});

// node_modules/@sinclair/typebox/build/cjs/type/type/index.js
var require_type5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Type = exports.JavaScriptTypeBuilder = exports.JsonTypeBuilder = undefined;
  var json_1 = require_json();
  Object.defineProperty(exports, "JsonTypeBuilder", { enumerable: true, get: function() {
    return json_1.JsonTypeBuilder;
  } });
  var TypeBuilder = require_type4();
  var javascript_1 = require_javascript();
  Object.defineProperty(exports, "JavaScriptTypeBuilder", { enumerable: true, get: function() {
    return javascript_1.JavaScriptTypeBuilder;
  } });
  var Type = TypeBuilder;
  exports.Type = Type;
});

// node_modules/@sinclair/typebox/build/cjs/index.js
var require_cjs2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_clone3(), exports);
  __exportStar(require_error2(), exports);
  __exportStar(require_guard3(), exports);
  __exportStar(require_helpers2(), exports);
  __exportStar(require_patterns2(), exports);
  __exportStar(require_registry(), exports);
  __exportStar(require_sets(), exports);
  __exportStar(require_symbols2(), exports);
  __exportStar(require_any2(), exports);
  __exportStar(require_array2(), exports);
  __exportStar(require_async_iterator2(), exports);
  __exportStar(require_awaited2(), exports);
  __exportStar(require_bigint2(), exports);
  __exportStar(require_boolean2(), exports);
  __exportStar(require_composite2(), exports);
  __exportStar(require_const2(), exports);
  __exportStar(require_constructor2(), exports);
  __exportStar(require_constructor_parameters2(), exports);
  __exportStar(require_date2(), exports);
  __exportStar(require_deref4(), exports);
  __exportStar(require_enum2(), exports);
  __exportStar(require_exclude2(), exports);
  __exportStar(require_extends2(), exports);
  __exportStar(require_extract2(), exports);
  __exportStar(require_function2(), exports);
  __exportStar(require_indexed2(), exports);
  __exportStar(require_instance_type2(), exports);
  __exportStar(require_integer2(), exports);
  __exportStar(require_intersect2(), exports);
  __exportStar(require_iterator2(), exports);
  __exportStar(require_intrinsic2(), exports);
  __exportStar(require_keyof2(), exports);
  __exportStar(require_literal2(), exports);
  __exportStar(require_mapped2(), exports);
  __exportStar(require_never2(), exports);
  __exportStar(require_not2(), exports);
  __exportStar(require_null2(), exports);
  __exportStar(require_number2(), exports);
  __exportStar(require_object2(), exports);
  __exportStar(require_omit2(), exports);
  __exportStar(require_optional2(), exports);
  __exportStar(require_parameters2(), exports);
  __exportStar(require_partial2(), exports);
  __exportStar(require_pick2(), exports);
  __exportStar(require_promise2(), exports);
  __exportStar(require_readonly2(), exports);
  __exportStar(require_readonly_optional2(), exports);
  __exportStar(require_record2(), exports);
  __exportStar(require_recursive2(), exports);
  __exportStar(require_ref2(), exports);
  __exportStar(require_regexp2(), exports);
  __exportStar(require_required2(), exports);
  __exportStar(require_rest2(), exports);
  __exportStar(require_return_type2(), exports);
  __exportStar(require_schema2(), exports);
  __exportStar(require_static2(), exports);
  __exportStar(require_strict2(), exports);
  __exportStar(require_string2(), exports);
  __exportStar(require_symbol2(), exports);
  __exportStar(require_template_literal2(), exports);
  __exportStar(require_transform3(), exports);
  __exportStar(require_tuple2(), exports);
  __exportStar(require_uint8array2(), exports);
  __exportStar(require_undefined2(), exports);
  __exportStar(require_union2(), exports);
  __exportStar(require_unknown2(), exports);
  __exportStar(require_unsafe2(), exports);
  __exportStar(require_void2(), exports);
  __exportStar(require_type5(), exports);
});

// node_modules/@sinclair/typebox/build/cjs/compiler/compiler.js
var require_compiler = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TypeCompiler = exports.Policy = exports.TypeCompilerTypeGuardError = exports.TypeCompilerUnknownTypeError = exports.TypeCheck = undefined;
  var index_1 = require_transform();
  var index_2 = require_errors2();
  var index_3 = require_system2();
  var index_4 = require_error2();
  var index_5 = require_deref2();
  var index_6 = require_hash2();
  var index_7 = require_symbols2();
  var index_8 = require_registry();
  var index_9 = require_keyof2();
  var extends_undefined_1 = require_extends_undefined();
  var index_10 = require_never2();
  var index_11 = require_guard2();
  var type_1 = require_type3();

  class TypeCheck {
    constructor(schema, references, checkFunc, code) {
      this.schema = schema;
      this.references = references;
      this.checkFunc = checkFunc;
      this.code = code;
      this.hasTransform = (0, index_1.HasTransform)(schema, references);
    }
    Code() {
      return this.code;
    }
    Errors(value) {
      return (0, index_2.Errors)(this.schema, this.references, value);
    }
    Check(value) {
      return this.checkFunc(value);
    }
    Decode(value) {
      if (!this.checkFunc(value))
        throw new index_1.TransformDecodeCheckError(this.schema, value, this.Errors(value).First());
      return this.hasTransform ? (0, index_1.TransformDecode)(this.schema, this.references, value) : value;
    }
    Encode(value) {
      const encoded = this.hasTransform ? (0, index_1.TransformEncode)(this.schema, this.references, value) : value;
      if (!this.checkFunc(encoded))
        throw new index_1.TransformEncodeCheckError(this.schema, value, this.Errors(value).First());
      return encoded;
    }
  }
  exports.TypeCheck = TypeCheck;
  var Character;
  (function(Character2) {
    function DollarSign(code) {
      return code === 36;
    }
    Character2.DollarSign = DollarSign;
    function IsUnderscore(code) {
      return code === 95;
    }
    Character2.IsUnderscore = IsUnderscore;
    function IsAlpha(code) {
      return code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
    Character2.IsAlpha = IsAlpha;
    function IsNumeric(code) {
      return code >= 48 && code <= 57;
    }
    Character2.IsNumeric = IsNumeric;
  })(Character || (Character = {}));
  var MemberExpression;
  (function(MemberExpression2) {
    function IsFirstCharacterNumeric(value) {
      if (value.length === 0)
        return false;
      return Character.IsNumeric(value.charCodeAt(0));
    }
    function IsAccessor(value) {
      if (IsFirstCharacterNumeric(value))
        return false;
      for (let i = 0;i < value.length; i++) {
        const code = value.charCodeAt(i);
        const check = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
        if (!check)
          return false;
      }
      return true;
    }
    function EscapeHyphen(key) {
      return key.replace(/'/g, "\\'");
    }
    function Encode(object, key) {
      return IsAccessor(key) ? `${object}.${key}` : `${object}['${EscapeHyphen(key)}']`;
    }
    MemberExpression2.Encode = Encode;
  })(MemberExpression || (MemberExpression = {}));
  var Identifier;
  (function(Identifier2) {
    function Encode($id) {
      const buffer = [];
      for (let i = 0;i < $id.length; i++) {
        const code = $id.charCodeAt(i);
        if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
          buffer.push($id.charAt(i));
        } else {
          buffer.push(`_${code}_`);
        }
      }
      return buffer.join("").replace(/__/g, "_");
    }
    Identifier2.Encode = Encode;
  })(Identifier || (Identifier = {}));
  var LiteralString;
  (function(LiteralString2) {
    function Escape(content) {
      return content.replace(/'/g, "\\'");
    }
    LiteralString2.Escape = Escape;
  })(LiteralString || (LiteralString = {}));

  class TypeCompilerUnknownTypeError extends index_4.TypeBoxError {
    constructor(schema) {
      super("Unknown type");
      this.schema = schema;
    }
  }
  exports.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;

  class TypeCompilerTypeGuardError extends index_4.TypeBoxError {
    constructor(schema) {
      super("Preflight validation check failed to guard for the given schema");
      this.schema = schema;
    }
  }
  exports.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
  var Policy;
  (function(Policy2) {
    function IsExactOptionalProperty(value, key, expression) {
      return index_3.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value} ? ${expression} : true)` : `(${MemberExpression.Encode(value, key)} !== undefined ? ${expression} : true)`;
    }
    Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
    function IsObjectLike(value) {
      return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}))` : `(typeof ${value} === 'object' && ${value} !== null)`;
    }
    Policy2.IsObjectLike = IsObjectLike;
    function IsRecordLike(value) {
      return !index_3.TypeSystemPolicy.AllowArrayObject ? `(typeof ${value} === 'object' && ${value} !== null && !Array.isArray(${value}) && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))` : `(typeof ${value} === 'object' && ${value} !== null && !(${value} instanceof Date) && !(${value} instanceof Uint8Array))`;
    }
    Policy2.IsRecordLike = IsRecordLike;
    function IsNumberLike(value) {
      return index_3.TypeSystemPolicy.AllowNaN ? `typeof ${value} === 'number'` : `Number.isFinite(${value})`;
    }
    Policy2.IsNumberLike = IsNumberLike;
    function IsVoidLike(value) {
      return index_3.TypeSystemPolicy.AllowNullVoid ? `(${value} === undefined || ${value} === null)` : `${value} === undefined`;
    }
    Policy2.IsVoidLike = IsVoidLike;
  })(Policy || (exports.Policy = Policy = {}));
  var TypeCompiler;
  (function(TypeCompiler2) {
    function IsAnyOrUnknown(schema) {
      return schema[index_7.Kind] === "Any" || schema[index_7.Kind] === "Unknown";
    }
    function* FromAny(schema, references, value) {
      yield "true";
    }
    function* FromArray(schema, references, value) {
      yield `Array.isArray(${value})`;
      const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
      if ((0, index_11.IsNumber)(schema.maxItems))
        yield `${value}.length <= ${schema.maxItems}`;
      if ((0, index_11.IsNumber)(schema.minItems))
        yield `${value}.length >= ${schema.minItems}`;
      const elementExpression = CreateExpression(schema.items, references, "value");
      yield `${value}.every((${parameter}) => ${elementExpression})`;
      if ((0, type_1.IsSchema)(schema.contains) || (0, index_11.IsNumber)(schema.minContains) || (0, index_11.IsNumber)(schema.maxContains)) {
        const containsSchema = (0, type_1.IsSchema)(schema.contains) ? schema.contains : (0, index_10.Never)();
        const checkExpression = CreateExpression(containsSchema, references, "value");
        const checkMinContains = (0, index_11.IsNumber)(schema.minContains) ? [`(count >= ${schema.minContains})`] : [];
        const checkMaxContains = (0, index_11.IsNumber)(schema.maxContains) ? [`(count <= ${schema.maxContains})`] : [];
        const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
        const check = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
        yield `((${parameter}) => { ${checkCount}; return ${check}})(${value})`;
      }
      if (schema.uniqueItems === true) {
        const check = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
        const block = `const set = new Set(); for(const element of value) { ${check} }`;
        yield `((${parameter}) => { ${block} )(${value})`;
      }
    }
    function* FromAsyncIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.asyncIterator in ${value})`;
    }
    function* FromBigInt(schema, references, value) {
      yield `(typeof ${value} === 'bigint')`;
      if ((0, index_11.IsBigInt)(schema.exclusiveMaximum))
        yield `${value} < BigInt(${schema.exclusiveMaximum})`;
      if ((0, index_11.IsBigInt)(schema.exclusiveMinimum))
        yield `${value} > BigInt(${schema.exclusiveMinimum})`;
      if ((0, index_11.IsBigInt)(schema.maximum))
        yield `${value} <= BigInt(${schema.maximum})`;
      if ((0, index_11.IsBigInt)(schema.minimum))
        yield `${value} >= BigInt(${schema.minimum})`;
      if ((0, index_11.IsBigInt)(schema.multipleOf))
        yield `(${value} % BigInt(${schema.multipleOf})) === 0`;
    }
    function* FromBoolean(schema, references, value) {
      yield `(typeof ${value} === 'boolean')`;
    }
    function* FromConstructor(schema, references, value) {
      yield* Visit(schema.returns, references, `${value}.prototype`);
    }
    function* FromDate(schema, references, value) {
      yield `(${value} instanceof Date) && Number.isFinite(${value}.getTime())`;
      if ((0, index_11.IsNumber)(schema.exclusiveMaximumTimestamp))
        yield `${value}.getTime() < ${schema.exclusiveMaximumTimestamp}`;
      if ((0, index_11.IsNumber)(schema.exclusiveMinimumTimestamp))
        yield `${value}.getTime() > ${schema.exclusiveMinimumTimestamp}`;
      if ((0, index_11.IsNumber)(schema.maximumTimestamp))
        yield `${value}.getTime() <= ${schema.maximumTimestamp}`;
      if ((0, index_11.IsNumber)(schema.minimumTimestamp))
        yield `${value}.getTime() >= ${schema.minimumTimestamp}`;
      if ((0, index_11.IsNumber)(schema.multipleOfTimestamp))
        yield `(${value}.getTime() % ${schema.multipleOfTimestamp}) === 0`;
    }
    function* FromFunction(schema, references, value) {
      yield `(typeof ${value} === 'function')`;
    }
    function* FromInteger(schema, references, value) {
      yield `Number.isInteger(${value})`;
      if ((0, index_11.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, index_11.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, index_11.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, index_11.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, index_11.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* FromIntersect(schema, references, value) {
      const check1 = schema.allOf.map((schema2) => CreateExpression(schema2, references, value)).join(" && ");
      if (schema.unevaluatedProperties === false) {
        const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key))`;
        yield `(${check1} && ${check2})`;
      } else if ((0, type_1.IsSchema)(schema.unevaluatedProperties)) {
        const keyCheck = CreateVariable(`${new RegExp((0, index_9.KeyOfPattern)(schema))};`);
        const check2 = `Object.getOwnPropertyNames(${value}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema.unevaluatedProperties, references, `${value}[key]`)})`;
        yield `(${check1} && ${check2})`;
      } else {
        yield `(${check1})`;
      }
    }
    function* FromIterator(schema, references, value) {
      yield `(typeof value === 'object' && Symbol.iterator in ${value})`;
    }
    function* FromLiteral(schema, references, value) {
      if (typeof schema.const === "number" || typeof schema.const === "boolean") {
        yield `(${value} === ${schema.const})`;
      } else {
        yield `(${value} === '${LiteralString.Escape(schema.const)}')`;
      }
    }
    function* FromNever(schema, references, value) {
      yield `false`;
    }
    function* FromNot(schema, references, value) {
      const expression = CreateExpression(schema.not, references, value);
      yield `(!${expression})`;
    }
    function* FromNull(schema, references, value) {
      yield `(${value} === null)`;
    }
    function* FromNumber(schema, references, value) {
      yield Policy.IsNumberLike(value);
      if ((0, index_11.IsNumber)(schema.exclusiveMaximum))
        yield `${value} < ${schema.exclusiveMaximum}`;
      if ((0, index_11.IsNumber)(schema.exclusiveMinimum))
        yield `${value} > ${schema.exclusiveMinimum}`;
      if ((0, index_11.IsNumber)(schema.maximum))
        yield `${value} <= ${schema.maximum}`;
      if ((0, index_11.IsNumber)(schema.minimum))
        yield `${value} >= ${schema.minimum}`;
      if ((0, index_11.IsNumber)(schema.multipleOf))
        yield `(${value} % ${schema.multipleOf}) === 0`;
    }
    function* FromObject(schema, references, value) {
      yield Policy.IsObjectLike(value);
      if ((0, index_11.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, index_11.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const knownKeys = Object.getOwnPropertyNames(schema.properties);
      for (const knownKey of knownKeys) {
        const memberExpression = MemberExpression.Encode(value, knownKey);
        const property = schema.properties[knownKey];
        if (schema.required && schema.required.includes(knownKey)) {
          yield* Visit(property, references, memberExpression);
          if ((0, extends_undefined_1.ExtendsUndefinedCheck)(property) || IsAnyOrUnknown(property))
            yield `('${knownKey}' in ${value})`;
        } else {
          const expression = CreateExpression(property, references, memberExpression);
          yield Policy.IsExactOptionalProperty(value, knownKey, expression);
        }
      }
      if (schema.additionalProperties === false) {
        if (schema.required && schema.required.length === knownKeys.length) {
          yield `Object.getOwnPropertyNames(${value}).length === ${knownKeys.length}`;
        } else {
          const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
          yield `Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key))`;
        }
      }
      if (typeof schema.additionalProperties === "object") {
        const expression = CreateExpression(schema.additionalProperties, references, `${value}[key]`);
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `(Object.getOwnPropertyNames(${value}).every(key => ${keys}.includes(key) || ${expression}))`;
      }
    }
    function* FromPromise(schema, references, value) {
      yield `(typeof value === 'object' && typeof ${value}.then === 'function')`;
    }
    function* FromRecord(schema, references, value) {
      yield Policy.IsRecordLike(value);
      if ((0, index_11.IsNumber)(schema.minProperties))
        yield `Object.getOwnPropertyNames(${value}).length >= ${schema.minProperties}`;
      if ((0, index_11.IsNumber)(schema.maxProperties))
        yield `Object.getOwnPropertyNames(${value}).length <= ${schema.maxProperties}`;
      const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
      const variable = CreateVariable(`${new RegExp(patternKey)}`);
      const check1 = CreateExpression(patternSchema, references, "value");
      const check2 = (0, type_1.IsSchema)(schema.additionalProperties) ? CreateExpression(schema.additionalProperties, references, value) : schema.additionalProperties === false ? "false" : "true";
      const expression = `(${variable}.test(key) ? ${check1} : ${check2})`;
      yield `(Object.entries(${value}).every(([key, value]) => ${expression}))`;
    }
    function* FromRef(schema, references, value) {
      const target = (0, index_5.Deref)(schema, references);
      if (state.functions.has(schema.$ref))
        return yield `${CreateFunctionName(schema.$ref)}(${value})`;
      yield* Visit(target, references, value);
    }
    function* FromRegExp(schema, references, value) {
      const variable = CreateVariable(`${new RegExp(schema.source, schema.flags)};`);
      yield `(typeof ${value} === 'string')`;
      if ((0, index_11.IsNumber)(schema.maxLength))
        yield `${value}.length <= ${schema.maxLength}`;
      if ((0, index_11.IsNumber)(schema.minLength))
        yield `${value}.length >= ${schema.minLength}`;
      yield `${variable}.test(${value})`;
    }
    function* FromString(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      if ((0, index_11.IsNumber)(schema.maxLength))
        yield `${value}.length <= ${schema.maxLength}`;
      if ((0, index_11.IsNumber)(schema.minLength))
        yield `${value}.length >= ${schema.minLength}`;
      if (schema.pattern !== undefined) {
        const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
        yield `${variable}.test(${value})`;
      }
      if (schema.format !== undefined) {
        yield `format('${schema.format}', ${value})`;
      }
    }
    function* FromSymbol(schema, references, value) {
      yield `(typeof ${value} === 'symbol')`;
    }
    function* FromTemplateLiteral(schema, references, value) {
      yield `(typeof ${value} === 'string')`;
      const variable = CreateVariable(`${new RegExp(schema.pattern)};`);
      yield `${variable}.test(${value})`;
    }
    function* FromThis(schema, references, value) {
      yield `${CreateFunctionName(schema.$ref)}(${value})`;
    }
    function* FromTuple(schema, references, value) {
      yield `Array.isArray(${value})`;
      if (schema.items === undefined)
        return yield `${value}.length === 0`;
      yield `(${value}.length === ${schema.maxItems})`;
      for (let i = 0;i < schema.items.length; i++) {
        const expression = CreateExpression(schema.items[i], references, `${value}[${i}]`);
        yield `${expression}`;
      }
    }
    function* FromUndefined(schema, references, value) {
      yield `${value} === undefined`;
    }
    function* FromUnion(schema, references, value) {
      const expressions = schema.anyOf.map((schema2) => CreateExpression(schema2, references, value));
      yield `(${expressions.join(" || ")})`;
    }
    function* FromUint8Array(schema, references, value) {
      yield `${value} instanceof Uint8Array`;
      if ((0, index_11.IsNumber)(schema.maxByteLength))
        yield `(${value}.length <= ${schema.maxByteLength})`;
      if ((0, index_11.IsNumber)(schema.minByteLength))
        yield `(${value}.length >= ${schema.minByteLength})`;
    }
    function* FromUnknown(schema, references, value) {
      yield "true";
    }
    function* FromVoid(schema, references, value) {
      yield Policy.IsVoidLike(value);
    }
    function* FromKind(schema, references, value) {
      const instance = state.instances.size;
      state.instances.set(instance, schema);
      yield `kind('${schema[index_7.Kind]}', ${instance}, ${value})`;
    }
    function* Visit(schema, references, value, useHoisting = true) {
      const references_ = (0, index_11.IsString)(schema.$id) ? [...references, schema] : references;
      const schema_ = schema;
      if (useHoisting && (0, index_11.IsString)(schema.$id)) {
        const functionName = CreateFunctionName(schema.$id);
        if (state.functions.has(functionName)) {
          return yield `${functionName}(${value})`;
        } else {
          const functionCode = CreateFunction(functionName, schema, references, "value", false);
          state.functions.set(functionName, functionCode);
          return yield `${functionName}(${value})`;
        }
      }
      switch (schema_[index_7.Kind]) {
        case "Any":
          return yield* FromAny(schema_, references_, value);
        case "Array":
          return yield* FromArray(schema_, references_, value);
        case "AsyncIterator":
          return yield* FromAsyncIterator(schema_, references_, value);
        case "BigInt":
          return yield* FromBigInt(schema_, references_, value);
        case "Boolean":
          return yield* FromBoolean(schema_, references_, value);
        case "Constructor":
          return yield* FromConstructor(schema_, references_, value);
        case "Date":
          return yield* FromDate(schema_, references_, value);
        case "Function":
          return yield* FromFunction(schema_, references_, value);
        case "Integer":
          return yield* FromInteger(schema_, references_, value);
        case "Intersect":
          return yield* FromIntersect(schema_, references_, value);
        case "Iterator":
          return yield* FromIterator(schema_, references_, value);
        case "Literal":
          return yield* FromLiteral(schema_, references_, value);
        case "Never":
          return yield* FromNever(schema_, references_, value);
        case "Not":
          return yield* FromNot(schema_, references_, value);
        case "Null":
          return yield* FromNull(schema_, references_, value);
        case "Number":
          return yield* FromNumber(schema_, references_, value);
        case "Object":
          return yield* FromObject(schema_, references_, value);
        case "Promise":
          return yield* FromPromise(schema_, references_, value);
        case "Record":
          return yield* FromRecord(schema_, references_, value);
        case "Ref":
          return yield* FromRef(schema_, references_, value);
        case "RegExp":
          return yield* FromRegExp(schema_, references_, value);
        case "String":
          return yield* FromString(schema_, references_, value);
        case "Symbol":
          return yield* FromSymbol(schema_, references_, value);
        case "TemplateLiteral":
          return yield* FromTemplateLiteral(schema_, references_, value);
        case "This":
          return yield* FromThis(schema_, references_, value);
        case "Tuple":
          return yield* FromTuple(schema_, references_, value);
        case "Undefined":
          return yield* FromUndefined(schema_, references_, value);
        case "Union":
          return yield* FromUnion(schema_, references_, value);
        case "Uint8Array":
          return yield* FromUint8Array(schema_, references_, value);
        case "Unknown":
          return yield* FromUnknown(schema_, references_, value);
        case "Void":
          return yield* FromVoid(schema_, references_, value);
        default:
          if (!index_8.TypeRegistry.Has(schema_[index_7.Kind]))
            throw new TypeCompilerUnknownTypeError(schema);
          return yield* FromKind(schema_, references_, value);
      }
    }
    const state = {
      language: "javascript",
      functions: new Map,
      variables: new Map,
      instances: new Map
    };
    function CreateExpression(schema, references, value, useHoisting = true) {
      return `(${[...Visit(schema, references, value, useHoisting)].join(" && ")})`;
    }
    function CreateFunctionName($id) {
      return `check_${Identifier.Encode($id)}`;
    }
    function CreateVariable(expression) {
      const variableName = `local_${state.variables.size}`;
      state.variables.set(variableName, `const ${variableName} = ${expression}`);
      return variableName;
    }
    function CreateFunction(name, schema, references, value, useHoisting = true) {
      const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const expression = [...Visit(schema, references, value, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
      return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
    }
    function CreateParameter(name, type) {
      const annotation = state.language === "typescript" ? `: ${type}` : "";
      return `${name}${annotation}`;
    }
    function CreateReturns(type) {
      return state.language === "typescript" ? `: ${type}` : "";
    }
    function Build(schema, references, options) {
      const functionCode = CreateFunction("check", schema, references, "value");
      const parameter = CreateParameter("value", "any");
      const returns = CreateReturns("boolean");
      const functions = [...state.functions.values()];
      const variables = [...state.variables.values()];
      const checkFunction = (0, index_11.IsString)(schema.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema.$id)}(value)
}` : `return ${functionCode}`;
      return [...variables, ...functions, checkFunction].join(`
`);
    }
    function Code(...args) {
      const defaults = { language: "javascript" };
      const [schema, references, options] = args.length === 2 && (0, index_11.IsArray)(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !(0, index_11.IsArray)(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
      state.language = options.language;
      state.variables.clear();
      state.functions.clear();
      state.instances.clear();
      if (!(0, type_1.IsSchema)(schema))
        throw new TypeCompilerTypeGuardError(schema);
      for (const schema2 of references)
        if (!(0, type_1.IsSchema)(schema2))
          throw new TypeCompilerTypeGuardError(schema2);
      return Build(schema, references, options);
    }
    TypeCompiler2.Code = Code;
    function Compile(schema, references = []) {
      const generatedCode = Code(schema, references, { language: "javascript" });
      const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
      const instances = new Map(state.instances);
      function typeRegistryFunction(kind, instance, value) {
        if (!index_8.TypeRegistry.Has(kind) || !instances.has(instance))
          return false;
        const checkFunc = index_8.TypeRegistry.Get(kind);
        const schema2 = instances.get(instance);
        return checkFunc(schema2, value);
      }
      function formatRegistryFunction(format, value) {
        if (!index_8.FormatRegistry.Has(format))
          return false;
        const checkFunc = index_8.FormatRegistry.Get(format);
        return checkFunc(value);
      }
      function hashFunction(value) {
        return (0, index_6.Hash)(value);
      }
      const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
      return new TypeCheck(schema, references, checkFunction, generatedCode);
    }
    TypeCompiler2.Compile = Compile;
  })(TypeCompiler || (exports.TypeCompiler = TypeCompiler = {}));
});

// node_modules/@sinclair/typebox/build/cjs/compiler/index.js
var require_compiler2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValueErrorIterator = exports.ValueErrorType = undefined;
  var index_1 = require_errors2();
  Object.defineProperty(exports, "ValueErrorType", { enumerable: true, get: function() {
    return index_1.ValueErrorType;
  } });
  Object.defineProperty(exports, "ValueErrorIterator", { enumerable: true, get: function() {
    return index_1.ValueErrorIterator;
  } });
  __exportStar(require_compiler(), exports);
});

// node_modules/cookie/index.js
var require_cookie = __commonJS((exports) => {
  /*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  exports.parse = parse;
  exports.serialize = serialize;
  var __toString = Object.prototype.toString;
  var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  function parse(str, options) {
    if (typeof str !== "string") {
      throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode;
    var index = 0;
    while (index < str.length) {
      var eqIdx = str.indexOf("=", index);
      if (eqIdx === -1) {
        break;
      }
      var endIdx = str.indexOf(";", index);
      if (endIdx === -1) {
        endIdx = str.length;
      } else if (endIdx < eqIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      var key = str.slice(index, eqIdx).trim();
      if (obj[key] === undefined) {
        var val = str.slice(eqIdx + 1, endIdx).trim();
        if (val.charCodeAt(0) === 34) {
          val = val.slice(1, -1);
        }
        obj[key] = tryDecode(val, dec);
      }
      index = endIdx + 1;
    }
    return obj;
  }
  function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
      throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
      throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
      throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (opt.maxAge != null) {
      var maxAge = opt.maxAge - 0;
      if (isNaN(maxAge) || !isFinite(maxAge)) {
        throw new TypeError("option maxAge is invalid");
      }
      str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
      if (!fieldContentRegExp.test(opt.domain)) {
        throw new TypeError("option domain is invalid");
      }
      str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
      if (!fieldContentRegExp.test(opt.path)) {
        throw new TypeError("option path is invalid");
      }
      str += "; Path=" + opt.path;
    }
    if (opt.expires) {
      var expires = opt.expires;
      if (!isDate(expires) || isNaN(expires.valueOf())) {
        throw new TypeError("option expires is invalid");
      }
      str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
      str += "; HttpOnly";
    }
    if (opt.secure) {
      str += "; Secure";
    }
    if (opt.partitioned) {
      str += "; Partitioned";
    }
    if (opt.priority) {
      var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
      switch (priority) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError("option priority is invalid");
      }
    }
    if (opt.sameSite) {
      var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
      switch (sameSite) {
        case true:
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError("option sameSite is invalid");
      }
    }
    return str;
  }
  function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
  }
  function encode(val) {
    return encodeURIComponent(val);
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
  }
  function tryDecode(str, decode2) {
    try {
      return decode2(str);
    } catch (e) {
      return str;
    }
  }
});

// node_modules/fast-decode-uri-component/index.js
var require_fast_decode_uri_component = __commonJS((exports, module) => {
  var UTF8_ACCEPT = 12;
  var UTF8_REJECT = 0;
  var UTF8_DATA = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    3,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    7,
    7,
    10,
    9,
    9,
    9,
    11,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    24,
    36,
    48,
    60,
    72,
    84,
    96,
    0,
    12,
    12,
    12,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    24,
    24,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    48,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    127,
    63,
    63,
    63,
    0,
    31,
    15,
    15,
    15,
    7,
    7,
    7
  ];
  function decodeURIComponent2(uri) {
    var percentPosition = uri.indexOf("%");
    if (percentPosition === -1)
      return uri;
    var length = uri.length;
    var decoded = "";
    var last = 0;
    var codepoint = 0;
    var startOfOctets = percentPosition;
    var state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri[percentPosition + 1], 4);
      var low = hexCodeToInt(uri[percentPosition + 2], 0);
      var byte = high | low;
      var type = UTF8_DATA[byte];
      state = UTF8_DATA[256 + state + type];
      codepoint = codepoint << 6 | byte & UTF8_DATA[364 + type];
      if (state === UTF8_ACCEPT) {
        decoded += uri.slice(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023));
        codepoint = 0;
        last = percentPosition + 3;
        percentPosition = startOfOctets = uri.indexOf("%", last);
      } else if (state === UTF8_REJECT) {
        return null;
      } else {
        percentPosition += 3;
        if (percentPosition < length && uri.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri.slice(last);
  }
  var HEX = {
    "0": 0,
    "1": 1,
    "2": 2,
    "3": 3,
    "4": 4,
    "5": 5,
    "6": 6,
    "7": 7,
    "8": 8,
    "9": 9,
    a: 10,
    A: 10,
    b: 11,
    B: 11,
    c: 12,
    C: 12,
    d: 13,
    D: 13,
    e: 14,
    E: 14,
    f: 15,
    F: 15
  };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});

// node_modules/fast-querystring/lib/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var fastDecode = require_fast_decode_uri_component();
  var plusRegex = /\+/g;
  var Empty = function() {};
  Empty.prototype = Object.create(null);
  function parse(input) {
    const result = new Empty;
    if (typeof input !== "string") {
      return result;
    }
    let inputLength = input.length;
    let key = "";
    let value = "";
    let startingIndex = -1;
    let equalityIndex = -1;
    let shouldDecodeKey = false;
    let shouldDecodeValue = false;
    let keyHasPlus = false;
    let valueHasPlus = false;
    let hasBothKeyValuePair = false;
    let c = 0;
    for (let i = 0;i < inputLength + 1; i++) {
      c = i !== inputLength ? input.charCodeAt(i) : 38;
      if (c === 38) {
        hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair) {
          equalityIndex = i;
        }
        key = input.slice(startingIndex + 1, equalityIndex);
        if (hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus) {
            key = key.replace(plusRegex, " ");
          }
          if (shouldDecodeKey) {
            key = fastDecode(key) || key;
          }
          if (hasBothKeyValuePair) {
            value = input.slice(equalityIndex + 1, i);
            if (valueHasPlus) {
              value = value.replace(plusRegex, " ");
            }
            if (shouldDecodeValue) {
              value = fastDecode(value) || value;
            }
          }
          const currentValue = result[key];
          if (currentValue === undefined) {
            result[key] = value;
          } else {
            if (currentValue.pop) {
              currentValue.push(value);
            } else {
              result[key] = [currentValue, value];
            }
          }
        }
        value = "";
        startingIndex = i;
        equalityIndex = i;
        shouldDecodeKey = false;
        shouldDecodeValue = false;
        keyHasPlus = false;
        valueHasPlus = false;
      } else if (c === 61) {
        if (equalityIndex <= startingIndex) {
          equalityIndex = i;
        } else {
          shouldDecodeValue = true;
        }
      } else if (c === 43) {
        if (equalityIndex > startingIndex) {
          valueHasPlus = true;
        } else {
          keyHasPlus = true;
        }
      } else if (c === 37) {
        if (equalityIndex > startingIndex) {
          shouldDecodeValue = true;
        } else {
          shouldDecodeKey = true;
        }
      }
    }
    return result;
  }
  module.exports = parse;
});

// node_modules/fast-querystring/lib/internals/querystring.js
var require_querystring = __commonJS((exports, module) => {
  var hexTable = Array.from({ length: 256 }, (_, i) => "%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  var noEscape = new Int8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    0,
    0,
    1,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    1,
    0
  ]);
  function encodeString(str) {
    const len = str.length;
    if (len === 0)
      return "";
    let out = "";
    let lastPos = 0;
    let i = 0;
    outer:
      for (;i < len; i++) {
        let c = str.charCodeAt(i);
        while (c < 128) {
          if (noEscape[c] !== 1) {
            if (lastPos < i)
              out += str.slice(lastPos, i);
            lastPos = i + 1;
            out += hexTable[c];
          }
          if (++i === len)
            break outer;
          c = str.charCodeAt(i);
        }
        if (lastPos < i)
          out += str.slice(lastPos, i);
        if (c < 2048) {
          lastPos = i + 1;
          out += hexTable[192 | c >> 6] + hexTable[128 | c & 63];
          continue;
        }
        if (c < 55296 || c >= 57344) {
          lastPos = i + 1;
          out += hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
          continue;
        }
        ++i;
        if (i >= len) {
          throw new Error("URI malformed");
        }
        const c2 = str.charCodeAt(i) & 1023;
        lastPos = i + 1;
        c = 65536 + ((c & 1023) << 10 | c2);
        out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
      }
    if (lastPos === 0)
      return str;
    if (lastPos < len)
      return out + str.slice(lastPos);
    return out;
  }
  module.exports = { encodeString };
});

// node_modules/fast-querystring/lib/stringify.js
var require_stringify = __commonJS((exports, module) => {
  var { encodeString } = require_querystring();
  function getAsPrimitive(value) {
    const type = typeof value;
    if (type === "string") {
      return encodeString(value);
    } else if (type === "bigint") {
      return value.toString();
    } else if (type === "boolean") {
      return value ? "true" : "false";
    } else if (type === "number" && Number.isFinite(value)) {
      return value < 1000000000000000000000 ? "" + value : encodeString("" + value);
    }
    return "";
  }
  function stringify(input) {
    let result = "";
    if (input === null || typeof input !== "object") {
      return result;
    }
    const separator = "&";
    const keys = Object.keys(input);
    const keyLength = keys.length;
    let valueLength = 0;
    for (let i = 0;i < keyLength; i++) {
      const key = keys[i];
      const value = input[key];
      const encodedKey = encodeString(key) + "=";
      if (i) {
        result += separator;
      }
      if (Array.isArray(value)) {
        valueLength = value.length;
        for (let j = 0;j < valueLength; j++) {
          if (j) {
            result += separator;
          }
          result += encodedKey;
          result += getAsPrimitive(value[j]);
        }
      } else {
        result += encodedKey;
        result += getAsPrimitive(value);
      }
    }
    return result;
  }
  module.exports = stringify;
});

// node_modules/fast-querystring/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var parse = require_parse2();
  var stringify = require_stringify();
  var fastQuerystring = {
    parse,
    stringify
  };
  module.exports = fastQuerystring;
  module.exports.default = fastQuerystring;
  module.exports.parse = parse;
  module.exports.stringify = stringify;
});

// node_modules/elysia/dist/cjs/index.js
var require_cjs3 = __commonJS((exports, module) => {
  var __create2 = Object.create;
  var __defProp2 = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __toCommonJS = (mod) => __copyProps(__defProp2({}, "__esModule", { value: true }), mod);
  var src_exports = {};
  __export2(src_exports, {
    Cookie: () => Cookie,
    Elysia: () => Elysia,
    InternalServerError: () => InternalServerError,
    InvalidCookieSignature: () => InvalidCookieSignature,
    NotFoundError: () => NotFoundError,
    ParseError: () => ParseError,
    ValidationError: () => ValidationError,
    default: () => Elysia,
    error: () => error,
    getResponseSchemaValidator: () => getResponseSchemaValidator,
    getSchemaValidator: () => getSchemaValidator,
    mapCompactResponse: () => mapCompactResponse,
    mapEarlyResponse: () => mapEarlyResponse,
    mapResponse: () => mapResponse,
    mergeDeep: () => mergeDeep,
    mergeHook: () => mergeHook,
    mergeObjectArray: () => mergeObjectArray,
    t: () => t
  });
  module.exports = __toCommonJS(src_exports);
  var import_memoirist = require_cjs();
  var import_eventemitter3 = __toESM2(require_eventemitter3());
  var resolver = () => {
    let resolve;
    const promise = new Promise((r) => {
      resolve = r;
    });
    return [promise, resolve];
  };
  var createSignal = () => {
    const [start, resolveStart] = resolver();
    const [end, resolveEnd] = resolver();
    const children = [];
    const resolvers = [];
    return {
      signal: start,
      consume: (trace) => {
        switch (trace.type) {
          case "begin":
            if (trace.unit && children.length === 0)
              for (let i = 0;i < trace.unit; i++) {
                const [start2, resolveStart2] = resolver();
                const [end2, resolveEnd2] = resolver();
                children.push(start2);
                resolvers.push([
                  (trace2) => {
                    resolveStart2({
                      children: [],
                      end: end2,
                      name: trace2.name ?? "",
                      skip: false,
                      time: trace2.time
                    });
                  },
                  (time) => {
                    resolveEnd2(time);
                  }
                ]);
              }
            resolveStart({
              children,
              end,
              name: trace.name ?? "",
              skip: false,
              time: trace.time
            });
            break;
          case "end":
            resolveEnd(trace.time);
            break;
        }
      },
      consumeChild(trace) {
        switch (trace.type) {
          case "begin":
            if (!resolvers[0])
              return;
            const [resolveStart2] = resolvers[0];
            resolveStart2({
              children: [],
              end,
              name: trace.name ?? "",
              skip: false,
              time: trace.time
            });
            break;
          case "end":
            const child = resolvers.shift();
            if (!child)
              return;
            child[1](trace.time);
        }
      },
      resolve() {
        resolveStart({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        for (const [resolveStart2, resolveEnd2] of resolvers) {
          resolveStart2({
            children: [],
            end: new Promise((resolve) => resolve(0)),
            name: "",
            skip: true,
            time: 0
          });
          resolveEnd2(0);
        }
        resolveEnd(0);
      }
    };
  };
  var createTraceListener = (getReporter, totalListener, handler) => {
    return async function trace(trace) {
      if (trace.event !== "request" || trace.type !== "begin")
        return;
      const id = trace.id;
      const reporter = getReporter();
      const request = createSignal();
      const parse2 = createSignal();
      const transform = createSignal();
      const beforeHandle = createSignal();
      const handle = createSignal();
      const afterHandle = createSignal();
      const error2 = createSignal();
      const response = createSignal();
      request.consume(trace);
      const reducer = (event) => {
        if (event.id === id)
          switch (event.event) {
            case "request":
              request.consume(event);
              break;
            case "request.unit":
              request.consumeChild(event);
              break;
            case "parse":
              parse2.consume(event);
              break;
            case "parse.unit":
              parse2.consumeChild(event);
              break;
            case "transform":
              transform.consume(event);
              break;
            case "transform.unit":
              transform.consumeChild(event);
              break;
            case "beforeHandle":
              beforeHandle.consume(event);
              break;
            case "beforeHandle.unit":
              beforeHandle.consumeChild(event);
              break;
            case "handle":
              handle.consume(event);
              break;
            case "afterHandle":
              afterHandle.consume(event);
              break;
            case "afterHandle.unit":
              afterHandle.consumeChild(event);
              break;
            case "error":
              error2.consume(event);
              break;
            case "error.unit":
              error2.consumeChild(event);
              break;
            case "response":
              if (event.type === "begin") {
                request.resolve();
                parse2.resolve();
                transform.resolve();
                beforeHandle.resolve();
                handle.resolve();
                afterHandle.resolve();
                error2.resolve();
              } else
                reporter.off("event", reducer);
              response.consume(event);
              break;
            case "response.unit":
              response.consumeChild(event);
              break;
            case "exit":
              request.resolve();
              parse2.resolve();
              transform.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error2.resolve();
              break;
          }
      };
      reporter.on("event", reducer);
      await handler({
        id,
        context: trace.ctx,
        set: trace.ctx?.set,
        store: trace.ctx?.store,
        time: trace.time,
        request: request.signal,
        parse: parse2.signal,
        transform: transform.signal,
        beforeHandle: beforeHandle.signal,
        handle: handle.signal,
        afterHandle: afterHandle.signal,
        error: error2.signal,
        response: response.signal
      });
      reporter.emit(`res${id}.${totalListener}`, undefined);
    };
  };
  var import_value2 = require_value5();
  var import_typebox = require_cjs2();
  var import_value = require_value5();
  var import_compiler = require_compiler2();
  var import_cookie2 = require_cookie();
  var import_cookie = require_cookie();
  var Cookie = class {
    constructor(_value, property = {}) {
      this._value = _value;
      this.property = property;
    }
    get() {
      return this._value;
    }
    get value() {
      return this._value;
    }
    set value(value) {
      if (typeof value === "object") {
        if (JSON.stringify(this.value) === JSON.stringify(value))
          return;
      } else if (this.value === value)
        return;
      this._value = value;
      this.sync();
    }
    add(config) {
      const updated = Object.assign(this.property, typeof config === "function" ? config(Object.assign(this.property, this.value)) : config);
      if ("value" in updated) {
        this._value = updated.value;
        delete updated.value;
      }
      this.property = updated;
      return this.sync();
    }
    set(config) {
      const updated = typeof config === "function" ? config(Object.assign(this.property, this.value)) : config;
      if ("value" in updated) {
        this._value = updated.value;
        delete updated.value;
      }
      this.property = updated;
      return this.sync();
    }
    remove(options) {
      if (this.value === undefined)
        return;
      this.set({
        domain: options?.domain,
        expires: /* @__PURE__ */ new Date(0),
        maxAge: 0,
        path: options?.path,
        sameSite: options?.sameSite,
        secure: options?.secure,
        value: ""
      });
    }
    get domain() {
      return this.property.domain;
    }
    set domain(value) {
      if (this.property.domain === value)
        return;
      this.property.domain = value;
      this.sync();
    }
    get expires() {
      return this.property.expires;
    }
    set expires(value) {
      if (this.property.expires?.getTime() === value?.getTime())
        return;
      this.property.expires = value;
      this.sync();
    }
    get httpOnly() {
      return this.property.httpOnly;
    }
    set httpOnly(value) {
      if (this.property.domain === value)
        return;
      this.property.httpOnly = value;
      this.sync();
    }
    get maxAge() {
      return this.property.maxAge;
    }
    set maxAge(value) {
      if (this.property.maxAge === value)
        return;
      this.property.maxAge = value;
      this.sync();
    }
    get path() {
      return this.property.path;
    }
    set path(value) {
      if (this.property.path === value)
        return;
      this.property.path = value;
      this.sync();
    }
    get priority() {
      return this.property.priority;
    }
    set priority(value) {
      if (this.property.priority === value)
        return;
      this.property.priority = value;
      this.sync();
    }
    get sameSite() {
      return this.property.sameSite;
    }
    set sameSite(value) {
      if (this.property.sameSite === value)
        return;
      this.property.sameSite = value;
      this.sync();
    }
    get secure() {
      return this.property.secure;
    }
    set secure(value) {
      if (this.property.secure === value)
        return;
      this.property.secure = value;
      this.sync();
    }
    toString() {
      return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
    }
    sync() {
      if (!this.name || !this.setter)
        return this;
      if (!this.setter.cookie)
        this.setter.cookie = {
          [this.name]: Object.assign(this.property, {
            value: this.toString()
          })
        };
      else
        this.setter.cookie[this.name] = Object.assign(this.property, {
          value: this.toString()
        });
      return this;
    }
  };
  var createCookieJar = (initial, set, properties) => new Proxy(initial, {
    get(target, key) {
      if (key in target)
        return target[key];
      const cookie = new Cookie(undefined, properties ? { ...properties } : undefined);
      cookie.setter = set;
      cookie.name = key;
      return cookie;
    },
    set(target, key, value) {
      if (!(value instanceof Cookie))
        return false;
      if (!set.cookie)
        set.cookie = {};
      value.setter = set;
      value.name = key;
      value.sync();
      target[key] = value;
      return true;
    }
  });
  var parseCookie = async (set, cookieString, {
    secret,
    sign,
    ...properties
  } = {}) => {
    if (!cookieString)
      return createCookieJar({}, set, properties);
    const jar = {};
    const isStringKey = typeof secret === "string";
    if (sign && sign !== true && !Array.isArray(sign))
      sign = [sign];
    const cookieKeys = Object.keys((0, import_cookie.parse)(cookieString));
    for (let i = 0;i < cookieKeys.length; i++) {
      const key = cookieKeys[i];
      let value = (0, import_cookie.parse)(cookieString)[key];
      if (sign === true || sign?.includes(key)) {
        if (!secret)
          throw new Error("No secret is provided to cookie plugin");
        if (isStringKey) {
          value = await unsignCookie(value, secret);
          if (value === false)
            throw new InvalidCookieSignature(key);
        } else {
          let fail = true;
          for (let i2 = 0;i2 < secret.length; i2++) {
            const temp = await unsignCookie(value, secret[i2]);
            if (temp !== false) {
              value = temp;
              fail = false;
              break;
            }
          }
          if (fail)
            throw new InvalidCookieSignature(key);
        }
      }
      if (value === undefined)
        continue;
      const start = value.charCodeAt(0);
      if (start === 123 || start === 91)
        try {
          const cookie2 = new Cookie(JSON.parse(value));
          cookie2.setter = set;
          cookie2.name = key;
          jar[key] = cookie2;
          continue;
        } catch {}
      if (isNumericString(value))
        value = +value;
      else if (value === "true")
        value = true;
      else if (value === "false")
        value = false;
      const cookie = new Cookie(value, properties);
      cookie.setter = set;
      cookie.name = key;
      jar[key] = cookie;
    }
    return createCookieJar(jar, set);
  };
  var hasHeaderShorthand = "toJSON" in new Headers;
  var isNotEmpty = (obj) => {
    for (const x in obj)
      return true;
    return false;
  };
  var handleFile = (response, set) => {
    const size = response.size;
    if (size && set && set.status !== 206 && set.status !== 304 && set.status !== 412 && set.status !== 416 || !set && size) {
      if (set) {
        if (set.headers instanceof Headers) {
          if (hasHeaderShorthand)
            set.headers = set.headers.toJSON();
          else
            for (const [key, value] of set.headers.entries())
              if (key in set.headers)
                set.headers[key] = value;
        }
        return new Response(response, {
          status: set.status,
          headers: Object.assign({
            "accept-ranges": "bytes",
            "content-range": `bytes 0-${size - 1}/${size}`
          }, set.headers)
        });
      }
      return new Response(response, {
        headers: {
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`
        }
      });
    }
    return new Response(response);
  };
  var parseSetCookies = (headers, setCookie) => {
    if (!headers || !Array.isArray(setCookie))
      return headers;
    headers.delete("Set-Cookie");
    for (let i = 0;i < setCookie.length; i++) {
      const index = setCookie[i].indexOf("=");
      headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`);
    }
    return headers;
  };
  var cookieToHeader = (cookies) => {
    if (!cookies || typeof cookies !== "object" || !isNotEmpty(cookies))
      return;
    const set = [];
    for (const [key, property] of Object.entries(cookies)) {
      if (!key || !property)
        continue;
      if (Array.isArray(property.value)) {
        for (let i = 0;i < property.value.length; i++) {
          let value = property.value[i];
          if (value === undefined || value === null)
            continue;
          if (typeof value === "object")
            value = JSON.stringify(value);
          set.push((0, import_cookie2.serialize)(key, value, property));
        }
      } else {
        let value = property.value;
        if (value === undefined || value === null)
          continue;
        if (typeof value === "object")
          value = JSON.stringify(value);
        set.push((0, import_cookie2.serialize)(key, property.value, property));
      }
    }
    if (set.length === 0)
      return;
    if (set.length === 1)
      return set[0];
    return set;
  };
  var mapResponse = (response, set) => {
    if (response?.[response.$passthrough])
      response = response[response.$passthrough];
    if (response?.[ELYSIA_RESPONSE]) {
      set.status = response[ELYSIA_RESPONSE];
      response = response.response;
    }
    if (isNotEmpty(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
      if (typeof set.status === "string")
        set.status = StatusMap[set.status];
      if (set.redirect) {
        set.headers.Location = set.redirect;
        if (!set.status || set.status < 300 || set.status >= 400)
          set.status = 302;
      }
      if (set.cookie && isNotEmpty(set.cookie))
        set.headers["Set-Cookie"] = cookieToHeader(set.cookie);
      if (set.headers["Set-Cookie"] && Array.isArray(set.headers["Set-Cookie"]))
        set.headers = parseSetCookies(new Headers(set.headers), set.headers["Set-Cookie"]);
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response, set);
        case "Blob":
          return handleFile(response, set);
        case "Object":
        case "Array":
          return Response.json(response, set);
        case "ReadableStream":
          if (!set.headers["content-type"]?.startsWith("text/event-stream"))
            set.headers["content-type"] = "text/event-stream; charset=utf-8";
          return new Response(response, set);
        case undefined:
          if (!response)
            return new Response("", set);
          return Response.json(response, set);
        case "Response":
          const inherits = { ...set.headers };
          if (hasHeaderShorthand)
            set.headers = response.headers.toJSON();
          else
            for (const [key, value] of response.headers.entries())
              if (key in set.headers)
                set.headers[key] = value;
          for (const key in inherits)
            response.headers.append(key, inherits[key]);
          return response;
        case "Error":
          return errorToResponse(response, set);
        case "Promise":
          return response.then((x) => mapResponse(x, set));
        case "Function":
          return mapResponse(response(), set);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set);
        case "Cookie":
          if (response instanceof Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          if (response instanceof Response) {
            const inherits2 = { ...set.headers };
            if (hasHeaderShorthand)
              set.headers = response.headers.toJSON();
            else
              for (const [key, value] of response.headers.entries())
                if (key in set.headers)
                  set.headers[key] = value;
            for (const key in inherits2)
              response.headers.append(key, inherits2[key]);
            return response;
          }
          if (response instanceof Promise)
            return response.then((x) => mapResponse(x, set));
          if (response instanceof Error)
            return errorToResponse(response, set);
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set);
          }
          return new Response(r, set);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Blob":
          return handleFile(response, set);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "ReadableStream":
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Error":
          return errorToResponse(response, set);
        case "Promise":
          return response.then((x) => {
            const r2 = mapCompactResponse(x);
            if (r2 !== undefined)
              return r2;
            return new Response("");
          });
        case "Function":
          return mapCompactResponse(response());
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          if (response instanceof Response)
            return new Response(response.body, {
              headers: {
                "Content-Type": "application/json"
              }
            });
          if (response instanceof Promise)
            return response.then((x) => mapResponse(x, set));
          if (response instanceof Error)
            return errorToResponse(response, set);
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123)
            return new Response(JSON.stringify(response), {
              headers: {
                "Content-Type": "application/json"
              }
            });
          return new Response(r);
      }
  };
  var mapEarlyResponse = (response, set) => {
    if (response === undefined || response === null)
      return;
    if (response?.$passthrough)
      response = response[response.$passthrough];
    if (response?.[ELYSIA_RESPONSE]) {
      set.status = response[ELYSIA_RESPONSE];
      response = response.response;
    }
    if (isNotEmpty(set.headers) || set.status !== 200 || set.redirect || set.cookie) {
      if (typeof set.status === "string")
        set.status = StatusMap[set.status];
      if (set.redirect) {
        set.headers.Location = set.redirect;
        if (!set.status || set.status < 300 || set.status >= 400)
          set.status = 302;
      }
      if (set.cookie && isNotEmpty(set.cookie))
        set.headers["Set-Cookie"] = cookieToHeader(set.cookie);
      if (set.headers["Set-Cookie"] && Array.isArray(set.headers["Set-Cookie"]))
        set.headers = parseSetCookies(new Headers(set.headers), set.headers["Set-Cookie"]);
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response, set);
        case "Blob":
          return handleFile(response, set);
        case "Object":
        case "Array":
          return Response.json(response, set);
        case "ReadableStream":
          if (!set.headers["content-type"]?.startsWith("text/event-stream"))
            set.headers["content-type"] = "text/event-stream; charset=utf-8";
          return new Response(response, set);
        case undefined:
          if (!response)
            return;
          return Response.json(response, set);
        case "Response":
          const inherits = Object.assign({}, set.headers);
          if (hasHeaderShorthand)
            set.headers = response.headers.toJSON();
          else
            for (const [key, value] of response.headers.entries())
              if (!(key in set.headers))
                set.headers[key] = value;
          for (const key in inherits)
            response.headers.append(key, inherits[key]);
          if (response.status !== set.status)
            set.status = response.status;
          return response;
        case "Promise":
          return response.then((x) => {
            const r2 = mapEarlyResponse(x, set);
            if (r2 !== undefined)
              return r2;
            return;
          });
        case "Error":
          return errorToResponse(response, set);
        case "Function":
          return mapEarlyResponse(response(), set);
        case "Number":
        case "Boolean":
          return new Response(response.toString(), set);
        case "Cookie":
          if (response instanceof Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          if (response instanceof Response) {
            const inherits2 = { ...set.headers };
            if (hasHeaderShorthand)
              set.headers = response.headers.toJSON();
            else
              for (const [key, value] of response.headers.entries())
                if (key in set.headers)
                  set.headers[key] = value;
            for (const key in inherits2)
              response.headers.append(key, inherits2[key]);
            return response;
          }
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse(x, set));
          if (response instanceof Error)
            return errorToResponse(response, set);
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123) {
            if (!set.headers["Content-Type"])
              set.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set);
          }
          return new Response(r, set);
      }
    } else
      switch (response?.constructor?.name) {
        case "String":
          return new Response(response);
        case "Blob":
          return handleFile(response, set);
        case "Object":
        case "Array":
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "ReadableStream":
          return new Response(response, {
            headers: {
              "Content-Type": "text/event-stream; charset=utf-8"
            }
          });
        case undefined:
          if (!response)
            return new Response("");
          return new Response(JSON.stringify(response), {
            headers: {
              "content-type": "application/json"
            }
          });
        case "Response":
          return response;
        case "Promise":
          return response.then((x) => {
            const r2 = mapEarlyResponse(x, set);
            if (r2 !== undefined)
              return r2;
            return;
          });
        case "Error":
          return errorToResponse(response, set);
        case "Function":
          return mapCompactResponse(response());
        case "Number":
        case "Boolean":
          return new Response(response.toString());
        case "Cookie":
          if (response instanceof Cookie)
            return new Response(response.value, set);
          return new Response(response?.toString(), set);
        default:
          if (response instanceof Response)
            return new Response(response.body, {
              headers: {
                "Content-Type": "application/json"
              }
            });
          if (response instanceof Promise)
            return response.then((x) => mapEarlyResponse(x, set));
          if (response instanceof Error)
            return errorToResponse(response, set);
          const r = JSON.stringify(response);
          if (r.charCodeAt(0) === 123)
            return new Response(JSON.stringify(response), {
              headers: {
                "Content-Type": "application/json"
              }
            });
          return new Response(r);
      }
  };
  var mapCompactResponse = (response) => {
    if (response?.$passthrough)
      response = response[response.$passthrough];
    if (response?.[ELYSIA_RESPONSE])
      return mapResponse(response.response, {
        status: response[ELYSIA_RESPONSE],
        headers: {}
      });
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse(response);
      case "Promise":
        return response.then(mapCompactResponse);
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then(mapCompactResponse);
        if (response instanceof Error)
          return errorToResponse(response);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        return new Response(r);
    }
  };
  var errorToResponse = (error2, set) => new Response(JSON.stringify({
    name: error2?.name,
    message: error2?.message,
    cause: error2?.cause
  }), {
    status: set?.status !== 200 ? set?.status ?? 500 : 500,
    headers: set?.headers
  });
  var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
  var replaceUrlPath = (url, pathname) => {
    const urlObject = new URL(url);
    urlObject.pathname = pathname;
    return urlObject.toString();
  };
  var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || isNotEmpty(Object.getPrototypeOf(v));
  var mergeDeep = (target, source, {
    skipKeys
  } = {}) => {
    if (isObject(target) && isObject(source))
      for (const [key, value] of Object.entries(source)) {
        if (skipKeys?.includes(key))
          continue;
        if (!isObject(value)) {
          target[key] = value;
          continue;
        }
        if (!(key in target)) {
          target[key] = value;
          continue;
        }
        if (isClass(value)) {
          target[key] = value;
          continue;
        }
        target[key] = mergeDeep(target[key], value);
      }
    return target;
  };
  var mergeCookie = (target, source) => mergeDeep(target, source, {
    skipKeys: ["properties"]
  });
  var mergeObjectArray = (a, b) => {
    if (!a)
      return [];
    const array = [...Array.isArray(a) ? a : [a]];
    const checksums = [];
    for (const item of array) {
      if (item.$elysiaChecksum)
        checksums.push(item.$elysiaChecksum);
    }
    for (const item of Array.isArray(b) ? b : [b]) {
      if (!checksums.includes(item?.$elysiaChecksum)) {
        array.push(item);
      }
    }
    return array;
  };
  var primitiveHooks = [
    "start",
    "request",
    "parse",
    "transform",
    "resolve",
    "beforeHandle",
    "afterHandle",
    "onResponse",
    "mapResponse",
    "trace",
    "error",
    "stop",
    "body",
    "headers",
    "params",
    "query",
    "response",
    "type",
    "detail"
  ];
  var mergeHook = (a, b) => {
    return {
      ...a,
      ...b,
      body: b?.body ?? a?.body,
      headers: b?.headers ?? a?.headers,
      params: b?.params ?? a?.params,
      query: b?.query ?? a?.query,
      response: b?.response ?? a?.response,
      type: a?.type || b?.type,
      detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}),
      parse: mergeObjectArray(a?.parse ?? [], b?.parse ?? []),
      transform: mergeObjectArray(a?.transform ?? [], b?.transform ?? []),
      beforeHandle: mergeObjectArray(a?.beforeHandle ?? [], b?.beforeHandle ?? []),
      afterHandle: mergeObjectArray(a?.afterHandle ?? [], b?.afterHandle ?? []),
      onResponse: mergeObjectArray(a?.onResponse ?? [], b?.onResponse ?? []),
      mapResponse: mergeObjectArray(a?.mapResponse ?? [], b?.mapResponse ?? []),
      trace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []),
      error: mergeObjectArray(a?.error ?? [], b?.error ?? [])
    };
  };
  var getSchemaValidator = (s, {
    models = {},
    additionalProperties = false,
    dynamic = false
  }) => {
    if (!s)
      return;
    if (typeof s === "string" && !(s in models))
      return;
    const schema = typeof s === "string" ? models[s] : s;
    if (schema.type === "object" && "additionalProperties" in schema === false)
      schema.additionalProperties = additionalProperties;
    if (dynamic)
      return {
        schema,
        references: "",
        checkFunc: () => {},
        code: "",
        Check: (value) => import_value.Value.Check(schema, value),
        Errors: (value) => import_value.Value.Errors(schema, value),
        Code: () => ""
      };
    return import_compiler.TypeCompiler.Compile(schema, Object.values(models));
  };
  var getResponseSchemaValidator = (s, {
    models = {},
    additionalProperties = false,
    dynamic = false
  }) => {
    if (!s)
      return;
    if (typeof s === "string" && !(s in models))
      return;
    const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
    const compile = (schema, references) => {
      if (dynamic)
        return {
          schema,
          references: "",
          checkFunc: () => {},
          code: "",
          Check: (value) => import_value.Value.Check(schema, value),
          Errors: (value) => import_value.Value.Errors(schema, value),
          Code: () => ""
        };
      return import_compiler.TypeCompiler.Compile(schema, references);
    };
    if (import_typebox.Kind in maybeSchemaOrRecord) {
      if ("additionalProperties" in maybeSchemaOrRecord === false)
        maybeSchemaOrRecord.additionalProperties = additionalProperties;
      return {
        200: compile(maybeSchemaOrRecord, Object.values(models))
      };
    }
    const record = {};
    Object.keys(maybeSchemaOrRecord).forEach((status) => {
      const maybeNameOrSchema = maybeSchemaOrRecord[+status];
      if (typeof maybeNameOrSchema === "string") {
        if (maybeNameOrSchema in models) {
          const schema = models[maybeNameOrSchema];
          schema.type === "object" && "additionalProperties" in schema;
          record[+status] = import_typebox.Kind in schema ? compile(schema, Object.values(models)) : schema;
        }
        return;
      }
      if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
        maybeNameOrSchema.additionalProperties = additionalProperties;
      record[+status] = import_typebox.Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
    });
    return record;
  };
  var isBun = typeof Bun !== "undefined";
  var hasHash = isBun && typeof Bun.hash === "function";
  var checksum = (s) => {
    if (hasHash)
      return Bun.hash(s);
    let h = 9;
    for (let i = 0;i < s.length; )
      h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
    return h = h ^ h >>> 9;
  };
  var mergeLifeCycle = (a, b, checksum2) => {
    const injectChecksum = (x) => {
      if (checksum2 && !x.$elysiaChecksum)
        x.$elysiaChecksum = checksum2;
      return x;
    };
    return {
      ...a,
      ...b,
      start: mergeObjectArray(a.start, ("start" in b ? b.start ?? [] : []).map(injectChecksum)),
      request: mergeObjectArray(a.request, ("request" in b ? b.request ?? [] : []).map(injectChecksum)),
      parse: mergeObjectArray(a.parse, "parse" in b ? b?.parse ?? [] : []).map(injectChecksum),
      transform: mergeObjectArray(a.transform, (b?.transform ?? []).map(injectChecksum)),
      beforeHandle: mergeObjectArray(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
      afterHandle: mergeObjectArray(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
      mapResponse: mergeObjectArray(a.mapResponse, (b?.mapResponse ?? []).map(injectChecksum)),
      onResponse: mergeObjectArray(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
      trace: a.trace,
      error: mergeObjectArray(a.error, (b?.error ?? []).map(injectChecksum)),
      stop: mergeObjectArray(a.stop, ("stop" in b ? b.stop ?? [] : []).map(injectChecksum))
    };
  };
  var asGlobal = (fn, inject = true) => {
    if (!fn)
      return fn;
    if (typeof fn === "function") {
      if (inject)
        fn.$elysiaHookType = "global";
      else
        fn.$elysiaHookType = undefined;
      return fn;
    }
    return fn.map((x) => {
      if (inject)
        x.$elysiaHookType = "global";
      else
        x.$elysiaHookType = undefined;
      return x;
    });
  };
  var filterGlobal = (fn) => {
    if (!fn)
      return fn;
    if (typeof fn === "function") {
      return fn.$elysiaHookType === "global" ? fn : undefined;
    }
    return fn.filter((x) => x.$elysiaHookType === "global");
  };
  var filterGlobalHook = (hook) => {
    return {
      ...hook,
      type: hook?.type,
      detail: hook?.detail,
      parse: filterGlobal(hook?.parse),
      transform: filterGlobal(hook?.transform),
      beforeHandle: filterGlobal(hook?.beforeHandle),
      afterHandle: filterGlobal(hook?.afterHandle),
      onResponse: filterGlobal(hook?.onResponse),
      error: filterGlobal(hook?.error)
    };
  };
  var StatusMap = {
    Continue: 100,
    "Switching Protocols": 101,
    Processing: 102,
    "Early Hints": 103,
    OK: 200,
    Created: 201,
    Accepted: 202,
    "Non-Authoritative Information": 203,
    "No Content": 204,
    "Reset Content": 205,
    "Partial Content": 206,
    "Multi-Status": 207,
    "Already Reported": 208,
    "Multiple Choices": 300,
    "Moved Permanently": 301,
    Found: 302,
    "See Other": 303,
    "Not Modified": 304,
    "Temporary Redirect": 307,
    "Permanent Redirect": 308,
    "Bad Request": 400,
    Unauthorized: 401,
    "Payment Required": 402,
    Forbidden: 403,
    "Not Found": 404,
    "Method Not Allowed": 405,
    "Not Acceptable": 406,
    "Proxy Authentication Required": 407,
    "Request Timeout": 408,
    Conflict: 409,
    Gone: 410,
    "Length Required": 411,
    "Precondition Failed": 412,
    "Payload Too Large": 413,
    "URI Too Long": 414,
    "Unsupported Media Type": 415,
    "Range Not Satisfiable": 416,
    "Expectation Failed": 417,
    "I'm a teapot": 418,
    "Misdirected Request": 421,
    "Unprocessable Content": 422,
    Locked: 423,
    "Failed Dependency": 424,
    "Too Early": 425,
    "Upgrade Required": 426,
    "Precondition Required": 428,
    "Too Many Requests": 429,
    "Request Header Fields Too Large": 431,
    "Unavailable For Legal Reasons": 451,
    "Internal Server Error": 500,
    "Not Implemented": 501,
    "Bad Gateway": 502,
    "Service Unavailable": 503,
    "Gateway Timeout": 504,
    "HTTP Version Not Supported": 505,
    "Variant Also Negotiates": 506,
    "Insufficient Storage": 507,
    "Loop Detected": 508,
    "Not Extended": 510,
    "Network Authentication Required": 511
  };
  var signCookie = async (val, secret) => {
    if (typeof val !== "string")
      throw new TypeError("Cookie value must be provided as a string.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const encoder = new TextEncoder;
    const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
    const hmacArray = Array.from(new Uint8Array(hmacBuffer));
    const digest = btoa(String.fromCharCode(...hmacArray));
    return `${val}.${digest.replace(/=+$/, "")}`;
  };
  var unsignCookie = async (input, secret) => {
    if (typeof input !== "string")
      throw new TypeError("Signed cookie string must be provided.");
    if (secret === null)
      throw new TypeError("Secret key must be provided.");
    const tentativeValue = input.slice(0, input.lastIndexOf("."));
    const expectedInput = await signCookie(tentativeValue, secret);
    return expectedInput === input ? tentativeValue : false;
  };
  var traceBackMacro = (extension, property, hooks = property) => {
    for (const [key, value] of Object.entries(property ?? {})) {
      if (primitiveHooks.includes(key) || !(key in extension))
        continue;
      if (typeof extension[key] === "function") {
        extension[key](value);
      } else if (typeof extension[key] === "object")
        traceBackMacro(extension[key], value, hooks);
    }
  };
  var isNumericString = (message) => {
    if (message.length < 16)
      return message.trim().length !== 0 && !Number.isNaN(Number(message));
    if (message.length === 16) {
      const numVal = Number(message);
      if (numVal.toString() === message)
        return message.trim().length !== 0 && !Number.isNaN(numVal);
    }
    return false;
  };
  var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
  var ERROR_CODE = Symbol("ElysiaErrorCode");
  var ELYSIA_RESPONSE = Symbol("ElysiaResponse");
  var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
  var error = (code, response) => ({
    [ELYSIA_RESPONSE]: StatusMap[code] ?? code,
    response
  });
  var InternalServerError = class extends Error {
    constructor(message) {
      super(message ?? "INTERNAL_SERVER_ERROR");
      this.code = "INTERNAL_SERVER_ERROR";
      this.status = 500;
    }
  };
  var NotFoundError = class extends Error {
    constructor(message) {
      super(message ?? "NOT_FOUND");
      this.code = "NOT_FOUND";
      this.status = 404;
    }
  };
  var ParseError = class extends Error {
    constructor(message) {
      super(message ?? "PARSE");
      this.code = "PARSE";
      this.status = 400;
    }
  };
  var InvalidCookieSignature = class extends Error {
    constructor(key, message) {
      super(message ?? `"${key}" has invalid cookie signature`);
      this.key = key;
      this.code = "INVALID_COOKIE_SIGNATURE";
      this.status = 400;
    }
  };
  var ValidationError = class _ValidationError extends Error {
    constructor(type, validator, value) {
      const error2 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value).First() : import_value2.Value.Errors(validator, value).First();
      const customError = error2?.schema.error ? typeof error2.schema.error === "function" ? error2.schema.error(type, validator, value) : error2.schema.error : undefined;
      const accessor = error2?.path?.slice(1) || "root";
      let message = "";
      if (customError) {
        message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
      } else if (isProduction) {
        message = JSON.stringify({
          type,
          message: error2?.message
        });
      } else {
        message = JSON.stringify({
          type,
          at: accessor,
          message: error2?.message,
          expected: import_value2.Value.Create(validator.schema),
          found: value,
          errors: [...validator.Errors(value)]
        }, null, 2);
      }
      super(message);
      this.type = type;
      this.validator = validator;
      this.value = value;
      this.code = "VALIDATION";
      this.status = 400;
      Object.setPrototypeOf(this, _ValidationError.prototype);
    }
    get all() {
      return [...this.validator.Errors(this.value)];
    }
    static simplifyModel(validator) {
      const model = "schema" in validator ? validator.schema : validator;
      try {
        return import_value2.Value.Create(model);
      } catch {
        return model;
      }
    }
    get model() {
      return _ValidationError.simplifyModel(this.validator);
    }
    toResponse(headers) {
      return new Response(this.message, {
        status: 400,
        headers
      });
    }
  };
  var websocket = {
    open(ws) {
      ws.data.open?.(ws);
    },
    message(ws, message) {
      ws.data.message?.(ws, message);
    },
    drain(ws) {
      ws.data.drain?.(ws);
    },
    close(ws, code, reason) {
      ws.data.close?.(ws, code, reason);
    }
  };
  var ElysiaWS = class {
    constructor(raw, data) {
      this.raw = raw;
      this.data = data;
      this.validator = raw.data.validator;
      if (raw.data.id) {
        this.id = raw.data.id;
      } else {
        const array = new Uint32Array(1);
        crypto.getRandomValues(array);
        this.id = array[0].toString();
      }
    }
    get id() {
      return this.raw.data.id;
    }
    set id(newID) {
      this.raw.data.id = newID;
    }
    get publish() {
      return (topic, data = undefined, compress) => {
        if (this.validator?.Check(data) === false)
          throw new ValidationError("message", this.validator, data);
        if (typeof data === "object")
          data = JSON.stringify(data);
        this.raw.publish(topic, data, compress);
        return this;
      };
    }
    get send() {
      return (data) => {
        if (this.validator?.Check(data) === false)
          throw new ValidationError("message", this.validator, data);
        if (Buffer.isBuffer(data)) {
          this.raw.send(data);
          return this;
        }
        if (typeof data === "object")
          data = JSON.stringify(data);
        this.raw.send(data);
        return this;
      };
    }
    get subscribe() {
      return (room) => {
        this.raw.subscribe(room);
        return this;
      };
    }
    get unsubscribe() {
      return (room) => {
        this.raw.unsubscribe(room);
        return this;
      };
    }
    get cork() {
      return (callback) => {
        this.raw.cork(callback);
        return this;
      };
    }
    get close() {
      return () => {
        this.raw.close();
        return this;
      };
    }
    get terminate() {
      return this.raw.terminate.bind(this.raw);
    }
    get isSubscribed() {
      return this.raw.isSubscribed.bind(this.raw);
    }
    get remoteAddress() {
      return this.raw.remoteAddress;
    }
  };
  var import_value3 = require_value5();
  var import_fast_querystring = require_lib();
  var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component());
  var headersHasToJSON = new Headers().toJSON;
  var findAliases = new RegExp(` (\\w+) = context`, "g");
  var requestId = { value: 0 };
  var createReport = ({
    hasTrace,
    hasTraceSet = false,
    addFn,
    condition = {}
  }) => {
    if (hasTrace) {
      addFn(`
const reporter = getReporter()
`);
      return (event, {
        name,
        attribute = "",
        unit = 0
      } = {}) => {
        const dotIndex = event.indexOf(".");
        const isGroup = dotIndex === -1;
        if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
          return () => {
            if (hasTraceSet && event === "afterHandle")
              addFn(`
await traceDone
`);
          };
        if (isGroup)
          name ||= event;
        else
          name ||= "anonymous";
        addFn(`
` + `reporter.emit('event', {
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + `
`);
        let handled = false;
        return () => {
          if (handled)
            return;
          handled = true;
          addFn(`
` + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + `
`);
          if (hasTraceSet && event === "afterHandle")
            addFn(`
await traceDone
`);
        };
      };
    } else {
      return () => () => {};
    }
  };
  var hasReturn = (fnLiteral) => {
    const parenthesisEnd = fnLiteral.indexOf(")");
    if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
      return true;
    }
    return fnLiteral.includes("return");
  };
  var composeValidationFactory = (hasErrorHandler, {
    injectResponse = ""
  } = {}) => ({
    composeValidation: (type, value = `c.${type}`) => hasErrorHandler ? `c.set.status = 400; throw new ValidationError(
'${type}',
${type},
${value}
)` : `c.set.status = 400; return new ValidationError(
	'${type}',
	${type},
	${value}
).toResponse(c.set.headers)`,
    composeResponseValidation: (name = "r") => {
      const returnError = hasErrorHandler ? `throw new ValidationError(
'response',
response[c.set.status],
${name}
)` : `return new ValidationError(
'response',
response[c.set.status],
${name}
).toResponse(c.set.headers)`;
      return `
${injectResponse}
		if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {
	if(!(response instanceof Error))
		${returnError}
}
`;
    }
  });
  var isFnUse = (keyword, fnLiteral) => {
    if (fnLiteral.startsWith("[object "))
      return false;
    fnLiteral = fnLiteral.trimStart();
    fnLiteral = fnLiteral.replaceAll(/^async /g, "");
    if (/^(\w+)\(/g.test(fnLiteral))
      fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
    const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
    if (argument === "")
      return false;
    const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
    if (argument.charCodeAt(0) === 123) {
      if (argument.includes(keyword))
        return true;
      if (restIndex === -1)
        return false;
    }
    if (fnLiteral.match(new RegExp(`${argument}(.${keyword}|\\["${keyword}"\\])`))) {
      return true;
    }
    const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
    if (fnLiteral.match(new RegExp(`${restAlias}(.${keyword}|\\["${keyword}"\\])`)))
      return true;
    const aliases = [argument];
    if (restAlias)
      aliases.push(restAlias);
    for (const found of fnLiteral.matchAll(findAliases))
      aliases.push(found[1]);
    const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
    for (const [params] of fnLiteral.matchAll(destructuringRegex))
      if (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))
        return true;
    return false;
  };
  var isContextPassToFunction = (fnLiteral) => {
    fnLiteral = fnLiteral.trimStart();
    if (fnLiteral.startsWith("[object"))
      return false;
    fnLiteral = fnLiteral.replaceAll(/^async /g, "");
    if (/^(\w+)\(/g.test(fnLiteral))
      fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
    const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
    if (argument === "")
      return false;
    const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
    const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
    const aliases = [argument];
    if (restAlias)
      aliases.push(restAlias);
    for (const found of fnLiteral.matchAll(findAliases))
      aliases.push(found[1]);
    for (const alias of aliases)
      if (new RegExp(`\\b\\w+\\([^)]*\\b${alias}\\b[^)]*\\)`).test(fnLiteral))
        return true;
    const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
    for (const [renamed] of fnLiteral.matchAll(destructuringRegex))
      if (new RegExp(`\\b\\w+\\([^)]*\\b${renamed}\\b[^)]*\\)`).test(fnLiteral))
        return true;
    return false;
  };
  var KindSymbol = Symbol.for("TypeBox.Kind");
  var hasType = (type, schema) => {
    if (!schema)
      return;
    if (KindSymbol in schema && schema[KindSymbol] === type)
      return true;
    if (schema.type === "object") {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if (hasType(type, property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if (hasType(type, property.anyOf[i]))
              return true;
        }
        if (KindSymbol in property && property[KindSymbol] === type)
          return true;
      }
      return false;
    }
    return schema.properties && KindSymbol in schema.properties && schema.properties[KindSymbol] === type;
  };
  var hasProperty = (expectedProperty, schema) => {
    if (!schema)
      return;
    if (schema.type === "object") {
      const properties = schema.properties;
      if (!properties)
        return false;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (expectedProperty in property)
          return true;
        if (property.type === "object") {
          if (hasProperty(expectedProperty, property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++) {
            if (hasProperty(expectedProperty, property.anyOf[i]))
              return true;
          }
        }
      }
      return false;
    }
    return expectedProperty in schema;
  };
  var TransformSymbol = Symbol.for("TypeBox.Transform");
  var hasTransform = (schema) => {
    if (!schema)
      return;
    if (schema.type === "object" && schema.properties) {
      const properties = schema.properties;
      for (const key of Object.keys(properties)) {
        const property = properties[key];
        if (property.type === "object") {
          if (hasTransform(property))
            return true;
        } else if (property.anyOf) {
          for (let i = 0;i < property.anyOf.length; i++)
            if (hasTransform(property.anyOf[i]))
              return true;
        }
        const hasTransformSymbol = TransformSymbol in property;
        if (hasTransformSymbol)
          return true;
      }
      return false;
    }
    return TransformSymbol in schema || schema.properties && TransformSymbol in schema.properties;
  };
  var getUnionedType = (validator) => {
    if (!validator)
      return;
    const schema = validator?.schema;
    if (schema && "anyOf" in schema) {
      let foundDifference = false;
      const type = schema.anyOf[0].type;
      for (const validator2 of schema.anyOf) {
        if (validator2.type !== type) {
          foundDifference = true;
          break;
        }
      }
      if (!foundDifference)
        return type;
    }
    return validator.schema?.type;
  };
  var matchFnReturn = /(?:return|=>) \S+\(/g;
  var isAsync = (fn) => {
    if (fn.constructor.name === "AsyncFunction")
      return true;
    const literal = fn.toString();
    if (literal.includes("=> response.clone("))
      return false;
    return !!literal.match(matchFnReturn);
  };
  var getDestructureQuery = (fn) => {
    if (!fn.includes("query: {") || fn.includes("query,") || fn.includes("query }"))
      return false;
    const start = fn.indexOf("query: {");
    fn = fn.slice(start + 9);
    fn = fn.slice(0, fn.indexOf("}"));
    return fn.split(",").map((x) => {
      const indexOf = x.indexOf(":");
      if (indexOf === -1)
        return x.trim();
      return x.slice(0, indexOf).trim();
    });
  };
  var composeHandler = ({
    path,
    method,
    hooks,
    validator,
    handler,
    handleError,
    definitions,
    schema,
    onRequest,
    config,
    getReporter,
    setHeader
  }) => {
    const hasErrorHandler = config.forceErrorEncapsulation || hooks.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || !!hooks.trace.length;
    const isHandleFn = typeof handler === "function";
    const handle = isHandleFn ? `handler(c)` : `handler`;
    const handleResponse = hooks.onResponse.length ? `
;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();
` : "";
    const traceLiteral = hooks.trace.map((x) => x.toString());
    let hasUnknownContext = false;
    if (isHandleFn && isContextPassToFunction(handler.toString()))
      hasUnknownContext = true;
    if (!hasUnknownContext)
      for (const [key, value] of Object.entries(hooks)) {
        if (!Array.isArray(value) || !value.length || ![
          "parse",
          "transform",
          "beforeHandle",
          "afterHandle",
          "onResponse"
        ].includes(key))
          continue;
        for (const handle2 of value) {
          if (typeof handle2 !== "function")
            continue;
          if (isContextPassToFunction(handle2.toString())) {
            hasUnknownContext = true;
            break;
          }
        }
        if (hasUnknownContext)
          break;
      }
    const traceConditions = {
      parse: traceLiteral.some((x) => isFnUse("parse", x)),
      transform: traceLiteral.some((x) => isFnUse("transform", x)),
      handle: traceLiteral.some((x) => isFnUse("handle", x)),
      beforeHandle: traceLiteral.some((x) => isFnUse("beforeHandle", x)),
      afterHandle: traceLiteral.some((x) => isFnUse("afterHandle", x)),
      error: hasErrorHandler || traceLiteral.some((x) => isFnUse("error", x))
    };
    const hasTrace = hooks.trace.length > 0;
    let fnLiteral = "";
    const lifeCycleLiteral = validator || method !== "GET" && method !== "HEAD" ? [
      handler,
      ...hooks.transform,
      ...hooks.beforeHandle,
      ...hooks.afterHandle,
      ...hooks.mapResponse
    ].map((x) => typeof x === "function" ? x.toString() : `${x}`) : [];
    const hasBody = method !== "GET" && method !== "HEAD" && (hasUnknownContext || hooks.type !== "none" && (!!validator.body || !!hooks.type || lifeCycleLiteral.some((fn) => isFnUse("body", fn))));
    const hasHeaders = hasUnknownContext || validator.headers || lifeCycleLiteral.some((fn) => isFnUse("headers", fn)) || setHeader && Object.keys(setHeader).length;
    const hasCookie = hasUnknownContext || !!validator.cookie || lifeCycleLiteral.some((fn) => isFnUse("cookie", fn));
    const cookieMeta = validator?.cookie?.schema;
    let encodeCookie = "";
    if (cookieMeta?.sign) {
      if (!cookieMeta.secrets)
        throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
      if (cookieMeta.sign === true) {
        encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
      } else
        for (const name of cookieMeta.sign) {
          encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
        }
      encodeCookie += `}
`;
    }
    const { composeValidation, composeResponseValidation } = composeValidationFactory(hasErrorHandler);
    if (hasHeaders) {
      fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
    }
    if (hasCookie) {
      const get = (name, defaultValue) => {
        const value = cookieMeta?.[name] ?? defaultValue;
        if (!value)
          return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
        if (typeof value === "string")
          return `${name}: '${value}',`;
        if (value instanceof Date)
          return `${name}: new Date(${value.getTime()}),`;
        return `${name}: ${value},`;
      };
      const options = cookieMeta ? `{
			secret: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
      if (hasHeaders)
        fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
      else
        fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
    }
    const hasQuery = hasUnknownContext || validator.query || lifeCycleLiteral.some((fn) => isFnUse("query", fn));
    if (hasQuery) {
      let destructured = [];
      let referenceFullQuery = false;
      if (validator.query && validator.query.schema.type === "object") {
        destructured = Object.keys(validator.query.schema.properties);
      } else
        for (const event of lifeCycleLiteral) {
          const queries = getDestructureQuery(event);
          if (!queries) {
            referenceFullQuery = true;
            continue;
          }
          for (const query of queries)
            if (destructured.indexOf(query) === -1)
              destructured.push(query);
        }
      if (!referenceFullQuery && destructured.length) {
        fnLiteral += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${destructured.map((name, index) => `
						memory = url.indexOf('${name}=')

						const a${index} = memory === -1 ? undefined : url.slice(memory = memory + ${name.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join(`
`)}

				c.query = {
					${destructured.map((name, index) => `'${name}': a${index}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
      } else {
        fnLiteral += `c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}`;
      }
    }
    const traceLiterals = hooks.trace.map((x) => x.toString());
    const hasTraceSet = traceLiterals.some((fn) => isFnUse("set", fn) || isContextPassToFunction(fn));
    hasUnknownContext || hooks.trace.some((fn) => isFnUse("set", fn.toString()));
    const hasSet = setHeader && Object.keys(setHeader).length || hasTraceSet || hasCookie || lifeCycleLiteral.some((fn) => isFnUse("set", fn)) || onRequest.some((fn) => isFnUse("set", fn.toString()));
    if (hasTrace)
      fnLiteral += `
const id = c.$$requestId
`;
    const report = createReport({
      hasTrace,
      hasTraceSet,
      condition: traceConditions,
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    fnLiteral += hasErrorHandler ? `
 try {
` : "";
    if (hasTraceSet) {
      fnLiteral += `
const traceDone = Promise.all([`;
      for (let i = 0;i < hooks.trace.length; i++) {
        fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
      }
      fnLiteral += `])
`;
    }
    const isAsyncHandler = typeof handler === "function" && isAsync(handler);
    const maybeAsync = hasCookie || hasBody || hasTraceSet || isAsyncHandler || !!hooks.mapResponse.length || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync);
    const endParse = report("parse", {
      unit: hooks.parse.length
    });
    if (hasBody) {
      const type = getUnionedType(validator?.body);
      if (hooks.type && !Array.isArray(hooks.type)) {
        if (hooks.type) {
          switch (hooks.type) {
            case "json":
            case "application/json":
              fnLiteral += `c.body = await c.request.json()
`;
              break;
            case "text":
            case "text/plain":
              fnLiteral += `c.body = await c.request.text()
`;
              break;
            case "urlencoded":
            case "application/x-www-form-urlencoded":
              fnLiteral += `c.body = parseQuery(await c.request.text())
`;
              break;
            case "arrayBuffer":
            case "application/octet-stream":
              fnLiteral += `c.body = await c.request.arrayBuffer()
`;
              break;
            case "formdata":
            case "multipart/form-data":
              fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
              break;
          }
        }
        if (hooks.parse.length)
          fnLiteral += "}}";
      } else {
        const getAotParser = () => {
          if (hooks.parse.length && type && !Array.isArray(hooks.type)) {
            const schema2 = validator?.body?.schema;
            switch (type) {
              case "object":
                if (hasType("File", schema2) || hasType("Files", schema2))
                  return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
                break;
              default:
                break;
            }
          }
        };
        const aotParse = getAotParser();
        if (aotParse)
          fnLiteral += aotParse;
        else {
          fnLiteral += `
`;
          fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
          fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`;
          if (hooks.parse.length) {
            fnLiteral += `let used = false
`;
            const endReport = report("parse", {
              unit: hooks.parse.length
            });
            for (let i = 0;i < hooks.parse.length; i++) {
              const endUnit = report("parse.unit", {
                name: hooks.parse[i].name
              });
              const name = `bo${i}`;
              if (i !== 0)
                fnLiteral += `if(!used) {
`;
              fnLiteral += `let ${name} = parse[${i}](c, contentType)
`;
              fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
              fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
              endUnit();
              if (i !== 0)
                fnLiteral += `}`;
            }
            endReport();
          }
          if (hooks.parse.length)
            fnLiteral += `if (!used)`;
          fnLiteral += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}
`;
          fnLiteral += `}
`;
        }
      }
      fnLiteral += `
`;
    }
    endParse();
    if (hooks?.transform) {
      const endTransform = report("transform", {
        unit: hooks.transform.length
      });
      for (let i = 0;i < hooks.transform.length; i++) {
        const transform = hooks.transform[i];
        const endUnit = report("transform.unit", {
          name: transform.name
        });
        if (transform.$elysia === "derive")
          fnLiteral += isAsync(transform) ? `Object.assign(c, await transform[${i}](c));` : `Object.assign(c, transform[${i}](c));`;
        else
          fnLiteral += isAsync(transform) ? `await transform[${i}](c);` : `transform[${i}](c);`;
        endUnit();
      }
      endTransform();
    }
    if (validator) {
      fnLiteral += `
`;
      if (validator.headers) {
        if (hasProperty("default", validator.headers.params))
          for (const [key, value] of Object.entries(import_value3.Value.Default(validator.headers.schema, {}))) {
            const parsed = typeof value === "object" ? JSON.stringify(value) : `'${value}'`;
            if (parsed)
              fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
          }
        fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
        if (hasTransform(validator.headers.schema))
          fnLiteral += `
c.headers = headers.Decode(c.headers)
`;
      }
      if (validator.params) {
        if (hasProperty("default", validator.params.schema))
          for (const [key, value] of Object.entries(import_value3.Value.Default(validator.params.schema, {}))) {
            const parsed = typeof value === "object" ? JSON.stringify(value) : `'${value}'`;
            if (parsed)
              fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
          }
        fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
        if (hasTransform(validator.params.schema))
          fnLiteral += `
c.params = params.Decode(c.params)
`;
      }
      if (validator.query) {
        if (hasProperty("default", validator.query.schema))
          for (const [key, value] of Object.entries(import_value3.Value.Default(validator.query.schema, {}))) {
            const parsed = typeof value === "object" ? JSON.stringify(value) : `'${value}'`;
            if (parsed)
              fnLiteral += `c.query['${key}'] ??= ${parsed}
`;
          }
        fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")}
			}`;
        if (hasTransform(validator.query.schema))
          fnLiteral += `
c.query = query.Decode(Object.assign({}, c.query))
`;
      }
      if (validator.body) {
        if (hasProperty("default", validator.body.schema))
          fnLiteral += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(import_value3.Value.Default(validator.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${composeValidation("body")}
     			}
            }`;
        else
          fnLiteral += `if(body.Check(c.body) === false) {
			${composeValidation("body")}
		}`;
        if (hasTransform(validator.body.schema))
          fnLiteral += `
c.body = body.Decode(c.body)
`;
      }
      if (isNotEmpty(validator.cookie?.schema.properties ?? {})) {
        fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
        if (hasProperty("default", validator.cookie.schema))
          for (const [key, value] of Object.entries(import_value3.Value.Default(validator.cookie.schema, {}))) {
            fnLiteral += `cookieValue['${key}'] = ${typeof value === "object" ? JSON.stringify(value) : value}
`;
          }
        fnLiteral += `if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
        if (hasTransform(validator.cookie.schema))
          fnLiteral += `
c.cookie = params.Decode(c.cookie)
`;
      }
    }
    if (hooks?.beforeHandle) {
      const endBeforeHandle = report("beforeHandle", {
        unit: hooks.beforeHandle.length
      });
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        const beforeHandle = hooks.beforeHandle[i];
        const endUnit = report("beforeHandle.unit", {
          name: beforeHandle.name
        });
        const returning = hasReturn(beforeHandle.toString());
        if (beforeHandle.$elysia === "resolve") {
          fnLiteral += isAsync(beforeHandle) ? `Object.assign(c, await beforeHandle[${i}](c));` : `Object.assign(c, beforeHandle[${i}](c));`;
        } else if (!returning) {
          fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`;
          endUnit();
        } else {
          fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`;
          endUnit();
          fnLiteral += `if(be !== undefined) {
`;
          const endAfterHandle = report("afterHandle", {
            unit: hooks.transform.length
          });
          if (hooks.afterHandle) {
            report("handle", {
              name: isHandleFn ? handler.name : undefined
            })();
            for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
              const returning2 = hasReturn(hooks.afterHandle[i2].toString());
              const endUnit2 = report("afterHandle.unit", {
                name: hooks.afterHandle[i2].name
              });
              fnLiteral += `c.response = be
`;
              if (!returning2) {
                fnLiteral += isAsync(hooks.afterHandle[i2]) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
              } else {
                fnLiteral += isAsync(hooks.afterHandle[i2]) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
                fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
              }
              endUnit2();
            }
          }
          endAfterHandle();
          if (validator.response)
            fnLiteral += composeResponseValidation("be");
          if (hooks.mapResponse.length) {
            fnLiteral += `c.response = be`;
            for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
              fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i2}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`;
            }
          }
          fnLiteral += encodeCookie;
          fnLiteral += `return mapEarlyResponse(be, c.set)}
`;
        }
      }
      endBeforeHandle();
    }
    if (hooks?.afterHandle.length) {
      const endHandle = report("handle", {
        name: isHandleFn ? handler.name : undefined
      });
      if (hooks.afterHandle.length)
        fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
      else
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      const endAfterHandle = report("afterHandle", {
        unit: hooks.afterHandle.length
      });
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        const returning = hasReturn(hooks.afterHandle[i].toString());
        const endUnit = report("afterHandle.unit", {
          name: hooks.afterHandle[i].name
        });
        if (!returning) {
          fnLiteral += isAsync(hooks.afterHandle[i]) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`;
          endUnit();
        } else {
          fnLiteral += isAsync(hooks.afterHandle[i]) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`;
          endUnit();
          if (validator.response) {
            fnLiteral += `if(af !== undefined) {`;
            endAfterHandle();
            fnLiteral += composeResponseValidation("af");
            fnLiteral += `c.response = af }`;
          } else {
            fnLiteral += `if(af !== undefined) {`;
            endAfterHandle();
            fnLiteral += `c.response = af}
`;
          }
        }
      }
      endAfterHandle();
      fnLiteral += `r = c.response
`;
      if (validator.response)
        fnLiteral += composeResponseValidation();
      fnLiteral += encodeCookie;
      if (hooks.mapResponse.length) {
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
mr = onMapResponse[${i}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;
        }
      }
      if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(r)
`;
    } else {
      const endHandle = report("handle", {
        name: isHandleFn ? handler.name : undefined
      });
      if (validator.response || hooks.mapResponse.length) {
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
        endHandle();
        if (validator.response)
          fnLiteral += composeResponseValidation();
        report("afterHandle")();
        if (hooks.mapResponse.length) {
          fnLiteral += "c.response = r";
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            fnLiteral += `
if(mr === undefined) { 
						mr = onMapResponse[${i}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`;
          }
        }
        fnLiteral += encodeCookie;
        if (handler instanceof Response)
          fnLiteral += `return ${handle}.clone()
`;
        else if (hasSet)
          fnLiteral += `return mapResponse(r, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(r)
`;
      } else {
        if (traceConditions.handle || hasCookie) {
          fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
          endHandle();
          report("afterHandle")();
          if (hooks.mapResponse.length) {
            fnLiteral += "c.response = r";
            for (let i = 0;i < hooks.mapResponse.length; i++) {
              fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`;
            }
          }
          fnLiteral += encodeCookie;
          if (hasSet)
            fnLiteral += `return mapResponse(r, c.set)
`;
          else
            fnLiteral += `return mapCompactResponse(r)
`;
        } else {
          endHandle();
          const handled = isAsyncHandler ? `await ${handle}` : handle;
          report("afterHandle")();
          if (handler instanceof Response)
            fnLiteral += `return ${handle}.clone()
`;
          else if (hasSet)
            fnLiteral += `return mapResponse(${handled}, c.set)
`;
          else
            fnLiteral += `return mapCompactResponse(${handled})
`;
        }
      }
    }
    if (hasErrorHandler || handleResponse) {
      fnLiteral += `
} catch(error) {`;
      if (!maybeAsync)
        fnLiteral += `return (async () => {`;
      fnLiteral += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
      const endError = report("error", {
        unit: hooks.error.length
      });
      if (hooks.error.length) {
        fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
        for (let i = 0;i < hooks.error.length; i++) {
          const name = `er${i}`;
          const endUnit = report("error.unit", {
            name: hooks.error[i].name
          });
          fnLiteral += `
let ${name} = handleErrors[${i}](c)
`;
          if (isAsync(hooks.error[i]))
            fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}
`;
          endUnit();
          fnLiteral += `${name} = mapEarlyResponse(${name}, set)
`;
          fnLiteral += `if (${name}) {`;
          fnLiteral += `return ${name} }
`;
        }
      }
      endError();
      fnLiteral += `return handleError(c, error)

`;
      if (!maybeAsync)
        fnLiteral += "})()";
      fnLiteral += "}";
      if (handleResponse || hasTrace) {
        fnLiteral += ` finally { `;
        const endResponse = report("response", {
          unit: hooks.onResponse.length
        });
        fnLiteral += handleResponse;
        endResponse();
        fnLiteral += `}`;
      }
    }
    fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${schema && definitions ? "c.schema = schema; c.defs = definitions;" : ""}
		${fnLiteral}
	}`;
    const createHandler = Function("hooks", fnLiteral);
    return createHandler({
      handler,
      hooks,
      validator,
      handleError,
      utils: {
        mapResponse,
        mapCompactResponse,
        mapEarlyResponse,
        parseQuery: import_fast_querystring.parse
      },
      error: {
        NotFoundError,
        ValidationError,
        InternalServerError
      },
      schema,
      definitions,
      ERROR_CODE,
      getReporter,
      requestId,
      parseCookie,
      signCookie,
      decodeURIComponent: import_fast_decode_uri_component.default
    });
  };
  var composeGeneralHandler = (app) => {
    let decoratorsLiteral = "";
    let fnLiteral = "";
    for (const key of Object.keys(app.decorators))
      decoratorsLiteral += `,${key}: app.decorators.${key}`;
    const { router, staticRouter } = app;
    const hasTrace = app.event.trace.length > 0;
    const findDynamicRoute = `
	const route = router.find(request.method, path) ${router.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : app.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params

	return route.store(ctx)`;
    let switchMap = ``;
    for (const [path, { code, all }] of Object.entries(staticRouter.map))
      switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? `default: break map`}}

`;
    const maybeAsync = app.event.request.some(isAsync);
    fnLiteral += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request` : ""}
	${staticRouter.variables}
	${app.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${maybeAsync ? "async" : ""} function map(request) {
`;
    if (app.event.request.length)
      fnLiteral += `let re`;
    const traceLiteral = app.event.trace.map((x) => x.toString());
    const report = createReport({
      hasTrace,
      hasTraceSet: app.event.trace.some((fn) => {
        const literal = fn.toString();
        return isFnUse("set", literal) || isContextPassToFunction(literal);
      }),
      condition: {
        request: traceLiteral.some((x) => isFnUse("request", x) || isContextPassToFunction(x))
      },
      addFn: (word) => {
        fnLiteral += word;
      }
    });
    if (app.event.request.length) {
      fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys(app.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
      const endReport = report("request", {
        attribute: "ctx",
        unit: app.event.request.length
      });
      fnLiteral += `
 try {
`;
      for (let i = 0;i < app.event.request.length; i++) {
        const fn = app.event.request[i];
        const withReturn = hasReturn(fn.toString());
        const maybeAsync2 = isAsync(fn);
        const endUnit = report("request.unit", {
          name: app.event.request[i].name
        });
        if (withReturn) {
          fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set
				)
`;
          endUnit();
          if (withReturn)
            fnLiteral += `if(re !== undefined) return re
`;
        } else {
          fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`;
          endUnit();
        }
      }
      fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
      endReport();
      fnLiteral += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
    } else {
      fnLiteral += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${hasTrace ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys(app.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
      report("request", {
        unit: app.event.request.length,
        attribute: traceLiteral.some((x) => isFnUse("context", x)) || traceLiteral.some((x) => isFnUse("store", x)) || traceLiteral.some((x) => isFnUse("set", x)) ? "ctx" : ""
      })();
    }
    const wsPaths = app.wsPaths;
    const wsRouter = app.wsRouter;
    if (Object.keys(wsPaths).length || wsRouter.history.length) {
      fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
      for (const [path, index] of Object.entries(wsPaths)) {
        fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)

						break`;
      }
      fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
    }
    fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
    const handleError = composeErrorHandler(app);
    app.handleError = handleError;
    return Function("data", fnLiteral)({
      app,
      mapEarlyResponse,
      NotFoundError,
      getReporter: () => app.reporter,
      requestId,
      handleError
    });
  };
  var composeErrorHandler = (app) => {
    let fnLiteral = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${app.event.error.find(isAsync) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
    for (let i = 0;i < app.event.error.length; i++) {
      const handler = app.event.error[i];
      const response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)`;
      if (hasReturn(handler.toString()))
        fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}
`;
      else
        fnLiteral += response + `
`;
    }
    fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`;
    return Function("inject", fnLiteral)({
      app,
      mapResponse,
      ERROR_CODE,
      ELYSIA_RESPONSE
    });
  };
  var import_fast_querystring2 = require_lib();
  var createDynamicHandler = (app) => async (request) => {
    const set = {
      cookie: {},
      status: 200,
      headers: {}
    };
    let context;
    if (app.decorators) {
      context = app.decorators;
      context.request = request;
      context.set = set;
      context.store = app.store;
    } else {
      context = {
        set,
        store: app.store,
        request
      };
    }
    const url = request.url, s = url.indexOf("/", 11), q = url.indexOf("?", s + 1), path = q === -1 ? url.substring(s) : url.substring(s, q);
    try {
      for (let i = 0;i < app.event.request.length; i++) {
        const onRequest = app.event.request[i];
        let response2 = onRequest(context);
        if (response2 instanceof Promise)
          response2 = await response2;
        response2 = mapEarlyResponse(response2, set);
        if (response2)
          return response2;
      }
      const handler = app.dynamicRouter.find(request.method, path) ?? app.dynamicRouter.find("ALL", path);
      if (!handler)
        throw new NotFoundError;
      const { handle, hooks, validator, content } = handler.store;
      let body;
      if (request.method !== "GET" && request.method !== "HEAD") {
        if (content) {
          switch (content) {
            case "application/json":
              body = await request.json();
              break;
            case "text/plain":
              body = await request.text();
              break;
            case "application/x-www-form-urlencoded":
              body = (0, import_fast_querystring2.parse)(await request.text());
              break;
            case "application/octet-stream":
              body = await request.arrayBuffer();
              break;
            case "multipart/form-data":
              body = {};
              const form = await request.formData();
              for (const key of form.keys()) {
                if (body[key])
                  continue;
                const value = form.getAll(key);
                if (value.length === 1)
                  body[key] = value[0];
                else
                  body[key] = value;
              }
              break;
          }
        } else {
          let contentType = request.headers.get("content-type");
          if (contentType) {
            const index = contentType.indexOf(";");
            if (index !== -1)
              contentType = contentType.slice(0, index);
            for (let i = 0;i < hooks.parse.length; i++) {
              let temp = hooks.parse[i](context, contentType);
              if (temp instanceof Promise)
                temp = await temp;
              if (temp) {
                body = temp;
                break;
              }
            }
            if (body === undefined) {
              switch (contentType) {
                case "application/json":
                  body = await request.json();
                  break;
                case "text/plain":
                  body = await request.text();
                  break;
                case "application/x-www-form-urlencoded":
                  body = (0, import_fast_querystring2.parse)(await request.text());
                  break;
                case "application/octet-stream":
                  body = await request.arrayBuffer();
                  break;
                case "multipart/form-data":
                  body = {};
                  const form = await request.formData();
                  for (const key of form.keys()) {
                    if (body[key])
                      continue;
                    const value = form.getAll(key);
                    if (value.length === 1)
                      body[key] = value[0];
                    else
                      body[key] = value;
                  }
                  break;
              }
            }
          }
        }
      }
      context.body = body;
      context.params = handler?.params || undefined;
      context.query = q === -1 ? {} : (0, import_fast_querystring2.parse)(url.substring(q + 1));
      context.headers = {};
      for (const [key, value] of request.headers.entries())
        context.headers[key] = value;
      const cookieMeta = validator?.cookie?.schema;
      context.cookie = await parseCookie(context.set, context.headers.cookie, cookieMeta ? {
        secret: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
        sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
      } : undefined);
      for (let i = 0;i < hooks.transform.length; i++) {
        const operation = hooks.transform[i](context);
        if (hooks.transform[i].$elysia === "derive") {
          if (operation instanceof Promise)
            Object.assign(context, await operation);
          else
            Object.assign(context, operation);
        } else if (operation instanceof Promise)
          await operation;
      }
      if (validator) {
        if (validator.headers) {
          const _header = {};
          for (const key in request.headers)
            _header[key] = request.headers.get(key);
          if (validator.headers.Check(_header) === false)
            throw new ValidationError("header", validator.headers, _header);
        }
        if (validator.params?.Check(context.params) === false)
          throw new ValidationError("params", validator.params, context.params);
        if (validator.query?.Check(context.query) === false)
          throw new ValidationError("query", validator.query, context.query);
        if (validator.cookie) {
          const cookieValue = {};
          for (const [key, value] of Object.entries(context.cookie))
            cookieValue[key] = value.value;
          if (validator.cookie?.Check(cookieValue) === false)
            throw new ValidationError("cookie", validator.cookie, cookieValue);
        }
        if (validator.body?.Check(body) === false)
          throw new ValidationError("body", validator.body, body);
      }
      for (let i = 0;i < hooks.beforeHandle.length; i++) {
        let response2 = hooks.beforeHandle[i](context);
        if (response2 instanceof Promise)
          response2 = await response2;
        if (response2 !== undefined) {
          context.response = response2;
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let newResponse = hooks.afterHandle[i2](context);
            if (newResponse instanceof Promise)
              newResponse = await newResponse;
            if (newResponse)
              response2 = newResponse;
          }
          const result = mapEarlyResponse(response2, context.set);
          if (result)
            return result;
        }
      }
      let response = handle(context);
      if (response instanceof Promise)
        response = await response;
      if (!hooks.afterHandle.length) {
        const responseValidator = validator?.response?.[response.status];
        if (responseValidator?.Check(response) === false)
          throw new ValidationError("response", responseValidator, response);
      } else {
        context.response = response;
        for (let i = 0;i < hooks.afterHandle.length; i++) {
          let newResponse = hooks.afterHandle[i](context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          const result = mapEarlyResponse(newResponse, context.set);
          if (result !== undefined) {
            const responseValidator = validator?.response?.[response.status];
            if (responseValidator?.Check(result) === false)
              throw new ValidationError("response", responseValidator, result);
            return result;
          }
        }
      }
      if (context.set.cookie && cookieMeta?.sign) {
        const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
        if (cookieMeta.sign === true)
          for (const [key, cookie] of Object.entries(context.set.cookie))
            context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
        else
          for (const name of cookieMeta.sign) {
            if (!(name in cookieMeta.properties))
              continue;
            if (context.set.cookie[name]?.value) {
              context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
            }
          }
      }
      return mapResponse(response, context.set);
    } catch (error2) {
      if (error2.status)
        set.status = error2.status;
      return app.handleError(context, error2);
    } finally {
      for (const onResponse of app.event.onResponse)
        await onResponse(context);
    }
  };
  var createDynamicErrorHandler = (app) => async (context, error2) => {
    const errorContext = Object.assign(context, { error: error2, code: error2.code });
    errorContext.set = context.set;
    for (let i = 0;i < app.event.error.length; i++) {
      let response = app.event.error[i](errorContext);
      if (response instanceof Promise)
        response = await response;
      if (response !== undefined && response !== null)
        return mapResponse(response, context.set);
    }
    return new Response(typeof error2.cause === "string" ? error2.cause : error2.message, {
      headers: context.set.headers,
      status: error2.status ?? 500
    });
  };
  var import_system = require_system2();
  var import_typebox2 = require_cjs2();
  var import_value4 = require_value5();
  var import_system2 = require_system2();
  var import_compiler2 = require_compiler2();
  var t = Object.assign({}, import_typebox2.Type);
  try {
    import_system.TypeSystem.Format("email", (value) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(value));
    import_system.TypeSystem.Format("uuid", (value) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value));
    import_system.TypeSystem.Format("date", (value) => !Number.isNaN(new Date(value).getTime()));
    import_system.TypeSystem.Format("date-time", (value) => !Number.isNaN(new Date(value).getTime()));
  } catch {}
  var parseFileUnit = (size) => {
    if (typeof size === "string")
      switch (size.slice(-1)) {
        case "k":
          return +size.slice(0, size.length - 1) * 1024;
        case "m":
          return +size.slice(0, size.length - 1) * 1048576;
        default:
          return +size;
      }
    return size;
  };
  var validateFile = (options, value) => {
    if (!(value instanceof Blob))
      return false;
    if (options.minSize && value.size < parseFileUnit(options.minSize))
      return false;
    if (options.maxSize && value.size > parseFileUnit(options.maxSize))
      return false;
    if (options.extension)
      if (typeof options.extension === "string") {
        if (!value.type.startsWith(options.extension))
          return false;
      } else {
        for (let i = 0;i < options.extension.length; i++)
          if (value.type.startsWith(options.extension[i]))
            return true;
        return false;
      }
    return true;
  };
  var Files = import_system.TypeSystem.Type("Files", (options, value) => {
    if (!Array.isArray(value))
      return validateFile(options, value);
    if (options.minItems && value.length < options.minItems)
      return false;
    if (options.maxItems && value.length > options.maxItems)
      return false;
    for (let i = 0;i < value.length; i++)
      if (!validateFile(options, value[i]))
        return false;
    return true;
  });
  import_typebox2.FormatRegistry.Set("numeric", (value) => !!value && !isNaN(+value));
  import_typebox2.FormatRegistry.Set("boolean", (value) => value === "true" || value === "false");
  import_typebox2.FormatRegistry.Set("ObjectString", (value) => {
    let start = value.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      JSON.parse(value);
      return true;
    } catch {
      return false;
    }
  });
  var ElysiaType = {
    Numeric: (property) => {
      const schema = import_typebox2.Type.Number(property);
      return t.Transform(t.Union([
        t.String({
          format: "numeric",
          default: 0
        }),
        t.Number(property)
      ], property)).Decode((value) => {
        const number = +value;
        if (isNaN(number))
          return value;
        if (property && !import_value4.Value.Check(schema, number))
          throw new ValidationError("property", schema, number);
        return number;
      }).Encode((value) => value);
    },
    BooleanString: (property) => {
      const schema = import_typebox2.Type.Boolean(property);
      return t.Transform(t.Union([
        t.String({
          format: "boolean",
          default: false
        }),
        t.Boolean(property)
      ], property)).Decode((value) => {
        if (typeof value === "string")
          return value === "true";
        if (property && !import_value4.Value.Check(schema, value))
          throw new ValidationError("property", schema, value);
        return value;
      }).Encode((value) => value);
    },
    ObjectString: (properties, options) => t.Transform(t.Union([
      t.String({
        format: "ObjectString",
        default: ""
      }),
      t.Object(properties, options)
    ], options)).Decode((value) => {
      if (typeof value === "string")
        try {
          return JSON.parse(value);
        } catch {
          return value;
        }
      return value;
    }).Encode((value) => JSON.stringify(value)),
    File: import_system.TypeSystem.Type("File", validateFile),
    Files: (options = {}) => t.Transform(t.Union([Files(options)])).Decode((value) => {
      if (Array.isArray(value))
        return value;
      return [value];
    }).Encode((value) => value),
    Nullable: (schema) => t.Union([t.Null(), schema]),
    MaybeEmpty: (schema) => t.Union([t.Null(), t.Undefined(), schema]),
    Cookie: (properties, options) => t.Object(properties, options)
  };
  t.BooleanString = ElysiaType.BooleanString;
  t.ObjectString = ElysiaType.ObjectString;
  t.Numeric = ElysiaType.Numeric;
  t.File = (arg = {}) => ElysiaType.File({
    default: "File",
    ...arg,
    extension: arg?.type,
    type: "string",
    format: "binary"
  });
  t.Files = (arg = {}) => ElysiaType.Files({
    ...arg,
    elysiaMeta: "Files",
    default: "Files",
    extension: arg?.type,
    type: "array",
    items: {
      ...arg,
      default: "Files",
      type: "string",
      format: "binary"
    }
  });
  t.Nullable = (schema) => ElysiaType.Nullable(schema);
  t.MaybeEmpty = ElysiaType.MaybeEmpty;
  t.Cookie = ElysiaType.Cookie;
  var Elysia = class _Elysia {
    constructor(config) {
      this.dependencies = {};
      this.store = {};
      this.decorators = {};
      this.definitions = {
        type: {},
        error: {}
      };
      this.schema = {};
      this.macros = [];
      this.event = {
        start: [],
        request: [],
        parse: [],
        transform: [],
        beforeHandle: [],
        afterHandle: [],
        mapResponse: [],
        onResponse: [],
        trace: [],
        error: [],
        stop: []
      };
      this.reporter = new import_eventemitter3.default;
      this.server = null;
      this.validator = null;
      this.router = new import_memoirist.Memoirist;
      this.wsRouter = new import_memoirist.Memoirist;
      this.routes = [];
      this.staticRouter = {
        handlers: [],
        variables: "",
        map: {},
        all: ""
      };
      this.wsPaths = {};
      this.dynamicRouter = new import_memoirist.Memoirist;
      this.lazyLoadModules = [];
      this.path = "";
      this.stack = undefined;
      this.handle = async (request) => this.fetch(request);
      this.fetch = (request) => {
        if (false)
          ;
        return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
      };
      this.handleError = async (context, error2) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error2);
      this.outerErrorHandler = (error2) => new Response(error2.message || error2.name || "Error", {
        status: error2?.status ?? 500
      });
      this.listen = (options, callback) => {
        if (typeof Bun === "undefined")
          throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
        this.compile();
        if (typeof options === "string") {
          options = +options.trim();
          if (Number.isNaN(options))
            throw new Error("Port must be a numeric value");
        }
        const fetch = this.fetch;
        const serve = typeof options === "object" ? {
          development: !isProduction,
          reusePort: true,
          ...this.config.serve || {},
          ...options || {},
          websocket: {
            ...this.config.websocket || {},
            ...websocket || {}
          },
          fetch,
          error: this.outerErrorHandler
        } : {
          development: !isProduction,
          reusePort: true,
          ...this.config.serve || {},
          websocket: {
            ...this.config.websocket || {},
            ...websocket || {}
          },
          port: options,
          fetch,
          error: this.outerErrorHandler
        };
        this.server = Bun?.serve(serve);
        if (this.event.start.length)
          for (let i = 0;i < this.event.start.length; i++)
            this.event.start[i](this);
        if (callback)
          callback(this.server);
        process.on("beforeExit", () => {
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i](this);
        });
        Promise.all(this.lazyLoadModules).then(() => {
          Bun?.gc(false);
        });
        return this;
      };
      this.stop = async () => {
        if (!this.server)
          throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
        this.server.stop();
        if (this.event.stop.length)
          for (let i = 0;i < this.event.stop.length; i++)
            this.event.stop[i](this);
      };
      this.config = {
        forceErrorEncapsulation: true,
        prefix: "",
        aot: true,
        strictPath: false,
        scoped: false,
        cookie: {},
        analytic: false,
        ...config || {},
        seed: config?.seed === undefined ? "" : config?.seed
      };
      if (config?.analytic && (config?.name || config?.seed !== undefined))
        this.stack = new Error().stack;
    }
    getServer() {
      return this.server;
    }
    add(method, paths, handle, localHook, { allowMeta = false, skipPrefix = false } = {
      allowMeta: false,
      skipPrefix: false
    }) {
      if (typeof paths === "string")
        paths = [paths];
      for (let path of paths) {
        path = path === "" ? path : path.charCodeAt(0) === 47 ? path : `/${path}`;
        if (this.config.prefix && !skipPrefix && !this.config.scoped)
          path = this.config.prefix + path;
        if (localHook?.type)
          switch (localHook.type) {
            case "text":
              localHook.type = "text/plain";
              break;
            case "json":
              localHook.type = "application/json";
              break;
            case "formdata":
              localHook.type = "multipart/form-data";
              break;
            case "urlencoded":
              localHook.type = "application/x-www-form-urlencoded";
              break;
            case "arrayBuffer":
              localHook.type = "application/octet-stream";
              break;
            default:
              break;
          }
        const models = this.definitions.type;
        let cookieValidator = getSchemaValidator(localHook?.cookie ?? this.validator?.cookie, {
          dynamic: !this.config.aot,
          models,
          additionalProperties: true
        });
        if (isNotEmpty(this.config.cookie ?? {})) {
          if (cookieValidator) {
            cookieValidator.schema = mergeCookie(cookieValidator.schema, this.config.cookie ?? {});
          } else {
            cookieValidator = getSchemaValidator(t.Cookie({}, this.config.cookie), {
              dynamic: !this.config.aot,
              models,
              additionalProperties: true
            });
          }
        }
        const validator = {
          body: getSchemaValidator(localHook?.body ?? this.validator?.body, {
            dynamic: !this.config.aot,
            models
          }),
          headers: getSchemaValidator(localHook?.headers ?? this.validator?.headers, {
            dynamic: !this.config.aot,
            models,
            additionalProperties: true
          }),
          params: getSchemaValidator(localHook?.params ?? this.validator?.params, {
            dynamic: !this.config.aot,
            models
          }),
          query: getSchemaValidator(localHook?.query ?? this.validator?.query, {
            dynamic: !this.config.aot,
            models
          }),
          cookie: cookieValidator,
          response: getResponseSchemaValidator(localHook?.response ?? this.validator?.response, {
            dynamic: !this.config.aot,
            models
          })
        };
        const globalHook = this.event;
        const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
        if (this.macros.length) {
          const createManager = (stackName) => (type, fn) => {
            if (typeof type === "function" || Array.isArray(type)) {
              if (!localHook[stackName])
                localHook[stackName] = [];
              if (typeof localHook[stackName] === "function")
                localHook[stackName] = [localHook[stackName]];
              if (Array.isArray(type))
                localHook[stackName] = localHook[stackName].concat(type);
              else
                localHook[stackName].push(type);
              return;
            }
            const { insert = "after", stack = "local" } = type;
            if (stack === "global") {
              if (!Array.isArray(fn)) {
                if (insert === "before") {
                  globalHook[stackName].unshift(fn);
                } else {
                  globalHook[stackName].push(fn);
                }
              } else {
                if (insert === "before") {
                  globalHook[stackName] = fn.concat(globalHook[stackName]);
                } else {
                  globalHook[stackName] = globalHook[stackName].concat(fn);
                }
              }
              return;
            } else {
              if (!localHook[stackName])
                localHook[stackName] = [];
              if (typeof localHook[stackName] === "function")
                localHook[stackName] = [localHook[stackName]];
              if (!Array.isArray(fn)) {
                if (insert === "before") {
                  localHook[stackName].unshift(fn);
                } else {
                  localHook[stackName].push(fn);
                }
              } else {
                if (insert === "before") {
                  localHook[stackName] = fn.concat(localHook[stackName]);
                } else {
                  localHook[stackName] = localHook[stackName].concat(fn);
                }
              }
              return;
            }
          };
          const manager = {
            events: {
              global: globalHook,
              local: localHook
            },
            onParse: createManager("parse"),
            onTransform: createManager("transform"),
            onBeforeHandle: createManager("beforeHandle"),
            onAfterHandle: createManager("afterHandle"),
            onResponse: createManager("onResponse"),
            onError: createManager("error")
          };
          for (const macro of this.macros)
            traceBackMacro(macro(manager), localHook);
        }
        const hooks = mergeHook(globalHook, localHook);
        const isFn = typeof handle === "function";
        if (this.config.aot === false) {
          this.dynamicRouter.add(method, path, {
            validator,
            hooks,
            content: localHook?.type,
            handle
          });
          if (this.config.strictPath === false) {
            this.dynamicRouter.add(method, loosePath, {
              validator,
              hooks,
              content: localHook?.type,
              handle
            });
          }
          this.routes.push({
            method,
            path,
            composed: null,
            handler: handle,
            hooks
          });
          return;
        }
        const mainHandler = composeHandler({
          path,
          method,
          hooks,
          validator,
          handler: handle,
          handleError: this.handleError,
          onRequest: this.event.request,
          config: this.config,
          definitions: allowMeta ? this.definitions.type : undefined,
          schema: allowMeta ? this.schema : undefined,
          getReporter: () => this.reporter,
          setHeader: this.setHeaders
        });
        if (!isFn) {
          const context = Object.assign({
            headers: {},
            query: {},
            params: {},
            body: undefined,
            request: new Request(`http://localhost${path}`),
            store: this.store,
            path,
            set: {
              headers: this.setHeaders ?? {},
              status: 200
            }
          }, this.decorators);
          let response;
          for (const onRequest of Object.values(hooks.request)) {
            try {
              const inner = mapEarlyResponse(onRequest(context), context.set);
              if (inner !== undefined) {
                response = inner;
                break;
              }
            } catch (error2) {
              response = this.handleError(context, error2);
              break;
            }
          }
          if (response)
            mainHandler.response = response;
          else {
            try {
              mainHandler.response = mainHandler(context);
            } catch (error2) {
              mainHandler.response = this.handleError(context, error2);
            }
          }
        }
        const existingRouteIndex = this.routes.findIndex((route) => route.path === path && route.method === method);
        if (existingRouteIndex !== -1) {
          this.routes.splice(existingRouteIndex, 1);
        }
        this.routes.push({
          method,
          path,
          composed: mainHandler,
          handler: handle,
          hooks
        });
        if (method === "$INTERNALWS") {
          const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
          if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
            const index = this.staticRouter.handlers.length;
            this.staticRouter.handlers.push(mainHandler);
            if (mainHandler.response instanceof Response)
              this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response
`;
            else
              this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
            this.wsPaths[path] = index;
            if (loose)
              this.wsPaths[loose] = index;
          } else {
            this.wsRouter.add("ws", path, mainHandler);
            if (loose)
              this.wsRouter.add("ws", loose, mainHandler);
          }
          return;
        }
        if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
          const index = this.staticRouter.handlers.length;
          this.staticRouter.handlers.push(mainHandler);
          if (mainHandler.response instanceof Response)
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response
`;
          else
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
          if (!this.staticRouter.map[path])
            this.staticRouter.map[path] = {
              code: ""
            };
          if (method === "ALL")
            this.staticRouter.map[path].all = `default: return st${index}(ctx)
`;
          else {
            if (mainHandler.response instanceof Response)
              this.staticRouter.map[path].code = `case '${method}': return st${index}.clone()
${this.staticRouter.map[path].code}`;
            else
              this.staticRouter.map[path].code = `case '${method}': return st${index}(ctx)
${this.staticRouter.map[path].code}`;
          }
          if (!this.config.strictPath) {
            if (!this.staticRouter.map[loosePath])
              this.staticRouter.map[loosePath] = {
                code: ""
              };
            if (method === "ALL")
              this.staticRouter.map[loosePath].all = `default: return st${index}(ctx)
`;
            else {
              if (mainHandler.response instanceof Response)
                this.staticRouter.map[loosePath].code = `case '${method}': return st${index}.clone()
${this.staticRouter.map[loosePath].code}`;
              else
                this.staticRouter.map[loosePath].code = `case '${method}': return st${index}(ctx)
${this.staticRouter.map[loosePath].code}`;
            }
          }
        } else {
          this.router.add(method, path, mainHandler);
          if (!this.config.strictPath)
            this.router.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
        }
      }
    }
    headers(header) {
      if (!header)
        return this;
      if (!this.setHeaders)
        this.setHeaders = {};
      this.setHeaders = mergeDeep(this.setHeaders, header);
      return this;
    }
    onStart(handler) {
      this.on("start", handler);
      return this;
    }
    onRequest(handler) {
      this.on("request", handler);
      return this;
    }
    onParse(parser) {
      this.on("parse", parser);
      return this;
    }
    onTransform(handler) {
      this.on("transform", handler);
      return this;
    }
    resolve(resolver2) {
      resolver2.$elysia = "resolve";
      return this.onBeforeHandle(resolver2);
    }
    onBeforeHandle(handler) {
      this.on("beforeHandle", handler);
      return this;
    }
    onAfterHandle(handler) {
      this.on("afterHandle", handler);
      return this;
    }
    mapResponse(handler) {
      this.on("mapResponse", handler);
      return this;
    }
    onResponse(handler) {
      this.on("response", handler);
      return this;
    }
    trace(handler) {
      this.reporter.on("event", createTraceListener(() => this.reporter, this.event.trace.length, handler));
      this.on("trace", handler);
      return this;
    }
    error(name, error2) {
      switch (typeof name) {
        case "string":
          error2.prototype[ERROR_CODE] = name;
          this.definitions.error[name] = error2;
          return this;
        case "function":
          this.definitions.error = name(this.definitions.error);
          return this;
      }
      for (const [code, error3] of Object.entries(name)) {
        error3.prototype[ERROR_CODE] = code;
        this.definitions.error[code] = error3;
      }
      return this;
    }
    onError(handler) {
      this.on("error", handler);
      return this;
    }
    onStop(handler) {
      this.on("stop", handler);
      return this;
    }
    on(type, handlers) {
      for (let handler of Array.isArray(handlers) ? handlers : [handlers]) {
        handler = asGlobal(handler);
        switch (type) {
          case "start":
            this.event.start.push(handler);
            break;
          case "request":
            this.event.request.push(handler);
            break;
          case "parse":
            this.event.parse.splice(this.event.parse.length - 1, 0, handler);
            break;
          case "transform":
            this.event.transform.push(handler);
            break;
          case "beforeHandle":
            this.event.beforeHandle.push(handler);
            break;
          case "afterHandle":
            this.event.afterHandle.push(handler);
            break;
          case "mapResponse":
            this.event.mapResponse.push(handler);
            break;
          case "response":
            this.event.onResponse.push(handler);
            break;
          case "trace":
            this.event.trace.push(handler);
            break;
          case "error":
            this.event.error.push(handler);
            break;
          case "stop":
            this.event.stop.push(handler);
            break;
        }
      }
      return this;
    }
    group(prefix, schemaOrRun, run) {
      const instance = new _Elysia({
        ...this.config || {},
        prefix: ""
      });
      instance.store = this.store;
      instance.definitions = this.definitions;
      instance.getServer = () => this.server;
      const isSchema = typeof schemaOrRun === "object";
      const sandbox = (isSchema ? run : schemaOrRun)(instance);
      this.decorators = mergeDeep(this.decorators, instance.decorators);
      if (sandbox.event.request.length)
        this.event.request = [
          ...this.event.request || [],
          ...sandbox.event.request || []
        ];
      if (sandbox.event.onResponse.length)
        this.event.onResponse = [
          ...this.event.onResponse || [],
          ...sandbox.event.onResponse || []
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.routes).forEach(({ method, path, handler, hooks }) => {
        path = (isSchema ? "" : this.config.prefix) + prefix + path;
        if (isSchema) {
          const hook = schemaOrRun;
          const localHook = hooks;
          this.add(method, path, handler, mergeHook(hook, {
            ...localHook || {},
            error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
              ...localHook.error || {},
              ...sandbox.event.error || {}
            ] : [
              localHook.error,
              ...sandbox.event.error || {}
            ]
          }));
        } else {
          this.add(method, path, handler, mergeHook(hooks, {
            error: sandbox.event.error
          }), {
            skipPrefix: true
          });
        }
      });
      return this;
    }
    guard(hook, run) {
      if (!run) {
        this.event = mergeLifeCycle(this.event, hook);
        this.validator = {
          body: hook.body,
          headers: hook.headers,
          params: hook.params,
          query: hook.query,
          response: hook.response
        };
        return this;
      }
      const instance = new _Elysia({
        ...this.config || {},
        prefix: ""
      });
      instance.store = this.store;
      instance.definitions = this.definitions;
      const sandbox = run(instance);
      this.decorators = mergeDeep(this.decorators, instance.decorators);
      if (sandbox.event.request.length)
        this.event.request = [
          ...this.event.request || [],
          ...sandbox.event.request || []
        ];
      if (sandbox.event.onResponse.length)
        this.event.onResponse = [
          ...this.event.onResponse || [],
          ...sandbox.event.onResponse || []
        ];
      this.model(sandbox.definitions.type);
      Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
        this.add(method, path, handler, mergeHook(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || []
          ] : [localHook.error, ...sandbox.event.error || []]
        }));
      });
      return this;
    }
    use(plugin) {
      if (plugin instanceof Promise) {
        this.lazyLoadModules.push(plugin.then((plugin2) => {
          if (typeof plugin2 === "function") {
            return plugin2(this);
          }
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile()));
        return this;
      } else
        return this._use(plugin);
      return this;
    }
    _use(plugin) {
      if (typeof plugin === "function") {
        const instance = plugin(this);
        if (instance instanceof Promise) {
          this.lazyLoadModules.push(instance.then((plugin2) => {
            if (plugin2 instanceof _Elysia) {
              this.compile();
              for (const {
                method,
                path,
                handler,
                hooks
              } of Object.values(plugin2.routes)) {
                this.add(method, path, handler, mergeHook(hooks, {
                  error: plugin2.event.error
                }));
              }
              return plugin2;
            }
            if (typeof plugin2 === "function")
              return plugin2(this);
            if (typeof plugin2.default === "function")
              return plugin2.default(this);
            return this._use(plugin2);
          }).then((x) => x.compile()));
          return this;
        }
        return instance;
      }
      const { name, seed } = plugin.config;
      plugin.getServer = () => this.getServer();
      this.headers(plugin.setHeaders);
      const isScoped = plugin.config.scoped;
      if (isScoped) {
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
          if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
            return this;
          this.dependencies[name].push(!this.config?.analytic ? {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies
          } : {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies,
            stack: plugin.stack,
            routes: plugin.routes,
            decorators: plugin.decorators,
            store: plugin.store,
            type: plugin.definitions.type,
            error: plugin.definitions.error,
            derive: plugin.event.transform.filter((x) => x.$elysia === "derive").map((x) => ({
              fn: x.toString(),
              stack: new Error().stack ?? ""
            })),
            resolve: plugin.event.transform.filter((x) => x.$elysia === "derive").map((x) => ({
              fn: x.toString(),
              stack: new Error().stack ?? ""
            }))
          });
        }
        plugin.model(this.definitions.type);
        plugin.error(this.definitions.error);
        plugin.macros = [...this.macros || [], ...plugin.macros || []];
        plugin.onRequest((context) => {
          Object.assign(context, this.decorators);
          Object.assign(context.store, this.store);
        });
        if (plugin.event.trace.length)
          plugin.event.trace.push(...plugin.event.trace);
        if (isScoped && !plugin.config.prefix)
          console.warn("When using scoped plugins it is recommended to use a prefix, else routing may not work correctly for the second scoped instance");
        if (plugin.event.error.length)
          plugin.event.error.push(...this.event.error);
        if (plugin.config.aot)
          plugin.compile();
        let instance;
        if (isScoped && plugin.config.prefix) {
          instance = this.mount(plugin.config.prefix + "/", plugin.fetch);
          for (const route of plugin.routes)
            this.routes.push({
              ...route,
              path: `${plugin.config.prefix}${route.path}`,
              hooks: mergeHook(route.hooks, {
                error: this.event.error
              })
            });
        } else {
          instance = this.mount(plugin.fetch);
          if (instance.routes.length)
            this.routes.push(...instance.routes);
        }
        return this;
      } else {
        plugin.reporter = this.reporter;
        for (const trace of plugin.event.trace)
          this.trace(trace);
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
          if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
            this.macros.push(...plugin.macros || []);
          const macroHashes = [];
          for (let i = 0;i < this.macros.length; i++) {
            const macro = this.macros[i];
            if (macroHashes.includes(macro.$elysiaChecksum)) {
              this.macros.splice(i, 1);
              i--;
            }
            macroHashes.push(macro.$elysiaChecksum);
          }
        }
      }
      this.decorate(plugin.decorators);
      this.state(plugin.store);
      this.model(plugin.definitions.type);
      this.error(plugin.definitions.error);
      for (const { method, path, handler, hooks } of Object.values(plugin.routes)) {
        this.add(method, path, handler, mergeHook(hooks, {
          error: plugin.event.error
        }));
      }
      if (!isScoped)
        if (name) {
          if (!(name in this.dependencies))
            this.dependencies[name] = [];
          const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
          if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
            return this;
          this.dependencies[name].push(!this.config?.analytic ? {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies
          } : {
            name: plugin.config.name,
            seed: plugin.config.seed,
            checksum: current,
            dependencies: plugin.dependencies,
            stack: plugin.stack,
            routes: plugin.routes,
            decorators: plugin.decorators,
            store: plugin.store,
            type: plugin.definitions.type,
            error: plugin.definitions.error,
            derive: plugin.event.transform.filter((x) => x?.$elysia === "derive").map((x) => ({
              fn: x.toString(),
              stack: new Error().stack ?? ""
            })),
            resolve: plugin.event.transform.filter((x) => x?.$elysia === "resolve").map((x) => ({
              fn: x.toString(),
              stack: new Error().stack ?? ""
            }))
          });
          this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
        } else {
          this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
        }
      return this;
    }
    macro(macro) {
      macro.$elysiaChecksum = checksum(JSON.stringify({
        name: this.config.name,
        seed: this.config.seed,
        content: macro.toString()
      }));
      this.macros.push(macro);
      return this;
    }
    mount(path, handle) {
      if (path instanceof _Elysia || typeof path === "function" || path.length === 0 || path === "/") {
        const run = typeof path === "function" ? path : path instanceof _Elysia ? path.compile().fetch : handle instanceof _Elysia ? handle.compile().fetch : handle;
        const handler2 = async ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
        this.all("/", handler2, {
          type: "none"
        });
        this.all("/*", handler2, {
          type: "none"
        });
        return this;
      }
      const length = path.length;
      if (handle instanceof _Elysia)
        handle = handle.compile().fetch;
      const handler = async ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
      this.all(path, handler, {
        type: "none"
      });
      this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
        type: "none"
      });
      return this;
    }
    get(path, handler, hook) {
      this.add("GET", path, handler, hook);
      return this;
    }
    post(path, handler, hook) {
      this.add("POST", path, handler, hook);
      return this;
    }
    put(path, handler, hook) {
      this.add("PUT", path, handler, hook);
      return this;
    }
    patch(path, handler, hook) {
      this.add("PATCH", path, handler, hook);
      return this;
    }
    delete(path, handler, hook) {
      this.add("DELETE", path, handler, hook);
      return this;
    }
    options(path, handler, hook) {
      this.add("OPTIONS", path, handler, hook);
      return this;
    }
    all(path, handler, hook) {
      this.add("ALL", path, handler, hook);
      return this;
    }
    head(path, handler, hook) {
      this.add("HEAD", path, handler, hook);
      return this;
    }
    connect(path, handler, hook) {
      this.add("CONNECT", path, handler, hook);
      return this;
    }
    ws(path, options) {
      const transform = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
      let server = null;
      const validateMessage = getSchemaValidator(options?.body, {
        models: this.definitions.type
      });
      const validateResponse = getSchemaValidator(options?.response, {
        models: this.definitions.type
      });
      const parseMessage = (message) => {
        if (typeof message === "string") {
          const start = message?.charCodeAt(0);
          if (start === 47 || start === 123)
            try {
              message = JSON.parse(message);
            } catch {}
          else if (isNumericString(message))
            message = +message;
        }
        if (transform?.length)
          for (let i = 0;i < transform.length; i++) {
            const temp = transform[i](message);
            if (temp !== undefined)
              message = temp;
          }
        return message;
      };
      this.route("$INTERNALWS", path, (context) => {
        const { set, path: path2, qi, headers, query, params } = context;
        if (server === null)
          server = this.getServer();
        if (server?.upgrade(context.request, {
          headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
          data: {
            validator: validateResponse,
            open(ws) {
              options.open?.(new ElysiaWS(ws, context));
            },
            message: (ws, msg) => {
              const message = parseMessage(msg);
              if (validateMessage?.Check(message) === false)
                return void ws.send(new ValidationError("message", validateMessage, message).message);
              options.message?.(new ElysiaWS(ws, context), message);
            },
            drain(ws) {
              options.drain?.(new ElysiaWS(ws, context));
            },
            close(ws, code, reason) {
              options.close?.(new ElysiaWS(ws, context), code, reason);
            }
          }
        }))
          return;
        set.status = 400;
        return "Expected a websocket connection";
      }, {
        beforeHandle: options.beforeHandle,
        transform: options.transform,
        headers: options.headers,
        params: options.params,
        query: options.query
      });
      return this;
    }
    route(method, path, handler, {
      config,
      ...hook
    } = {
      config: {
        allowMeta: false
      }
    }) {
      this.add(method, path, handler, hook, config);
      return this;
    }
    state(name, value) {
      switch (typeof name) {
        case "object":
          this.store = mergeDeep(this.store, name);
          return this;
        case "function":
          this.store = name(this.store);
          return this;
      }
      if (!(name in this.store)) {
        this.store[name] = value;
      }
      return this;
    }
    decorate(name, value) {
      switch (typeof name) {
        case "object":
          this.decorators = mergeDeep(this.decorators, name);
          return this;
        case "function":
          this.decorators = name(this.decorators);
          return this;
      }
      if (!(name in this.decorators))
        this.decorators[name] = value;
      return this;
    }
    derive(transform) {
      transform.$elysia = "derive";
      return this.onTransform(transform);
    }
    model(name, model) {
      switch (typeof name) {
        case "object":
          Object.entries(name).forEach(([key, value]) => {
            if (!(key in this.definitions.type))
              this.definitions.type[key] = value;
          });
          return this;
        case "function":
          this.definitions.type = name(this.definitions.type);
          return this;
      }
      this.definitions.type[name] = model;
      return this;
    }
    mapDerive(mapper) {
      mapper.$elysia = "derive";
      return this.onTransform(mapper);
    }
    affix(base, type, word) {
      if (word === "")
        return this;
      const delimieter = ["_", "-", " "];
      const capitalize = (word2) => word2[0].toUpperCase() + word2.slice(1);
      const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize(suffix);
      const remap = (type2) => {
        const store = {};
        switch (type2) {
          case "decorator":
            for (const key in this.decorators)
              store[joinKey(word, key)] = this.decorators[key];
            this.decorators = store;
            break;
          case "state":
            for (const key in this.store)
              store[joinKey(word, key)] = this.store[key];
            this.store = store;
            break;
          case "model":
            for (const key in this.definitions.type)
              store[joinKey(word, key)] = this.definitions.type[key];
            this.definitions.type = store;
            break;
          case "error":
            for (const key in this.definitions.error)
              store[joinKey(word, key)] = this.definitions.error[key];
            this.definitions.error = store;
            break;
        }
      };
      const types = Array.isArray(type) ? type : [type];
      for (const type2 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
        remap(type2);
      return this;
    }
    prefix(type, word) {
      return this.affix("prefix", type, word);
    }
    suffix(type, word) {
      return this.affix("suffix", type, word);
    }
    compile() {
      this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
      if (typeof this.server?.reload === "function")
        this.server.reload({
          ...this.server || {},
          fetch: this.fetch
        });
      return this;
    }
    get modules() {
      return Promise.all(this.lazyLoadModules);
    }
  };
});

// node_modules/@elysiajs/cors/dist/cjs/index.js
var require_cjs4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cors = undefined;
  var elysia_1 = require_cjs3();
  var cors = (config = {
    origin: true,
    methods: "*",
    allowedHeaders: "*",
    exposedHeaders: "*",
    credentials: false,
    maxAge: 5,
    preflight: true
  }) => {
    const { origin = true, methods = "*", allowedHeaders = "*", exposedHeaders = "*", credentials = false, maxAge = 5, preflight = true } = config;
    const app = new elysia_1.Elysia({
      name: "@elysiajs/cors",
      seed: config
    });
    const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
    const processOrigin = (origin2, request, from) => {
      switch (typeof origin2) {
        case "string":
          const protocolStart = from.indexOf("://");
          if (protocolStart === -1)
            return false;
          return origin2 === from.slice(protocolStart + 3);
        case "function":
          return origin2(request);
        case "object":
          return origin2.test(from);
      }
    };
    const handleOrigin = (set, request) => {
      if (origin === true) {
        set.headers["Vary"] = "*";
        set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
        return;
      }
      if (!origins?.length)
        return;
      const headers = [];
      if (origins.length) {
        const from = request.headers.get("Origin") ?? "";
        for (let i = 0;i < origins.length; i++) {
          const value = processOrigin(origins[i], request, from);
          if (value === true) {
            set.headers["Vary"] = origin ? "Origin" : "*";
            set.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
            return;
          }
          if (value)
            headers.push(value);
        }
      }
      set.headers["Vary"] = "Origin";
      set.headers["Access-Control-Allow-Origin"] = headers.join(", ");
    };
    const handleMethod = (set) => {
      if (!methods?.length)
        return;
      if (methods === "*")
        return set.headers["Access-Control-Allow-Methods"] = "*";
      if (!Array.isArray(methods))
        return set.headers["Access-Control-Allow-Methods"] = methods;
      set.headers["Access-Control-Allow-Methods"] = methods.join(", ");
    };
    if (preflight)
      app.options("/", ({ set, request }) => {
        handleOrigin(set, request);
        handleMethod(set);
        if (exposedHeaders.length)
          set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
        if (maxAge)
          set.headers["Access-Control-Max-Age"] = maxAge.toString();
        return new Response("", {
          status: 204
        });
      }).options("/*", ({ set, request }) => {
        handleOrigin(set, request);
        handleMethod(set);
        if (exposedHeaders.length)
          set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
        if (maxAge)
          set.headers["Access-Control-Max-Age"] = maxAge.toString();
        return new Response("", {
          status: 204
        });
      });
    return app.onRequest(({ set, request }) => {
      handleOrigin(set, request);
      handleMethod(set);
      if (allowedHeaders.length)
        set.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (exposedHeaders.length)
        set.headers["Access-Control-Exposed-Headers"] = typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ");
      if (credentials)
        set.headers["Access-Control-Allow-Credentials"] = "true";
    });
  };
  exports.cors = cors;
  exports.default = exports.cors;
});

// node_modules/croner/dist/croner.min.cjs
var require_croner_min = __commonJS((exports, module) => {
  function minitz(y, m, d, h, i, s, tz, throwOnInvalid) {
    return minitz.fromTZ(minitz.tp(y, m, d, h, i, s, tz), throwOnInvalid);
  }
  minitz.fromTZISO = (localTimeStr, tz, throwOnInvalid) => {
    return minitz.fromTZ(parseISOLocal(localTimeStr, tz), throwOnInvalid);
  };
  minitz.fromTZ = function(tp, throwOnInvalid) {
    const inDate = new Date(Date.UTC(tp.y, tp.m - 1, tp.d, tp.h, tp.i, tp.s)), offset = getTimezoneOffset(tp.tz, inDate), dateGuess = new Date(inDate.getTime() - offset), dateOffsGuess = getTimezoneOffset(tp.tz, dateGuess);
    if (dateOffsGuess - offset === 0) {
      return dateGuess;
    } else {
      const dateGuess2 = new Date(inDate.getTime() - dateOffsGuess), dateOffsGuess2 = getTimezoneOffset(tp.tz, dateGuess2);
      if (dateOffsGuess2 - dateOffsGuess === 0) {
        return dateGuess2;
      } else if (!throwOnInvalid && dateOffsGuess2 - dateOffsGuess > 0) {
        return dateGuess2;
      } else if (!throwOnInvalid) {
        return dateGuess;
      } else {
        throw new Error("Invalid date passed to fromTZ()");
      }
    }
  };
  minitz.toTZ = function(d, tzStr) {
    const localDateString = d.toLocaleString("en-US", { timeZone: tzStr }).replace(/[\u202f]/, " ");
    const td = new Date(localDateString);
    return { y: td.getFullYear(), m: td.getMonth() + 1, d: td.getDate(), h: td.getHours(), i: td.getMinutes(), s: td.getSeconds(), tz: tzStr };
  };
  minitz.tp = (y, m, d, h, i, s, tz) => {
    return { y, m, d, h, i, s, tz };
  };
  function getTimezoneOffset(timeZone, date = new Date) {
    const tz = date.toLocaleString("en-US", { timeZone, timeZoneName: "short" }).split(" ").slice(-1)[0];
    const dateString = date.toLocaleString("en-US").replace(/[\u202f]/, " ");
    return Date.parse(`${dateString} GMT`) - Date.parse(`${dateString} ${tz}`);
  }
  function parseISOLocal(dtStr, tz) {
    const pd = new Date(Date.parse(dtStr));
    if (isNaN(pd)) {
      throw new Error("minitz: Invalid ISO8601 passed to parser.");
    }
    const stringEnd = dtStr.substring(9);
    if (dtStr.includes("Z") || stringEnd.includes("-") || stringEnd.includes("+")) {
      return minitz.tp(pd.getUTCFullYear(), pd.getUTCMonth() + 1, pd.getUTCDate(), pd.getUTCHours(), pd.getUTCMinutes(), pd.getUTCSeconds(), "Etc/UTC");
    } else {
      return minitz.tp(pd.getFullYear(), pd.getMonth() + 1, pd.getDate(), pd.getHours(), pd.getMinutes(), pd.getSeconds(), tz);
    }
  }
  minitz.minitz = minitz;
  function CronOptions(options) {
    if (options === undefined) {
      options = {};
    }
    delete options.name;
    options.legacyMode = options.legacyMode === undefined ? true : options.legacyMode;
    options.paused = options.paused === undefined ? false : options.paused;
    options.maxRuns = options.maxRuns === undefined ? Infinity : options.maxRuns;
    options.catch = options.catch === undefined ? false : options.catch;
    options.interval = options.interval === undefined ? 0 : parseInt(options.interval, 10);
    options.utcOffset = options.utcOffset === undefined ? undefined : parseInt(options.utcOffset, 10);
    options.unref = options.unref === undefined ? false : options.unref;
    if (options.startAt) {
      options.startAt = new CronDate(options.startAt, options.timezone);
    }
    if (options.stopAt) {
      options.stopAt = new CronDate(options.stopAt, options.timezone);
    }
    if (options.interval !== null) {
      if (isNaN(options.interval)) {
        throw new Error("CronOptions: Supplied value for interval is not a number");
      } else if (options.interval < 0) {
        throw new Error("CronOptions: Supplied value for interval can not be negative");
      }
    }
    if (options.utcOffset !== undefined) {
      if (isNaN(options.utcOffset)) {
        throw new Error("CronOptions: Invalid value passed for utcOffset, should be number representing minutes offset from UTC.");
      } else if (options.utcOffset < -870 || options.utcOffset > 870) {
        throw new Error("CronOptions: utcOffset out of bounds.");
      }
      if (options.utcOffset !== undefined && options.timezone) {
        throw new Error("CronOptions: Combining 'utcOffset' with 'timezone' is not allowed.");
      }
    }
    if (options.unref !== true && options.unref !== false) {
      throw new Error("CronOptions: Unref should be either true, false or undefined(false).");
    }
    return options;
  }
  var DaysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var RecursionSteps = [["month", "year", 0], ["day", "month", -1], ["hour", "day", 0], ["minute", "hour", 0], ["second", "minute", 0]];
  function CronDate(d, tz) {
    this.tz = tz;
    if (d && d instanceof Date) {
      if (!isNaN(d)) {
        this.fromDate(d);
      } else {
        throw new TypeError("CronDate: Invalid date passed to CronDate constructor");
      }
    } else if (d === undefined) {
      this.fromDate(new Date);
    } else if (d && typeof d === "string") {
      this.fromString(d);
    } else if (d instanceof CronDate) {
      this.fromCronDate(d);
    } else {
      throw new TypeError("CronDate: Invalid type (" + typeof d + ") passed to CronDate constructor");
    }
  }
  CronDate.prototype.fromDate = function(inDate) {
    if (this.tz !== undefined) {
      if (typeof this.tz === "number") {
        this.ms = inDate.getUTCMilliseconds();
        this.second = inDate.getUTCSeconds();
        this.minute = inDate.getUTCMinutes() + this.tz;
        this.hour = inDate.getUTCHours();
        this.day = inDate.getUTCDate();
        this.month = inDate.getUTCMonth();
        this.year = inDate.getUTCFullYear();
        this.apply();
      } else {
        const d = minitz.toTZ(inDate, this.tz);
        this.ms = inDate.getMilliseconds();
        this.second = d.s;
        this.minute = d.i;
        this.hour = d.h;
        this.day = d.d;
        this.month = d.m - 1;
        this.year = d.y;
      }
    } else {
      this.ms = inDate.getMilliseconds();
      this.second = inDate.getSeconds();
      this.minute = inDate.getMinutes();
      this.hour = inDate.getHours();
      this.day = inDate.getDate();
      this.month = inDate.getMonth();
      this.year = inDate.getFullYear();
    }
  };
  CronDate.prototype.fromCronDate = function(d) {
    this.tz = d.tz;
    this.year = d.year;
    this.month = d.month;
    this.day = d.day;
    this.hour = d.hour;
    this.minute = d.minute;
    this.second = d.second;
    this.ms = d.ms;
  };
  CronDate.prototype.apply = function() {
    if (this.month > 11 || this.day > DaysOfMonth[this.month] || this.hour > 59 || this.minute > 59 || this.second > 59 || this.hour < 0 || this.minute < 0 || this.second < 0) {
      const d = new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms));
      this.ms = d.getUTCMilliseconds();
      this.second = d.getUTCSeconds();
      this.minute = d.getUTCMinutes();
      this.hour = d.getUTCHours();
      this.day = d.getUTCDate();
      this.month = d.getUTCMonth();
      this.year = d.getUTCFullYear();
      return true;
    } else {
      return false;
    }
  };
  CronDate.prototype.fromString = function(str) {
    return this.fromDate(minitz.fromTZISO(str, this.tz));
  };
  CronDate.prototype.findNext = function(options, target, pattern, offset) {
    const originalTarget = this[target];
    let lastDayOfMonth;
    if (pattern.lastDayOfMonth || pattern.lastWeekdayOfMonth) {
      if (this.month !== 1) {
        lastDayOfMonth = DaysOfMonth[this.month];
      } else {
        lastDayOfMonth = new Date(Date.UTC(this.year, this.month + 1, 0, 0, 0, 0, 0)).getUTCDate();
      }
    }
    const fDomWeekDay = !pattern.starDOW && target == "day" ? new Date(Date.UTC(this.year, this.month, 1, 0, 0, 0, 0)).getUTCDay() : undefined;
    for (let i = this[target] + offset;i < pattern[target].length; i++) {
      let match = pattern[target][i];
      if (target === "day" && pattern.lastDayOfMonth && i - offset == lastDayOfMonth) {
        match = true;
      }
      if (target === "day" && !pattern.starDOW) {
        let dowMatch = pattern.dayOfWeek[(fDomWeekDay + (i - offset - 1)) % 7];
        if (dowMatch && pattern.lastWeekdayOfMonth) {
          dowMatch = dowMatch && i - offset > lastDayOfMonth - 7;
        }
        if (options.legacyMode && !pattern.starDOM) {
          match = match || dowMatch;
        } else {
          match = match && dowMatch;
        }
      }
      if (match) {
        this[target] = i - offset;
        return originalTarget !== this[target] ? 2 : 1;
      }
    }
    return 3;
  };
  CronDate.prototype.recurse = function(pattern, options, doing) {
    const res = this.findNext(options, RecursionSteps[doing][0], pattern, RecursionSteps[doing][2]);
    if (res > 1) {
      let resetLevel = doing + 1;
      while (resetLevel < RecursionSteps.length) {
        this[RecursionSteps[resetLevel][0]] = -RecursionSteps[resetLevel][2];
        resetLevel++;
      }
      if (res === 3) {
        this[RecursionSteps[doing][1]]++;
        this[RecursionSteps[doing][0]] = -RecursionSteps[doing][2];
        this.apply();
        return this.recurse(pattern, options, 0);
      } else if (this.apply()) {
        return this.recurse(pattern, options, doing - 1);
      }
    }
    doing += 1;
    if (doing >= RecursionSteps.length) {
      return this;
    } else if (this.year >= 3000) {
      return null;
    } else {
      return this.recurse(pattern, options, doing);
    }
  };
  CronDate.prototype.increment = function(pattern, options, hasPreviousRun) {
    this.second += options.interval > 1 && hasPreviousRun ? options.interval : 1;
    this.ms = 0;
    this.apply();
    return this.recurse(pattern, options, 0);
  };
  CronDate.prototype.getDate = function(internal) {
    if (internal || this.tz === undefined) {
      return new Date(this.year, this.month, this.day, this.hour, this.minute, this.second, this.ms);
    } else {
      if (typeof this.tz === "number") {
        return new Date(Date.UTC(this.year, this.month, this.day, this.hour, this.minute - this.tz, this.second, this.ms));
      } else {
        return minitz(this.year, this.month + 1, this.day, this.hour, this.minute, this.second, this.tz);
      }
    }
  };
  CronDate.prototype.getTime = function() {
    return this.getDate().getTime();
  };
  function CronPattern(pattern, timezone) {
    this.pattern = pattern;
    this.timezone = timezone;
    this.second = Array(60).fill(0);
    this.minute = Array(60).fill(0);
    this.hour = Array(24).fill(0);
    this.day = Array(31).fill(0);
    this.month = Array(12).fill(0);
    this.dayOfWeek = Array(8).fill(0);
    this.lastDayOfMonth = false;
    this.lastWeekdayOfMonth = false;
    this.starDOM = false;
    this.starDOW = false;
    this.parse();
  }
  CronPattern.prototype.parse = function() {
    if (!(typeof this.pattern === "string" || this.pattern.constructor === String)) {
      throw new TypeError("CronPattern: Pattern has to be of type string.");
    }
    if (this.pattern.indexOf("@") >= 0)
      this.pattern = this.handleNicknames(this.pattern).trim();
    const parts = this.pattern.replace(/\s+/g, " ").split(" ");
    if (parts.length < 5 || parts.length > 6) {
      throw new TypeError("CronPattern: invalid configuration format ('" + this.pattern + "'), exacly five or six space separated parts required.");
    }
    if (parts.length === 5) {
      parts.unshift("0");
    }
    if (parts[3].indexOf("L") >= 0) {
      parts[3] = parts[3].replace("L", "");
      this.lastDayOfMonth = true;
    }
    if (parts[5].indexOf("L") >= 0) {
      parts[5] = parts[5].replace("L", "");
      this.lastWeekdayOfMonth = true;
    }
    if (parts[3] == "*") {
      this.starDOM = true;
    }
    if (parts[4].length >= 3)
      parts[4] = this.replaceAlphaMonths(parts[4]);
    if (parts[5].length >= 3)
      parts[5] = this.replaceAlphaDays(parts[5]);
    if (parts[5] == "*") {
      this.starDOW = true;
    }
    if (this.pattern.indexOf("?") >= 0) {
      const initDate = new CronDate(new Date, this.timezone).getDate(true);
      parts[0] = parts[0].replace("?", initDate.getSeconds());
      parts[1] = parts[1].replace("?", initDate.getMinutes());
      parts[2] = parts[2].replace("?", initDate.getHours());
      if (!this.starDOM)
        parts[3] = parts[3].replace("?", initDate.getDate());
      parts[4] = parts[4].replace("?", initDate.getMonth() + 1);
      if (!this.starDOW)
        parts[5] = parts[5].replace("?", initDate.getDay());
    }
    this.throwAtIllegalCharacters(parts);
    this.partToArray("second", parts[0], 0);
    this.partToArray("minute", parts[1], 0);
    this.partToArray("hour", parts[2], 0);
    this.partToArray("day", parts[3], -1);
    this.partToArray("month", parts[4], -1);
    this.partToArray("dayOfWeek", parts[5], 0);
    if (this.dayOfWeek[7]) {
      this.dayOfWeek[0] = 1;
    }
  };
  CronPattern.prototype.partToArray = function(type, conf, valueIndexOffset) {
    const arr = this[type];
    if (conf === "*")
      return arr.fill(1);
    const split = conf.split(",");
    if (split.length > 1) {
      for (let i = 0;i < split.length; i++) {
        this.partToArray(type, split[i], valueIndexOffset);
      }
    } else if (conf.indexOf("-") !== -1 && conf.indexOf("/") !== -1) {
      this.handleRangeWithStepping(conf, type, valueIndexOffset);
    } else if (conf.indexOf("-") !== -1) {
      this.handleRange(conf, type, valueIndexOffset);
    } else if (conf.indexOf("/") !== -1) {
      this.handleStepping(conf, type, valueIndexOffset);
    } else if (conf !== "") {
      this.handleNumber(conf, type, valueIndexOffset);
    }
  };
  CronPattern.prototype.throwAtIllegalCharacters = function(parts) {
    const reValidCron = /[^/*0-9,-]+/;
    for (let i = 0;i < parts.length; i++) {
      if (reValidCron.test(parts[i])) {
        throw new TypeError("CronPattern: configuration entry " + i + " (" + parts[i] + ") contains illegal characters.");
      }
    }
  };
  CronPattern.prototype.handleNumber = function(conf, type, valueIndexOffset) {
    const i = parseInt(conf, 10) + valueIndexOffset;
    if (isNaN(i)) {
      throw new TypeError("CronPattern: " + type + " is not a number: '" + conf + "'");
    }
    if (i < 0 || i >= this[type].length) {
      throw new TypeError("CronPattern: " + type + " value out of range: '" + conf + "'");
    }
    this[type][i] = 1;
  };
  CronPattern.prototype.handleRangeWithStepping = function(conf, type, valueIndexOffset) {
    const matches = conf.match(/^(\d+)-(\d+)\/(\d+)$/);
    if (matches === null)
      throw new TypeError("CronPattern: Syntax error, illegal range with stepping: '" + conf + "'");
    let [, lower, upper, steps] = matches;
    lower = parseInt(lower, 10) + valueIndexOffset;
    upper = parseInt(upper, 10) + valueIndexOffset;
    steps = parseInt(steps, 10);
    if (isNaN(lower))
      throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
    if (isNaN(upper))
      throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
    if (isNaN(steps))
      throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
    if (steps === 0)
      throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
    if (steps > this[type].length)
      throw new TypeError("CronPattern: Syntax error, steps cannot be greater than maximum value of part (" + this[type].length + ")");
    if (lower < 0 || upper >= this[type].length)
      throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
    if (lower > upper)
      throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
    for (let i = lower;i <= upper; i += steps) {
      this[type][i] = 1;
    }
  };
  CronPattern.prototype.handleRange = function(conf, type, valueIndexOffset) {
    const split = conf.split("-");
    if (split.length !== 2) {
      throw new TypeError("CronPattern: Syntax error, illegal range: '" + conf + "'");
    }
    const lower = parseInt(split[0], 10) + valueIndexOffset, upper = parseInt(split[1], 10) + valueIndexOffset;
    if (isNaN(lower)) {
      throw new TypeError("CronPattern: Syntax error, illegal lower range (NaN)");
    } else if (isNaN(upper)) {
      throw new TypeError("CronPattern: Syntax error, illegal upper range (NaN)");
    }
    if (lower < 0 || upper >= this[type].length) {
      throw new TypeError("CronPattern: Value out of range: '" + conf + "'");
    }
    if (lower > upper) {
      throw new TypeError("CronPattern: From value is larger than to value: '" + conf + "'");
    }
    for (let i = lower;i <= upper; i++) {
      this[type][i] = 1;
    }
  };
  CronPattern.prototype.handleStepping = function(conf, type) {
    const split = conf.split("/");
    if (split.length !== 2) {
      throw new TypeError("CronPattern: Syntax error, illegal stepping: '" + conf + "'");
    }
    let start = 0;
    if (split[0] !== "*") {
      start = parseInt(split[0], 10);
    }
    const steps = parseInt(split[1], 10);
    if (isNaN(steps))
      throw new TypeError("CronPattern: Syntax error, illegal stepping: (NaN)");
    if (steps === 0)
      throw new TypeError("CronPattern: Syntax error, illegal stepping: 0");
    if (steps > this[type].length)
      throw new TypeError("CronPattern: Syntax error, max steps for part is (" + this[type].length + ")");
    for (let i = start;i < this[type].length; i += steps) {
      this[type][i] = 1;
    }
  };
  CronPattern.prototype.replaceAlphaDays = function(conf) {
    return conf.replace(/-sun/gi, "-7").replace(/sun/gi, "0").replace(/mon/gi, "1").replace(/tue/gi, "2").replace(/wed/gi, "3").replace(/thu/gi, "4").replace(/fri/gi, "5").replace(/sat/gi, "6");
  };
  CronPattern.prototype.replaceAlphaMonths = function(conf) {
    return conf.replace(/jan/gi, "1").replace(/feb/gi, "2").replace(/mar/gi, "3").replace(/apr/gi, "4").replace(/may/gi, "5").replace(/jun/gi, "6").replace(/jul/gi, "7").replace(/aug/gi, "8").replace(/sep/gi, "9").replace(/oct/gi, "10").replace(/nov/gi, "11").replace(/dec/gi, "12");
  };
  CronPattern.prototype.handleNicknames = function(pattern) {
    const cleanPattern = pattern.trim().toLowerCase();
    if (cleanPattern === "@yearly" || cleanPattern === "@annually") {
      return "0 0 1 1 *";
    } else if (cleanPattern === "@monthly") {
      return "0 0 1 * *";
    } else if (cleanPattern === "@weekly") {
      return "0 0 * * 0";
    } else if (cleanPattern === "@daily") {
      return "0 0 * * *";
    } else if (cleanPattern === "@hourly") {
      return "0 * * * *";
    } else {
      return pattern;
    }
  };
  function isFunction(v) {
    return Object.prototype.toString.call(v) === "[object Function]" || typeof v === "function" || v instanceof Function;
  }
  function unrefTimer(timer) {
    if (typeof Deno !== "undefined" && typeof Deno.unrefTimer !== "undefined") {
      Deno.unrefTimer(timer);
    } else if (timer && typeof timer.unref !== "undefined") {
      timer.unref();
    }
  }
  var maxDelay = 30 * 1000;
  var scheduledJobs = [];
  function Cron(pattern, fnOrOptions1, fnOrOptions2) {
    if (!(this instanceof Cron)) {
      return new Cron(pattern, fnOrOptions1, fnOrOptions2);
    }
    let options, func;
    if (isFunction(fnOrOptions1)) {
      func = fnOrOptions1;
    } else if (typeof fnOrOptions1 === "object") {
      options = fnOrOptions1;
    } else if (fnOrOptions1 !== undefined) {
      throw new Error("Cron: Invalid argument passed for optionsIn. Should be one of function, or object (options).");
    }
    if (isFunction(fnOrOptions2)) {
      func = fnOrOptions2;
    } else if (typeof fnOrOptions2 === "object") {
      options = fnOrOptions2;
    } else if (fnOrOptions2 !== undefined) {
      throw new Error("Cron: Invalid argument passed for funcIn. Should be one of function, or object (options).");
    }
    this.name = options ? options.name : undefined;
    this.options = CronOptions(options);
    this._states = { kill: false, blocking: false, previousRun: undefined, currentRun: undefined, once: undefined, currentTimeout: undefined, maxRuns: options ? options.maxRuns : undefined, paused: options ? options.paused : false, pattern: undefined };
    if (pattern && (pattern instanceof Date || typeof pattern === "string" && pattern.indexOf(":") > 0)) {
      this._states.once = new CronDate(pattern, this.options.timezone || this.options.utcOffset);
    } else {
      this._states.pattern = new CronPattern(pattern, this.options.timezone);
    }
    if (this.name) {
      const existing = scheduledJobs.find((j) => j.name === this.name);
      if (existing) {
        throw new Error("Cron: Tried to initialize new named job '" + this.name + "', but name already taken.");
      } else {
        scheduledJobs.push(this);
      }
    }
    if (func !== undefined) {
      this.fn = func;
      this.schedule();
    }
    return this;
  }
  Cron.prototype.nextRun = function(prev) {
    const next = this._next(prev);
    return next ? next.getDate() : null;
  };
  Cron.prototype.nextRuns = function(n, previous) {
    if (n > this._states.maxRuns) {
      n = this._states.maxRuns;
    }
    const enumeration = [];
    let prev = previous || this._states.currentRun;
    while (n-- && (prev = this.nextRun(prev))) {
      enumeration.push(prev);
    }
    return enumeration;
  };
  Cron.prototype.getPattern = function() {
    return this._states.pattern ? this._states.pattern.pattern : undefined;
  };
  Cron.prototype.isRunning = function() {
    const msLeft = this.msToNext(this._states.currentRun);
    const isRunning = !this._states.paused;
    const isScheduled = this.fn !== undefined;
    const notIsKilled = !this._states.kill;
    return isRunning && isScheduled && notIsKilled && msLeft !== null;
  };
  Cron.prototype.isStopped = function() {
    return this._states.kill;
  };
  Cron.prototype.isBusy = function() {
    return this._states.blocking;
  };
  Cron.prototype.currentRun = function() {
    return this._states.currentRun ? this._states.currentRun.getDate() : null;
  };
  Cron.prototype.previousRun = function() {
    return this._states.previousRun ? this._states.previousRun.getDate() : null;
  };
  Cron.prototype.msToNext = function(prev) {
    const next = this._next(prev);
    prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
    if (next) {
      return next.getTime(true) - prev.getTime(true);
    } else {
      return null;
    }
  };
  Cron.prototype.stop = function() {
    this._states.kill = true;
    if (this._states.currentTimeout) {
      clearTimeout(this._states.currentTimeout);
    }
    const jobIndex = scheduledJobs.indexOf(this);
    if (jobIndex >= 0) {
      scheduledJobs.splice(jobIndex, 1);
    }
  };
  Cron.prototype.pause = function() {
    this._states.paused = true;
    return !this._states.kill;
  };
  Cron.prototype.resume = function() {
    this._states.paused = false;
    return !this._states.kill;
  };
  Cron.prototype.schedule = function(func, partial) {
    if (func && this.fn) {
      throw new Error("Cron: It is not allowed to schedule two functions using the same Croner instance.");
    } else if (func) {
      this.fn = func;
    }
    let waitMs = this.msToNext(partial ? partial : this._states.currentRun);
    const target = this.nextRun(partial ? partial : this._states.currentRun);
    if (waitMs === null || target === null)
      return this;
    if (waitMs > maxDelay) {
      waitMs = maxDelay;
    }
    this._states.currentTimeout = setTimeout(() => this._checkTrigger(target), waitMs);
    if (this._states.currentTimeout && this.options.unref) {
      unrefTimer(this._states.currentTimeout);
    }
    return this;
  };
  Cron.prototype._trigger = async function(initiationDate) {
    this._states.blocking = true;
    this._states.currentRun = new CronDate(undefined, this.options.timezone || this.options.utcOffset);
    if (this.options.catch) {
      try {
        await this.fn(this, this.options.context);
      } catch (_e) {
        if (isFunction(this.options.catch)) {
          this.options.catch(_e, this);
        }
      }
    } else {
      await this.fn(this, this.options.context);
    }
    this._states.previousRun = new CronDate(initiationDate, this.options.timezone || this.options.utcOffset);
    this._states.blocking = false;
  };
  Cron.prototype.trigger = async function() {
    await this._trigger();
  };
  Cron.prototype._checkTrigger = function(target) {
    const now = new Date, shouldRun = !this._states.paused && now.getTime() >= target, isBlocked = this._states.blocking && this.options.protect;
    if (shouldRun && !isBlocked) {
      this._states.maxRuns--;
      this._trigger();
    } else {
      if (shouldRun && isBlocked && isFunction(this.options.protect)) {
        setTimeout(() => this.options.protect(this), 0);
      }
    }
    this.schedule(undefined, now);
  };
  Cron.prototype._next = function(prev) {
    const hasPreviousRun = prev || this._states.currentRun ? true : false;
    prev = new CronDate(prev, this.options.timezone || this.options.utcOffset);
    if (this.options.startAt && prev && prev.getTime() < this.options.startAt.getTime()) {
      prev = this.options.startAt;
    }
    const nextRun = this._states.once || new CronDate(prev, this.options.timezone || this.options.utcOffset).increment(this._states.pattern, this.options, hasPreviousRun);
    if (this._states.once && this._states.once.getTime() <= prev.getTime()) {
      return null;
    } else if (nextRun === null || this._states.maxRuns <= 0 || this._states.kill || this.options.stopAt && nextRun.getTime() >= this.options.stopAt.getTime()) {
      return null;
    } else {
      return nextRun;
    }
  };
  Cron.Cron = Cron;
  Cron.scheduledJobs = scheduledJobs;
  module.exports = Cron;
});

// node_modules/@elysiajs/cron/dist/cjs/index.js
var require_cjs5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.cron = undefined;
  var croner_1 = require_croner_min();
  var cron = ({ pattern, name, run, ...options }) => (app) => {
    if (!pattern)
      throw new Error("pattern is required");
    if (!name)
      throw new Error("name is required");
    return app.state((store) => {
      const prevCron = app.store?.cron ?? {};
      return {
        ...store,
        cron: {
          ...prevCron,
          [name]: new croner_1.Cron(pattern, options, () => run(app.store))
        }
      };
    });
  };
  exports.cron = cron;
  exports.default = exports.cron;
});

// node_modules/@elysiajs/swagger/dist/cjs/swagger/index.js
var require_swagger = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SwaggerUIRender = undefined;
  var SwaggerUIRender = (info, version, theme, stringifiedSwaggerOptions, autoDarkMode) => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${stringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;
  exports.SwaggerUIRender = SwaggerUIRender;
});

// node_modules/@elysiajs/swagger/dist/cjs/scalar/theme.js
var require_theme = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;
});

// node_modules/@elysiajs/swagger/dist/cjs/scalar/index.js
var require_scalar = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScalarRender = undefined;
  var theme_1 = __importDefault(require_theme());
  var ScalarRender = (version, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? theme_1.default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version}/dist/browser/standalone.min.js`}"></script>
  </body>
</html>`;
  exports.ScalarRender = ScalarRender;
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS((exports, module) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map, pair) {
    map.set(pair[0], pair[1]);
    return map;
  }
  function addSetEntry(set, value) {
    set.add(value);
    return set;
  }
  function arrayEach(array, iteratee) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }
  function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1, length = array ? array.length : 0;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {}
    }
    return result;
  }
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var Symbol2 = root.Symbol;
  var Uint8Array2 = root.Uint8Array;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise2 = getNative(root, "Promise");
  var Set2 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise2);
  var setCtorString = toSource(Set2);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash,
      map: new (Map2 || ListCache),
      string: new Hash
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache;
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object, source) {
    return object && copyObject(source, keys(source), object);
  }
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys(value);
    }
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
  }
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
  }
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
  }
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array) {
    var length = array.length, result = array.constructor(length);
    if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);
      case boolTag:
      case dateTag:
        return new Ctor(+object);
      case dataViewTag:
        return cloneDataView(object, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object, isDeep);
      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object);
      case regexpTag:
        return cloneRegExp(object);
      case setTag:
        return cloneSet(object, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object);
    }
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return func + "";
      } catch (e) {}
    }
    return "";
  }
  function cloneDeep(value) {
    return baseClone(value, true, true);
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
});

// node_modules/@elysiajs/swagger/dist/cjs/utils.js
var require_utils = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.filterPaths = exports.registerSchemaPath = exports.generateOperationId = exports.capitalize = exports.mapProperties = exports.toOpenAPIPath = undefined;
  var typebox_1 = require_cjs2();
  var lodash_clonedeep_1 = __importDefault(require_lodash());
  var toOpenAPIPath = (path) => path.split("/").map((x) => x.startsWith(":") ? `{${x.slice(1, x.length)}}` : x).join("/");
  exports.toOpenAPIPath = toOpenAPIPath;
  var mapProperties = (name, schema, models) => {
    if (schema === undefined)
      return [];
    if (typeof schema === "string")
      if (schema in models)
        schema = models[schema];
      else
        throw new Error(`Can't find model ${schema}`);
    return Object.entries(schema?.properties ?? []).map(([key, value]) => {
      const { type: valueType = undefined, ...rest } = value;
      return {
        ...rest,
        schema: { type: valueType },
        in: name,
        name: key,
        required: schema.required?.includes(key) ?? false
      };
    });
  };
  exports.mapProperties = mapProperties;
  var mapTypesResponse = (types, schema) => {
    if (typeof schema === "object" && ["void", "undefined", "null"].includes(schema.type))
      return;
    const responses = {};
    for (const type of types)
      responses[type] = {
        schema: typeof schema === "string" ? {
          $ref: `#/components/schemas/${schema}`
        } : { ...schema }
      };
    return responses;
  };
  var capitalize = (word) => word.charAt(0).toUpperCase() + word.slice(1);
  exports.capitalize = capitalize;
  var generateOperationId = (method, paths) => {
    let operationId = method.toLowerCase();
    if (paths === "/")
      return operationId + "Index";
    for (const path of paths.split("/")) {
      if (path.charCodeAt(0) === 123) {
        operationId += "By" + (0, exports.capitalize)(path.slice(1, -1));
      } else {
        operationId += (0, exports.capitalize)(path);
      }
    }
    return operationId;
  };
  exports.generateOperationId = generateOperationId;
  var registerSchemaPath = ({ schema, path, method, hook, models }) => {
    if (hook)
      hook = (0, lodash_clonedeep_1.default)(hook);
    const contentType = hook?.type ?? [
      "application/json",
      "multipart/form-data",
      "text/plain"
    ];
    path = (0, exports.toOpenAPIPath)(path);
    const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
    const bodySchema = hook?.body;
    const paramsSchema = hook?.params;
    const headerSchema = hook?.headers;
    const querySchema = hook?.query;
    let responseSchema = hook?.response;
    if (typeof responseSchema === "object") {
      if (typebox_1.Kind in responseSchema) {
        const { type, properties, required, additionalProperties, ...rest } = responseSchema;
        responseSchema = {
          "200": {
            ...rest,
            description: rest.description,
            content: mapTypesResponse(contentTypes, type === "object" || type === "array" ? {
              type,
              properties,
              items: responseSchema.items,
              required
            } : responseSchema)
          }
        };
      } else {
        Object.entries(responseSchema).forEach(([key, value]) => {
          if (typeof value === "string") {
            if (!models[value])
              return;
            const { type, properties, required, additionalProperties: _, ...rest } = models[value];
            responseSchema[key] = {
              ...rest,
              description: rest.description,
              content: mapTypesResponse(contentTypes, value)
            };
          } else {
            const { type, properties, required, additionalProperties, ...rest } = value;
            responseSchema[key] = {
              ...rest,
              description: rest.description,
              content: mapTypesResponse(contentTypes, rest.type === "object" || rest.type === "array" ? {
                type: rest.type,
                properties,
                items: value.items,
                required
              } : value)
            };
          }
        });
      }
    } else if (typeof responseSchema === "string") {
      if (!(responseSchema in models))
        return;
      const { type, properties, required, additionalProperties: _, ...rest } = models[responseSchema];
      responseSchema = {
        "200": {
          ...rest,
          content: mapTypesResponse(contentTypes, responseSchema)
        }
      };
    }
    const parameters = [
      ...(0, exports.mapProperties)("header", headerSchema, models),
      ...(0, exports.mapProperties)("path", paramsSchema, models),
      ...(0, exports.mapProperties)("query", querySchema, models)
    ];
    schema[path] = {
      ...schema[path] ? schema[path] : {},
      [method.toLowerCase()]: {
        ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters } : {},
        ...responseSchema ? {
          responses: responseSchema
        } : {},
        operationId: hook?.detail?.operationId ?? (0, exports.generateOperationId)(method, path),
        ...hook?.detail,
        ...bodySchema ? {
          requestBody: {
            content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
              $ref: `#/components/schemas/${bodySchema}`
            } : bodySchema)
          }
        } : null
      }
    };
  };
  exports.registerSchemaPath = registerSchemaPath;
  var filterPaths = (paths, { excludeStaticFile = true, exclude = [] }) => {
    const newPaths = {};
    for (const [key, value] of Object.entries(paths))
      if (!exclude.some((x) => {
        if (typeof x === "string")
          return key === x;
        return x.test(key);
      }) && !key.includes("/swagger") && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
        Object.keys(value).forEach((method) => {
          const schema = value[method];
          if (key.includes("{")) {
            if (!schema.parameters)
              schema.parameters = [];
            schema.parameters = [
              ...key.split("/").filter((x) => x.startsWith("{") && !schema.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
                schema: { type: "string" },
                in: "path",
                name: x.slice(1, x.length - 1),
                required: true
              })),
              ...schema.parameters
            ];
          }
          if (!schema.responses)
            schema.responses = {
              200: {}
            };
        });
        newPaths[key] = value;
      }
    return newPaths;
  };
  exports.filterPaths = filterPaths;
});

// node_modules/@elysiajs/swagger/dist/cjs/index.js
var require_cjs6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.swagger = undefined;
  var swagger_1 = require_swagger();
  var scalar_1 = require_scalar();
  var utils_1 = require_utils();
  var swagger = ({ provider = "scalar", scalarVersion = "latest", scalarCDN = "", scalarConfig = {}, documentation = {}, version = "5.9.0", excludeStaticFile = true, path = "/swagger", exclude = [], swaggerOptions = {}, theme = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`, autoDarkMode = true, excludeMethods = ["OPTIONS"] } = {
    provider: "scalar",
    scalarVersion: "latest",
    scalarCDN: "",
    scalarConfig: {},
    documentation: {},
    version: "5.9.0",
    excludeStaticFile: true,
    path: "/swagger",
    exclude: [],
    swaggerOptions: {},
    autoDarkMode: true,
    excludeMethods: ["OPTIONS"]
  }) => (app) => {
    const schema = {};
    let totalRoutes = 0;
    if (!version)
      version = `https://unpkg.com/swagger-ui-dist@${version}/swagger-ui.css`;
    const info = {
      title: "Elysia Documentation",
      description: "Development documentation",
      version: "0.0.0",
      ...documentation.info
    };
    const relativePath = path.startsWith("/") ? path.slice(1) : path;
    app.get(path, (() => {
      const combinedSwaggerOptions = {
        url: `${relativePath}/json`,
        dom_id: "#swagger-ui",
        ...swaggerOptions
      };
      const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value) => {
        if (typeof value == "function")
          return;
        return value;
      });
      const scalarConfiguration = {
        spec: {
          ...scalarConfig.spec,
          url: `${relativePath}/json`
        },
        ...scalarConfig
      };
      return new Response(provider === "swagger-ui" ? (0, swagger_1.SwaggerUIRender)(info, version, theme, stringifiedSwaggerOptions, autoDarkMode) : (0, scalar_1.ScalarRender)(scalarVersion, scalarConfiguration, scalarCDN), {
        headers: {
          "content-type": "text/html; charset=utf8"
        }
      });
    })()).get(`${path}/json`, () => {
      const routes = app.routes;
      if (routes.length !== totalRoutes) {
        totalRoutes = routes.length;
        routes.forEach((route) => {
          if (excludeMethods.includes(route.method))
            return;
          (0, utils_1.registerSchemaPath)({
            schema,
            hook: route.hooks,
            method: route.method,
            path: route.path,
            models: app.definitions?.type,
            contentType: route.hooks.type
          });
        });
      }
      return {
        openapi: "3.0.3",
        ...{
          ...documentation,
          info: {
            title: "Elysia Documentation",
            description: "Development documentation",
            version: "0.0.0",
            ...documentation.info
          }
        },
        paths: (0, utils_1.filterPaths)(schema, {
          excludeStaticFile,
          exclude: Array.isArray(exclude) ? exclude : [exclude]
        }),
        components: {
          ...documentation.components,
          schemas: {
            ...app.definitions?.type,
            ...documentation.components?.schemas
          }
        }
      };
    });
    return app;
  };
  exports.swagger = swagger;
  exports.default = exports.swagger;
});

// node_modules/postgres-array/index.js
var require_postgres_array = __commonJS((exports) => {
  exports.parse = function(source, transform4) {
    return new ArrayParser(source, transform4).parse();
  };

  class ArrayParser {
    constructor(source, transform4) {
      this.source = source;
      this.transform = transform4 || identity;
      this.position = 0;
      this.entries = [];
      this.recorded = [];
      this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var character = this.source[this.position++];
      if (character === "\\") {
        return {
          value: this.source[this.position++],
          escaped: true
        };
      }
      return {
        value: character,
        escaped: false
      };
    }
    record(character) {
      this.recorded.push(character);
    }
    newEntry(includeEmpty) {
      var entry;
      if (this.recorded.length > 0 || includeEmpty) {
        entry = this.recorded.join("");
        if (entry === "NULL" && !includeEmpty) {
          entry = null;
        }
        if (entry !== null)
          entry = this.transform(entry);
        this.entries.push(entry);
        this.recorded = [];
      }
    }
    consumeDimensions() {
      if (this.source[0] === "[") {
        while (!this.isEof()) {
          var char = this.nextCharacter();
          if (char.value === "=")
            break;
        }
      }
    }
    parse(nested) {
      var character, parser, quote;
      this.consumeDimensions();
      while (!this.isEof()) {
        character = this.nextCharacter();
        if (character.value === "{" && !quote) {
          this.dimension++;
          if (this.dimension > 1) {
            parser = new ArrayParser(this.source.substr(this.position - 1), this.transform);
            this.entries.push(parser.parse(true));
            this.position += parser.position - 2;
          }
        } else if (character.value === "}" && !quote) {
          this.dimension--;
          if (!this.dimension) {
            this.newEntry();
            if (nested)
              return this.entries;
          }
        } else if (character.value === '"' && !character.escaped) {
          if (quote)
            this.newEntry(true);
          quote = !quote;
        } else if (character.value === "," && !quote) {
          this.newEntry();
        } else {
          this.record(character.value);
        }
      }
      if (this.dimension !== 0) {
        throw new Error("array dimension not balanced");
      }
      return this.entries;
    }
  }
  function identity(value2) {
    return value2;
  }
});

// node_modules/pg-types/lib/arrayParser.js
var require_arrayParser = __commonJS((exports, module) => {
  var array3 = require_postgres_array();
  module.exports = {
    create: function(source, transform4) {
      return {
        parse: function() {
          return array3.parse(source, transform4);
        }
      };
    }
  };
});

// node_modules/postgres-date/index.js
var require_postgres_date = __commonJS((exports, module) => {
  var DATE_TIME = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/;
  var DATE = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/;
  var TIME_ZONE = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/;
  var INFINITY = /^-?infinity$/;
  module.exports = function parseDate(isoDate) {
    if (INFINITY.test(isoDate)) {
      return Number(isoDate.replace("i", "I"));
    }
    var matches = DATE_TIME.exec(isoDate);
    if (!matches) {
      return getDate(isoDate) || null;
    }
    var isBC = !!matches[8];
    var year = parseInt(matches[1], 10);
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var hour = parseInt(matches[4], 10);
    var minute = parseInt(matches[5], 10);
    var second = parseInt(matches[6], 10);
    var ms = matches[7];
    ms = ms ? 1000 * parseFloat(ms) : 0;
    var date3;
    var offset = timeZoneOffset(isoDate);
    if (offset != null) {
      date3 = new Date(Date.UTC(year, month, day, hour, minute, second, ms));
      if (is0To99(year)) {
        date3.setUTCFullYear(year);
      }
      if (offset !== 0) {
        date3.setTime(date3.getTime() - offset);
      }
    } else {
      date3 = new Date(year, month, day, hour, minute, second, ms);
      if (is0To99(year)) {
        date3.setFullYear(year);
      }
    }
    return date3;
  };
  function getDate(isoDate) {
    var matches = DATE.exec(isoDate);
    if (!matches) {
      return;
    }
    var year = parseInt(matches[1], 10);
    var isBC = !!matches[4];
    if (isBC) {
      year = bcYearToNegativeYear(year);
    }
    var month = parseInt(matches[2], 10) - 1;
    var day = matches[3];
    var date3 = new Date(year, month, day);
    if (is0To99(year)) {
      date3.setFullYear(year);
    }
    return date3;
  }
  function timeZoneOffset(isoDate) {
    if (isoDate.endsWith("+00")) {
      return 0;
    }
    var zone = TIME_ZONE.exec(isoDate.split(" ")[1]);
    if (!zone)
      return;
    var type3 = zone[1];
    if (type3 === "Z") {
      return 0;
    }
    var sign = type3 === "-" ? -1 : 1;
    var offset = parseInt(zone[2], 10) * 3600 + parseInt(zone[3] || 0, 10) * 60 + parseInt(zone[4] || 0, 10);
    return offset * sign * 1000;
  }
  function bcYearToNegativeYear(year) {
    return -(year - 1);
  }
  function is0To99(num) {
    return num >= 0 && num < 100;
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports, module) => {
  module.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1;i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/postgres-interval/index.js
var require_postgres_interval = __commonJS((exports, module) => {
  var extend = require_mutable();
  module.exports = PostgresInterval;
  function PostgresInterval(raw) {
    if (!(this instanceof PostgresInterval)) {
      return new PostgresInterval(raw);
    }
    extend(this, parse3(raw));
  }
  var properties = ["seconds", "minutes", "hours", "days", "months", "years"];
  PostgresInterval.prototype.toPostgres = function() {
    var filtered = properties.filter(this.hasOwnProperty, this);
    if (this.milliseconds && filtered.indexOf("seconds") < 0) {
      filtered.push("seconds");
    }
    if (filtered.length === 0)
      return "0";
    return filtered.map(function(property) {
      var value2 = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value2 = (value2 + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, "");
      }
      return value2 + " " + property;
    }, this).join(" ");
  };
  var propertiesISOEquivalent = {
    years: "Y",
    months: "M",
    days: "D",
    hours: "H",
    minutes: "M",
    seconds: "S"
  };
  var dateProperties = ["years", "months", "days"];
  var timeProperties = ["hours", "minutes", "seconds"];
  PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function() {
    var datePart = dateProperties.map(buildProperty, this).join("");
    var timePart = timeProperties.map(buildProperty, this).join("");
    return "P" + datePart + "T" + timePart;
    function buildProperty(property) {
      var value2 = this[property] || 0;
      if (property === "seconds" && this.milliseconds) {
        value2 = (value2 + this.milliseconds / 1000).toFixed(6).replace(/0+$/, "");
      }
      return value2 + propertiesISOEquivalent[property];
    }
  };
  var NUMBER = "([+-]?\\d+)";
  var YEAR = NUMBER + "\\s+years?";
  var MONTH = NUMBER + "\\s+mons?";
  var DAY = NUMBER + "\\s+days?";
  var TIME = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?";
  var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function(regexString) {
    return "(" + regexString + ")?";
  }).join("\\s*"));
  var positions = {
    years: 2,
    months: 4,
    days: 6,
    hours: 9,
    minutes: 10,
    seconds: 11,
    milliseconds: 12
  };
  var negatives = ["hours", "minutes", "seconds", "milliseconds"];
  function parseMilliseconds(fraction) {
    var microseconds = fraction + "000000".slice(fraction.length);
    return parseInt(microseconds, 10) / 1000;
  }
  function parse3(interval) {
    if (!interval)
      return {};
    var matches = INTERVAL.exec(interval);
    var isNegative = matches[8] === "-";
    return Object.keys(positions).reduce(function(parsed, property) {
      var position = positions[property];
      var value2 = matches[position];
      if (!value2)
        return parsed;
      value2 = property === "milliseconds" ? parseMilliseconds(value2) : parseInt(value2, 10);
      if (!value2)
        return parsed;
      if (isNegative && ~negatives.indexOf(property)) {
        value2 *= -1;
      }
      parsed[property] = value2;
      return parsed;
    }, {});
  }
});

// node_modules/postgres-bytea/index.js
var require_postgres_bytea = __commonJS((exports, module) => {
  module.exports = function parseBytea(input) {
    if (/^\\x/.test(input)) {
      return new Buffer(input.substr(2), "hex");
    }
    var output = "";
    var i = 0;
    while (i < input.length) {
      if (input[i] !== "\\") {
        output += input[i];
        ++i;
      } else {
        if (/[0-7]{3}/.test(input.substr(i + 1, 3))) {
          output += String.fromCharCode(parseInt(input.substr(i + 1, 3), 8));
          i += 4;
        } else {
          var backslashes = 1;
          while (i + backslashes < input.length && input[i + backslashes] === "\\") {
            backslashes++;
          }
          for (var k = 0;k < Math.floor(backslashes / 2); ++k) {
            output += "\\";
          }
          i += Math.floor(backslashes / 2) * 2;
        }
      }
    }
    return new Buffer(output, "binary");
  };
});

// node_modules/pg-types/lib/textParsers.js
var require_textParsers = __commonJS((exports, module) => {
  var array3 = require_postgres_array();
  var arrayParser = require_arrayParser();
  var parseDate = require_postgres_date();
  var parseInterval = require_postgres_interval();
  var parseByteA = require_postgres_bytea();
  function allowNull(fn) {
    return function nullAllowed(value2) {
      if (value2 === null)
        return value2;
      return fn(value2);
    };
  }
  function parseBool(value2) {
    if (value2 === null)
      return value2;
    return value2 === "TRUE" || value2 === "t" || value2 === "true" || value2 === "y" || value2 === "yes" || value2 === "on" || value2 === "1";
  }
  function parseBoolArray(value2) {
    if (!value2)
      return null;
    return array3.parse(value2, parseBool);
  }
  function parseBaseTenInt(string3) {
    return parseInt(string3, 10);
  }
  function parseIntegerArray(value2) {
    if (!value2)
      return null;
    return array3.parse(value2, allowNull(parseBaseTenInt));
  }
  function parseBigIntegerArray(value2) {
    if (!value2)
      return null;
    return array3.parse(value2, allowNull(function(entry) {
      return parseBigInteger(entry).trim();
    }));
  }
  var parsePointArray = function(value2) {
    if (!value2) {
      return null;
    }
    var p = arrayParser.create(value2, function(entry) {
      if (entry !== null) {
        entry = parsePoint(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseFloatArray = function(value2) {
    if (!value2) {
      return null;
    }
    var p = arrayParser.create(value2, function(entry) {
      if (entry !== null) {
        entry = parseFloat(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseStringArray = function(value2) {
    if (!value2) {
      return null;
    }
    var p = arrayParser.create(value2);
    return p.parse();
  };
  var parseDateArray = function(value2) {
    if (!value2) {
      return null;
    }
    var p = arrayParser.create(value2, function(entry) {
      if (entry !== null) {
        entry = parseDate(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseIntervalArray = function(value2) {
    if (!value2) {
      return null;
    }
    var p = arrayParser.create(value2, function(entry) {
      if (entry !== null) {
        entry = parseInterval(entry);
      }
      return entry;
    });
    return p.parse();
  };
  var parseByteAArray = function(value2) {
    if (!value2) {
      return null;
    }
    return array3.parse(value2, allowNull(parseByteA));
  };
  var parseInteger = function(value2) {
    return parseInt(value2, 10);
  };
  var parseBigInteger = function(value2) {
    var valStr = String(value2);
    if (/^\d+$/.test(valStr)) {
      return valStr;
    }
    return value2;
  };
  var parseJsonArray = function(value2) {
    if (!value2) {
      return null;
    }
    return array3.parse(value2, allowNull(JSON.parse));
  };
  var parsePoint = function(value2) {
    if (value2[0] !== "(") {
      return null;
    }
    value2 = value2.substring(1, value2.length - 1).split(",");
    return {
      x: parseFloat(value2[0]),
      y: parseFloat(value2[1])
    };
  };
  var parseCircle = function(value2) {
    if (value2[0] !== "<" && value2[1] !== "(") {
      return null;
    }
    var point = "(";
    var radius = "";
    var pointParsed = false;
    for (var i = 2;i < value2.length - 1; i++) {
      if (!pointParsed) {
        point += value2[i];
      }
      if (value2[i] === ")") {
        pointParsed = true;
        continue;
      } else if (!pointParsed) {
        continue;
      }
      if (value2[i] === ",") {
        continue;
      }
      radius += value2[i];
    }
    var result = parsePoint(point);
    result.radius = parseFloat(radius);
    return result;
  };
  var init = function(register) {
    register(20, parseBigInteger);
    register(21, parseInteger);
    register(23, parseInteger);
    register(26, parseInteger);
    register(700, parseFloat);
    register(701, parseFloat);
    register(16, parseBool);
    register(1082, parseDate);
    register(1114, parseDate);
    register(1184, parseDate);
    register(600, parsePoint);
    register(651, parseStringArray);
    register(718, parseCircle);
    register(1000, parseBoolArray);
    register(1001, parseByteAArray);
    register(1005, parseIntegerArray);
    register(1007, parseIntegerArray);
    register(1028, parseIntegerArray);
    register(1016, parseBigIntegerArray);
    register(1017, parsePointArray);
    register(1021, parseFloatArray);
    register(1022, parseFloatArray);
    register(1231, parseFloatArray);
    register(1014, parseStringArray);
    register(1015, parseStringArray);
    register(1008, parseStringArray);
    register(1009, parseStringArray);
    register(1040, parseStringArray);
    register(1041, parseStringArray);
    register(1115, parseDateArray);
    register(1182, parseDateArray);
    register(1185, parseDateArray);
    register(1186, parseInterval);
    register(1187, parseIntervalArray);
    register(17, parseByteA);
    register(114, JSON.parse.bind(JSON));
    register(3802, JSON.parse.bind(JSON));
    register(199, parseJsonArray);
    register(3807, parseJsonArray);
    register(3907, parseStringArray);
    register(2951, parseStringArray);
    register(791, parseStringArray);
    register(1183, parseStringArray);
    register(1270, parseStringArray);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-int8/index.js
var require_pg_int8 = __commonJS((exports, module) => {
  var BASE = 1e6;
  function readInt8(buffer) {
    var high = buffer.readInt32BE(0);
    var low = buffer.readUInt32BE(4);
    var sign = "";
    if (high < 0) {
      high = ~high + (low === 0);
      low = ~low + 1 >>> 0;
      sign = "-";
    }
    var result = "";
    var carry;
    var t2;
    var digits;
    var pad;
    var l;
    var i;
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      high = high / BASE >>> 0;
      t2 = 4294967296 * carry + low;
      low = t2 / BASE >>> 0;
      digits = "" + (t2 - BASE * low);
      if (low === 0 && high === 0) {
        return sign + digits + result;
      }
      pad = "";
      l = 6 - digits.length;
      for (i = 0;i < l; i++) {
        pad += "0";
      }
      result = pad + digits + result;
    }
    {
      carry = high % BASE;
      t2 = 4294967296 * carry + low;
      digits = "" + t2 % BASE;
      return sign + digits + result;
    }
  }
  module.exports = readInt8;
});

// node_modules/pg-types/lib/binaryParsers.js
var require_binaryParsers = __commonJS((exports, module) => {
  var parseInt64 = require_pg_int8();
  var parseBits = function(data, bits, offset, invert, callback) {
    offset = offset || 0;
    invert = invert || false;
    callback = callback || function(lastValue, newValue, bits2) {
      return lastValue * Math.pow(2, bits2) + newValue;
    };
    var offsetBytes = offset >> 3;
    var inv = function(value2) {
      if (invert) {
        return ~value2 & 255;
      }
      return value2;
    };
    var mask = 255;
    var firstBits = 8 - offset % 8;
    if (bits < firstBits) {
      mask = 255 << 8 - bits & 255;
      firstBits = bits;
    }
    if (offset) {
      mask = mask >> offset % 8;
    }
    var result = 0;
    if (offset % 8 + bits >= 8) {
      result = callback(0, inv(data[offsetBytes]) & mask, firstBits);
    }
    var bytes = bits + offset >> 3;
    for (var i = offsetBytes + 1;i < bytes; i++) {
      result = callback(result, inv(data[i]), 8);
    }
    var lastBits = (bits + offset) % 8;
    if (lastBits > 0) {
      result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);
    }
    return result;
  };
  var parseFloatFromBits = function(data, precisionBits, exponentBits) {
    var bias = Math.pow(2, exponentBits - 1) - 1;
    var sign = parseBits(data, 1);
    var exponent = parseBits(data, exponentBits, 1);
    if (exponent === 0) {
      return 0;
    }
    var precisionBitsCounter = 1;
    var parsePrecisionBits = function(lastValue, newValue, bits) {
      if (lastValue === 0) {
        lastValue = 1;
      }
      for (var i = 1;i <= bits; i++) {
        precisionBitsCounter /= 2;
        if ((newValue & 1 << bits - i) > 0) {
          lastValue += precisionBitsCounter;
        }
      }
      return lastValue;
    };
    var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);
    if (exponent == Math.pow(2, exponentBits + 1) - 1) {
      if (mantissa === 0) {
        return sign === 0 ? Infinity : -Infinity;
      }
      return NaN;
    }
    return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;
  };
  var parseInt16 = function(value2) {
    if (parseBits(value2, 1) == 1) {
      return -1 * (parseBits(value2, 15, 1, true) + 1);
    }
    return parseBits(value2, 15, 1);
  };
  var parseInt32 = function(value2) {
    if (parseBits(value2, 1) == 1) {
      return -1 * (parseBits(value2, 31, 1, true) + 1);
    }
    return parseBits(value2, 31, 1);
  };
  var parseFloat32 = function(value2) {
    return parseFloatFromBits(value2, 23, 8);
  };
  var parseFloat64 = function(value2) {
    return parseFloatFromBits(value2, 52, 11);
  };
  var parseNumeric = function(value2) {
    var sign = parseBits(value2, 16, 32);
    if (sign == 49152) {
      return NaN;
    }
    var weight = Math.pow(1e4, parseBits(value2, 16, 16));
    var result = 0;
    var digits = [];
    var ndigits = parseBits(value2, 16);
    for (var i = 0;i < ndigits; i++) {
      result += parseBits(value2, 16, 64 + 16 * i) * weight;
      weight /= 1e4;
    }
    var scale = Math.pow(10, parseBits(value2, 16, 48));
    return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;
  };
  var parseDate = function(isUTC, value2) {
    var sign = parseBits(value2, 1);
    var rawValue = parseBits(value2, 63, 1);
    var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);
    if (!isUTC) {
      result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);
    }
    result.usec = rawValue % 1000;
    result.getMicroSeconds = function() {
      return this.usec;
    };
    result.setMicroSeconds = function(value3) {
      this.usec = value3;
    };
    result.getUTCMicroSeconds = function() {
      return this.usec;
    };
    return result;
  };
  var parseArray = function(value2) {
    var dim = parseBits(value2, 32);
    var flags = parseBits(value2, 32, 32);
    var elementType = parseBits(value2, 32, 64);
    var offset = 96;
    var dims = [];
    for (var i = 0;i < dim; i++) {
      dims[i] = parseBits(value2, 32, offset);
      offset += 32;
      offset += 32;
    }
    var parseElement = function(elementType2) {
      var length = parseBits(value2, 32, offset);
      offset += 32;
      if (length == 4294967295) {
        return null;
      }
      var result;
      if (elementType2 == 23 || elementType2 == 20) {
        result = parseBits(value2, length * 8, offset);
        offset += length * 8;
        return result;
      } else if (elementType2 == 25) {
        result = value2.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);
        return result;
      } else {
        console.log("ERROR: ElementType not implemented: " + elementType2);
      }
    };
    var parse3 = function(dimension, elementType2) {
      var array3 = [];
      var i2;
      if (dimension.length > 1) {
        var count = dimension.shift();
        for (i2 = 0;i2 < count; i2++) {
          array3[i2] = parse3(dimension, elementType2);
        }
        dimension.unshift(count);
      } else {
        for (i2 = 0;i2 < dimension[0]; i2++) {
          array3[i2] = parseElement(elementType2);
        }
      }
      return array3;
    };
    return parse3(dims, elementType);
  };
  var parseText = function(value2) {
    return value2.toString("utf8");
  };
  var parseBool = function(value2) {
    if (value2 === null)
      return null;
    return parseBits(value2, 8) > 0;
  };
  var init = function(register) {
    register(20, parseInt64);
    register(21, parseInt16);
    register(23, parseInt32);
    register(26, parseInt32);
    register(1700, parseNumeric);
    register(700, parseFloat32);
    register(701, parseFloat64);
    register(16, parseBool);
    register(1114, parseDate.bind(null, false));
    register(1184, parseDate.bind(null, true));
    register(1000, parseArray);
    register(1007, parseArray);
    register(1016, parseArray);
    register(1008, parseArray);
    register(1009, parseArray);
    register(25, parseText);
  };
  module.exports = {
    init
  };
});

// node_modules/pg-types/lib/builtins.js
var require_builtins = __commonJS((exports, module) => {
  module.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});

// node_modules/pg-types/index.js
var require_pg_types = __commonJS((exports) => {
  var textParsers = require_textParsers();
  var binaryParsers = require_binaryParsers();
  var arrayParser = require_arrayParser();
  var builtinTypes = require_builtins();
  exports.getTypeParser = getTypeParser;
  exports.setTypeParser = setTypeParser;
  exports.arrayParser = arrayParser;
  exports.builtins = builtinTypes;
  var typeParsers = {
    text: {},
    binary: {}
  };
  function noParse(val) {
    return String(val);
  }
  function getTypeParser(oid, format) {
    format = format || "text";
    if (!typeParsers[format]) {
      return noParse;
    }
    return typeParsers[format][oid] || noParse;
  }
  function setTypeParser(oid, format, parseFn) {
    if (typeof format == "function") {
      parseFn = format;
      format = "text";
    }
    typeParsers[format][oid] = parseFn;
  }
  textParsers.init(function(oid, converter) {
    typeParsers.text[oid] = converter;
  });
  binaryParsers.init(function(oid, converter) {
    typeParsers.binary[oid] = converter;
  });
});

// node_modules/pg/lib/defaults.js
var require_defaults = __commonJS((exports, module) => {
  module.exports = {
    host: "localhost",
    user: process.platform === "win32" ? process.env.USERNAME : process.env.USER,
    database: undefined,
    password: null,
    connectionString: undefined,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 30000,
    client_encoding: "",
    ssl: false,
    application_name: undefined,
    fallback_application_name: undefined,
    options: undefined,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var pgTypes = require_pg_types();
  var parseBigInteger = pgTypes.getTypeParser(20, "text");
  var parseBigIntegerArray = pgTypes.getTypeParser(1016, "text");
  module.exports.__defineSetter__("parseInt8", function(val) {
    pgTypes.setTypeParser(20, "text", val ? pgTypes.getTypeParser(23, "text") : parseBigInteger);
    pgTypes.setTypeParser(1016, "text", val ? pgTypes.getTypeParser(1007, "text") : parseBigIntegerArray);
  });
});

// node_modules/pg/lib/utils.js
var require_utils2 = __commonJS((exports, module) => {
  var defaults = require_defaults();
  var util = __require("util");
  var { isDate } = util.types || util;
  function escapeElement(elementRepresentation) {
    const escaped = elementRepresentation.replace(/\\/g, "\\\\").replace(/"/g, "\\\"");
    return '"' + escaped + '"';
  }
  function arrayString(val) {
    let result = "{";
    for (let i = 0;i < val.length; i++) {
      if (i > 0) {
        result = result + ",";
      }
      if (val[i] === null || typeof val[i] === "undefined") {
        result = result + "NULL";
      } else if (Array.isArray(val[i])) {
        result = result + arrayString(val[i]);
      } else if (ArrayBuffer.isView(val[i])) {
        let item = val[i];
        if (!(item instanceof Buffer)) {
          const buf = Buffer.from(item.buffer, item.byteOffset, item.byteLength);
          if (buf.length === item.byteLength) {
            item = buf;
          } else {
            item = buf.slice(item.byteOffset, item.byteOffset + item.byteLength);
          }
        }
        result += "\\\\x" + item.toString("hex");
      } else {
        result += escapeElement(prepareValue(val[i]));
      }
    }
    result = result + "}";
    return result;
  }
  var prepareValue = function(val, seen) {
    if (val == null) {
      return null;
    }
    if (typeof val === "object") {
      if (val instanceof Buffer) {
        return val;
      }
      if (ArrayBuffer.isView(val)) {
        const buf = Buffer.from(val.buffer, val.byteOffset, val.byteLength);
        if (buf.length === val.byteLength) {
          return buf;
        }
        return buf.slice(val.byteOffset, val.byteOffset + val.byteLength);
      }
      if (isDate(val)) {
        if (defaults.parseInputDatesAsUTC) {
          return dateToStringUTC(val);
        } else {
          return dateToString(val);
        }
      }
      if (Array.isArray(val)) {
        return arrayString(val);
      }
      return prepareObject(val, seen);
    }
    return val.toString();
  };
  function prepareObject(val, seen) {
    if (val && typeof val.toPostgres === "function") {
      seen = seen || [];
      if (seen.indexOf(val) !== -1) {
        throw new Error('circular reference detected while preparing "' + val + '" for query');
      }
      seen.push(val);
      return prepareValue(val.toPostgres(prepareValue), seen);
    }
    return JSON.stringify(val);
  }
  function dateToString(date3) {
    let offset = -date3.getTimezoneOffset();
    let year = date3.getFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date3.getMonth() + 1).padStart(2, "0") + "-" + String(date3.getDate()).padStart(2, "0") + "T" + String(date3.getHours()).padStart(2, "0") + ":" + String(date3.getMinutes()).padStart(2, "0") + ":" + String(date3.getSeconds()).padStart(2, "0") + "." + String(date3.getMilliseconds()).padStart(3, "0");
    if (offset < 0) {
      ret += "-";
      offset *= -1;
    } else {
      ret += "+";
    }
    ret += String(Math.floor(offset / 60)).padStart(2, "0") + ":" + String(offset % 60).padStart(2, "0");
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function dateToStringUTC(date3) {
    let year = date3.getUTCFullYear();
    const isBCYear = year < 1;
    if (isBCYear)
      year = Math.abs(year) + 1;
    let ret = String(year).padStart(4, "0") + "-" + String(date3.getUTCMonth() + 1).padStart(2, "0") + "-" + String(date3.getUTCDate()).padStart(2, "0") + "T" + String(date3.getUTCHours()).padStart(2, "0") + ":" + String(date3.getUTCMinutes()).padStart(2, "0") + ":" + String(date3.getUTCSeconds()).padStart(2, "0") + "." + String(date3.getUTCMilliseconds()).padStart(3, "0");
    ret += "+00:00";
    if (isBCYear)
      ret += " BC";
    return ret;
  }
  function normalizeQueryConfig(config, values, callback) {
    config = typeof config === "string" ? { text: config } : config;
    if (values) {
      if (typeof values === "function") {
        config.callback = values;
      } else {
        config.values = values;
      }
    }
    if (callback) {
      config.callback = callback;
    }
    return config;
  }
  var escapeIdentifier = function(str) {
    return '"' + str.replace(/"/g, '""') + '"';
  };
  var escapeLiteral = function(str) {
    let hasBackslash = false;
    let escaped = "'";
    if (str == null) {
      return "''";
    }
    if (typeof str !== "string") {
      return "''";
    }
    for (let i = 0;i < str.length; i++) {
      const c = str[i];
      if (c === "'") {
        escaped += c + c;
      } else if (c === "\\") {
        escaped += c + c;
        hasBackslash = true;
      } else {
        escaped += c;
      }
    }
    escaped += "'";
    if (hasBackslash === true) {
      escaped = " E" + escaped;
    }
    return escaped;
  };
  module.exports = {
    prepareValue: function prepareValueWrapper(value2) {
      return prepareValue(value2);
    },
    normalizeQueryConfig,
    escapeIdentifier,
    escapeLiteral
  };
});

// node_modules/pg/lib/crypto/utils-legacy.js
var require_utils_legacy = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  function md5(string3) {
    return nodeCrypto.createHash("md5").update(string3, "utf-8").digest("hex");
  }
  function postgresMd5PasswordHash(user, password, salt) {
    const inner = md5(password + user);
    const outer = md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  function sha256(text) {
    return nodeCrypto.createHash("sha256").update(text).digest();
  }
  function hashByName(hashName, text) {
    hashName = hashName.replace(/(\D)-/, "$1");
    return nodeCrypto.createHash(hashName).update(text).digest();
  }
  function hmacSha256(key, msg) {
    return nodeCrypto.createHmac("sha256", key).update(msg).digest();
  }
  async function deriveKey(password, salt, iterations) {
    return nodeCrypto.pbkdf2Sync(password, salt, iterations, 32, "sha256");
  }
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes: nodeCrypto.randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
});

// node_modules/pg/lib/crypto/utils-webcrypto.js
var require_utils_webcrypto = __commonJS((exports, module) => {
  var nodeCrypto = __require("crypto");
  module.exports = {
    postgresMd5PasswordHash,
    randomBytes,
    deriveKey,
    sha256,
    hashByName,
    hmacSha256,
    md5
  };
  var webCrypto = nodeCrypto.webcrypto || globalThis.crypto;
  var subtleCrypto = webCrypto.subtle;
  var textEncoder = new TextEncoder;
  function randomBytes(length) {
    return webCrypto.getRandomValues(Buffer.alloc(length));
  }
  async function md5(string3) {
    try {
      return nodeCrypto.createHash("md5").update(string3, "utf-8").digest("hex");
    } catch (e) {
      const data = typeof string3 === "string" ? textEncoder.encode(string3) : string3;
      const hash3 = await subtleCrypto.digest("MD5", data);
      return Array.from(new Uint8Array(hash3)).map((b) => b.toString(16).padStart(2, "0")).join("");
    }
  }
  async function postgresMd5PasswordHash(user, password, salt) {
    const inner = await md5(password + user);
    const outer = await md5(Buffer.concat([Buffer.from(inner), salt]));
    return "md5" + outer;
  }
  async function sha256(text) {
    return await subtleCrypto.digest("SHA-256", text);
  }
  async function hashByName(hashName, text) {
    return await subtleCrypto.digest(hashName, text);
  }
  async function hmacSha256(keyBuffer, msg) {
    const key = await subtleCrypto.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return await subtleCrypto.sign("HMAC", key, textEncoder.encode(msg));
  }
  async function deriveKey(password, salt, iterations) {
    const key = await subtleCrypto.importKey("raw", textEncoder.encode(password), "PBKDF2", false, ["deriveBits"]);
    const params = { name: "PBKDF2", hash: "SHA-256", salt, iterations };
    return await subtleCrypto.deriveBits(params, key, 32 * 8, ["deriveBits"]);
  }
});

// node_modules/pg/lib/crypto/utils.js
var require_utils3 = __commonJS((exports, module) => {
  var useLegacyCrypto = parseInt(process.versions && process.versions.node && process.versions.node.split(".")[0]) < 15;
  if (useLegacyCrypto) {
    module.exports = require_utils_legacy();
  } else {
    module.exports = require_utils_webcrypto();
  }
});

// node_modules/pg/lib/crypto/cert-signatures.js
var require_cert_signatures = __commonJS((exports, module) => {
  function x509Error(msg, cert) {
    return new Error("SASL channel binding: " + msg + " when parsing public certificate " + cert.toString("base64"));
  }
  function readASN1Length(data, index) {
    let length = data[index++];
    if (length < 128)
      return { length, index };
    const lengthBytes = length & 127;
    if (lengthBytes > 4)
      throw x509Error("bad length", data);
    length = 0;
    for (let i = 0;i < lengthBytes; i++) {
      length = length << 8 | data[index++];
    }
    return { length, index };
  }
  function readASN1OID(data, index) {
    if (data[index++] !== 6)
      throw x509Error("non-OID data", data);
    const { length: OIDLength, index: indexAfterOIDLength } = readASN1Length(data, index);
    index = indexAfterOIDLength;
    const lastIndex = index + OIDLength;
    const byte1 = data[index++];
    let oid = (byte1 / 40 >> 0) + "." + byte1 % 40;
    while (index < lastIndex) {
      let value2 = 0;
      while (index < lastIndex) {
        const nextByte = data[index++];
        value2 = value2 << 7 | nextByte & 127;
        if (nextByte < 128)
          break;
      }
      oid += "." + value2;
    }
    return { oid, index };
  }
  function expectASN1Seq(data, index) {
    if (data[index++] !== 48)
      throw x509Error("non-sequence data", data);
    return readASN1Length(data, index);
  }
  function signatureAlgorithmHashFromCertificate(data, index) {
    if (index === undefined)
      index = 0;
    index = expectASN1Seq(data, index).index;
    const { length: certInfoLength, index: indexAfterCertInfoLength } = expectASN1Seq(data, index);
    index = indexAfterCertInfoLength + certInfoLength;
    index = expectASN1Seq(data, index).index;
    const { oid, index: indexAfterOID } = readASN1OID(data, index);
    switch (oid) {
      case "1.2.840.113549.1.1.4":
        return "MD5";
      case "1.2.840.113549.1.1.5":
        return "SHA-1";
      case "1.2.840.113549.1.1.11":
        return "SHA-256";
      case "1.2.840.113549.1.1.12":
        return "SHA-384";
      case "1.2.840.113549.1.1.13":
        return "SHA-512";
      case "1.2.840.113549.1.1.14":
        return "SHA-224";
      case "1.2.840.113549.1.1.15":
        return "SHA512-224";
      case "1.2.840.113549.1.1.16":
        return "SHA512-256";
      case "1.2.840.10045.4.1":
        return "SHA-1";
      case "1.2.840.10045.4.3.1":
        return "SHA-224";
      case "1.2.840.10045.4.3.2":
        return "SHA-256";
      case "1.2.840.10045.4.3.3":
        return "SHA-384";
      case "1.2.840.10045.4.3.4":
        return "SHA-512";
      case "1.2.840.113549.1.1.10": {
        index = indexAfterOID;
        index = expectASN1Seq(data, index).index;
        if (data[index++] !== 160)
          throw x509Error("non-tag data", data);
        index = readASN1Length(data, index).index;
        index = expectASN1Seq(data, index).index;
        const { oid: hashOID } = readASN1OID(data, index);
        switch (hashOID) {
          case "1.2.840.113549.2.5":
            return "MD5";
          case "1.3.14.3.2.26":
            return "SHA-1";
          case "2.16.840.1.101.3.4.2.1":
            return "SHA-256";
          case "2.16.840.1.101.3.4.2.2":
            return "SHA-384";
          case "2.16.840.1.101.3.4.2.3":
            return "SHA-512";
        }
        throw x509Error("unknown hash OID " + hashOID, data);
      }
      case "1.3.101.110":
      case "1.3.101.112":
        return "SHA-512";
      case "1.3.101.111":
      case "1.3.101.113":
        throw x509Error("Ed448 certificate channel binding is not currently supported by Postgres");
    }
    throw x509Error("unknown OID " + oid, data);
  }
  module.exports = { signatureAlgorithmHashFromCertificate };
});

// node_modules/pg/lib/crypto/sasl.js
var require_sasl = __commonJS((exports, module) => {
  var crypto2 = require_utils3();
  var { signatureAlgorithmHashFromCertificate } = require_cert_signatures();
  function startSession(mechanisms, stream) {
    const candidates = ["SCRAM-SHA-256"];
    if (stream)
      candidates.unshift("SCRAM-SHA-256-PLUS");
    const mechanism = candidates.find((candidate) => mechanisms.includes(candidate));
    if (!mechanism) {
      throw new Error("SASL: Only mechanism(s) " + candidates.join(" and ") + " are supported");
    }
    if (mechanism === "SCRAM-SHA-256-PLUS" && typeof stream.getPeerCertificate !== "function") {
      throw new Error("SASL: Mechanism SCRAM-SHA-256-PLUS requires a certificate");
    }
    const clientNonce = crypto2.randomBytes(18).toString("base64");
    const gs2Header = mechanism === "SCRAM-SHA-256-PLUS" ? "p=tls-server-end-point" : stream ? "y" : "n";
    return {
      mechanism,
      clientNonce,
      response: gs2Header + ",,n=*,r=" + clientNonce,
      message: "SASLInitialResponse"
    };
  }
  async function continueSession(session, password, serverData, stream) {
    if (session.message !== "SASLInitialResponse") {
      throw new Error("SASL: Last message was not SASLInitialResponse");
    }
    if (typeof password !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    }
    if (password === "") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a non-empty string");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    }
    const sv = parseServerFirstMessage(serverData);
    if (!sv.nonce.startsWith(session.clientNonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    } else if (sv.nonce.length === session.clientNonce.length) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    }
    const clientFirstMessageBare = "n=*,r=" + session.clientNonce;
    const serverFirstMessage = "r=" + sv.nonce + ",s=" + sv.salt + ",i=" + sv.iteration;
    let channelBinding = stream ? "eSws" : "biws";
    if (session.mechanism === "SCRAM-SHA-256-PLUS") {
      const peerCert = stream.getPeerCertificate().raw;
      let hashName = signatureAlgorithmHashFromCertificate(peerCert);
      if (hashName === "MD5" || hashName === "SHA-1")
        hashName = "SHA-256";
      const certHash = await crypto2.hashByName(hashName, peerCert);
      const bindingData = Buffer.concat([Buffer.from("p=tls-server-end-point,,"), Buffer.from(certHash)]);
      channelBinding = bindingData.toString("base64");
    }
    const clientFinalMessageWithoutProof = "c=" + channelBinding + ",r=" + sv.nonce;
    const authMessage = clientFirstMessageBare + "," + serverFirstMessage + "," + clientFinalMessageWithoutProof;
    const saltBytes = Buffer.from(sv.salt, "base64");
    const saltedPassword = await crypto2.deriveKey(password, saltBytes, sv.iteration);
    const clientKey = await crypto2.hmacSha256(saltedPassword, "Client Key");
    const storedKey = await crypto2.sha256(clientKey);
    const clientSignature = await crypto2.hmacSha256(storedKey, authMessage);
    const clientProof = xorBuffers(Buffer.from(clientKey), Buffer.from(clientSignature)).toString("base64");
    const serverKey = await crypto2.hmacSha256(saltedPassword, "Server Key");
    const serverSignatureBytes = await crypto2.hmacSha256(serverKey, authMessage);
    session.message = "SASLResponse";
    session.serverSignature = Buffer.from(serverSignatureBytes).toString("base64");
    session.response = clientFinalMessageWithoutProof + ",p=" + clientProof;
  }
  function finalizeSession(session, serverData) {
    if (session.message !== "SASLResponse") {
      throw new Error("SASL: Last message was not SASLResponse");
    }
    if (typeof serverData !== "string") {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    }
    const { serverSignature } = parseServerFinalMessage(serverData);
    if (serverSignature !== session.serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
    }
  }
  function isPrintableChars(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: text must be a string");
    }
    return text.split("").map((_, i) => text.charCodeAt(i)).every((c) => c >= 33 && c <= 43 || c >= 45 && c <= 126);
  }
  function isBase64(text) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(text);
  }
  function parseAttributePairs(text) {
    if (typeof text !== "string") {
      throw new TypeError("SASL: attribute pairs text must be a string");
    }
    return new Map(text.split(",").map((attrValue) => {
      if (!/^.=/.test(attrValue)) {
        throw new Error("SASL: Invalid attribute pair entry");
      }
      const name = attrValue[0];
      const value2 = attrValue.substring(2);
      return [name, value2];
    }));
  }
  function parseServerFirstMessage(data) {
    const attrPairs = parseAttributePairs(data);
    const nonce = attrPairs.get("r");
    if (!nonce) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    } else if (!isPrintableChars(nonce)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    }
    const salt = attrPairs.get("s");
    if (!salt) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    } else if (!isBase64(salt)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    }
    const iterationText = attrPairs.get("i");
    if (!iterationText) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    } else if (!/^[1-9][0-9]*$/.test(iterationText)) {
      throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    }
    const iteration = parseInt(iterationText, 10);
    return {
      nonce,
      salt,
      iteration
    };
  }
  function parseServerFinalMessage(serverData) {
    const attrPairs = parseAttributePairs(serverData);
    const serverSignature = attrPairs.get("v");
    if (!serverSignature) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    } else if (!isBase64(serverSignature)) {
      throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    }
    return {
      serverSignature
    };
  }
  function xorBuffers(a, b) {
    if (!Buffer.isBuffer(a)) {
      throw new TypeError("first argument must be a Buffer");
    }
    if (!Buffer.isBuffer(b)) {
      throw new TypeError("second argument must be a Buffer");
    }
    if (a.length !== b.length) {
      throw new Error("Buffer lengths must match");
    }
    if (a.length === 0) {
      throw new Error("Buffers cannot be empty");
    }
    return Buffer.from(a.map((_, i) => a[i] ^ b[i]));
  }
  module.exports = {
    startSession,
    continueSession,
    finalizeSession
  };
});

// node_modules/pg/lib/type-overrides.js
var require_type_overrides = __commonJS((exports, module) => {
  var types = require_pg_types();
  function TypeOverrides(userTypes) {
    this._types = userTypes || types;
    this.text = {};
    this.binary = {};
  }
  TypeOverrides.prototype.getOverrides = function(format) {
    switch (format) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  TypeOverrides.prototype.setTypeParser = function(oid, format, parseFn) {
    if (typeof format === "function") {
      parseFn = format;
      format = "text";
    }
    this.getOverrides(format)[oid] = parseFn;
  };
  TypeOverrides.prototype.getTypeParser = function(oid, format) {
    format = format || "text";
    return this.getOverrides(format)[oid] || this._types.getTypeParser(oid, format);
  };
  module.exports = TypeOverrides;
});

// node_modules/pg-connection-string/index.js
var require_pg_connection_string = __commonJS((exports, module) => {
  function parse3(str, options = {}) {
    if (str.charAt(0) === "/") {
      const config2 = str.split(" ");
      return { host: config2[0], database: config2[1] };
    }
    const config = {};
    let result;
    let dummyHost = false;
    if (/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(str)) {
      str = encodeURI(str).replace(/%25(\d\d)/g, "%$1");
    }
    try {
      try {
        result = new URL(str, "postgres://base");
      } catch (e) {
        result = new URL(str.replace("@/", "@___DUMMY___/"), "postgres://base");
        dummyHost = true;
      }
    } catch (err) {
      err.input && (err.input = "*****REDACTED*****");
    }
    for (const entry of result.searchParams.entries()) {
      config[entry[0]] = entry[1];
    }
    config.user = config.user || decodeURIComponent(result.username);
    config.password = config.password || decodeURIComponent(result.password);
    if (result.protocol == "socket:") {
      config.host = decodeURI(result.pathname);
      config.database = result.searchParams.get("db");
      config.client_encoding = result.searchParams.get("encoding");
      return config;
    }
    const hostname = dummyHost ? "" : result.hostname;
    if (!config.host) {
      config.host = decodeURIComponent(hostname);
    } else if (hostname && /^%2f/i.test(hostname)) {
      result.pathname = hostname + result.pathname;
    }
    if (!config.port) {
      config.port = result.port;
    }
    const pathname = result.pathname.slice(1) || null;
    config.database = pathname ? decodeURI(pathname) : null;
    if (config.ssl === "true" || config.ssl === "1") {
      config.ssl = true;
    }
    if (config.ssl === "0") {
      config.ssl = false;
    }
    if (config.sslcert || config.sslkey || config.sslrootcert || config.sslmode) {
      config.ssl = {};
    }
    const fs = config.sslcert || config.sslkey || config.sslrootcert ? __require("fs") : null;
    if (config.sslcert) {
      config.ssl.cert = fs.readFileSync(config.sslcert).toString();
    }
    if (config.sslkey) {
      config.ssl.key = fs.readFileSync(config.sslkey).toString();
    }
    if (config.sslrootcert) {
      config.ssl.ca = fs.readFileSync(config.sslrootcert).toString();
    }
    if (options.useLibpqCompat && config.uselibpqcompat) {
      throw new Error("Both useLibpqCompat and uselibpqcompat are set. Please use only one of them.");
    }
    if (config.uselibpqcompat === "true" || options.useLibpqCompat) {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
        case "require": {
          if (config.sslrootcert) {
            config.ssl.checkServerIdentity = function() {};
          } else {
            config.ssl.rejectUnauthorized = false;
          }
          break;
        }
        case "verify-ca": {
          if (!config.ssl.ca) {
            throw new Error("SECURITY WARNING: Using sslmode=verify-ca requires specifying a CA with sslrootcert. If a public CA is used, verify-ca allows connections to a server that somebody else may have registered with the CA, making you vulnerable to Man-in-the-Middle attacks. Either specify a custom CA certificate with sslrootcert parameter or use sslmode=verify-full for proper security.");
          }
          config.ssl.checkServerIdentity = function() {};
          break;
        }
        case "verify-full": {
          break;
        }
      }
    } else {
      switch (config.sslmode) {
        case "disable": {
          config.ssl = false;
          break;
        }
        case "prefer":
        case "require":
        case "verify-ca":
        case "verify-full": {
          break;
        }
        case "no-verify": {
          config.ssl.rejectUnauthorized = false;
          break;
        }
      }
    }
    return config;
  }
  function toConnectionOptions(sslConfig) {
    const connectionOptions = Object.entries(sslConfig).reduce((c, [key, value2]) => {
      if (value2 !== undefined && value2 !== null) {
        c[key] = value2;
      }
      return c;
    }, {});
    return connectionOptions;
  }
  function toClientConfig(config) {
    const poolConfig = Object.entries(config).reduce((c, [key, value2]) => {
      if (key === "ssl") {
        const sslConfig = value2;
        if (typeof sslConfig === "boolean") {
          c[key] = sslConfig;
        }
        if (typeof sslConfig === "object") {
          c[key] = toConnectionOptions(sslConfig);
        }
      } else if (value2 !== undefined && value2 !== null) {
        if (key === "port") {
          if (value2 !== "") {
            const v = parseInt(value2, 10);
            if (isNaN(v)) {
              throw new Error(`Invalid ${key}: ${value2}`);
            }
            c[key] = v;
          }
        } else {
          c[key] = value2;
        }
      }
      return c;
    }, {});
    return poolConfig;
  }
  function parseIntoClientConfig(str) {
    return toClientConfig(parse3(str));
  }
  module.exports = parse3;
  parse3.parse = parse3;
  parse3.toClientConfig = toClientConfig;
  parse3.parseIntoClientConfig = parseIntoClientConfig;
});

// node_modules/pg/lib/connection-parameters.js
var require_connection_parameters = __commonJS((exports, module) => {
  var dns = __require("dns");
  var defaults = require_defaults();
  var parse3 = require_pg_connection_string().parse;
  var val = function(key, config, envVar) {
    if (envVar === undefined) {
      envVar = process.env["PG" + key.toUpperCase()];
    } else if (envVar === false) {} else {
      envVar = process.env[envVar];
    }
    return config[key] || envVar || defaults[key];
  };
  var readSSLConfigFromEnvironment = function() {
    switch (process.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return defaults.ssl;
  };
  var quoteParamValue = function(value2) {
    return "'" + ("" + value2).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  };
  var add = function(params, config, paramName) {
    const value2 = config[paramName];
    if (value2 !== undefined && value2 !== null) {
      params.push(paramName + "=" + quoteParamValue(value2));
    }
  };

  class ConnectionParameters {
    constructor(config) {
      config = typeof config === "string" ? parse3(config) : config || {};
      if (config.connectionString) {
        config = Object.assign({}, config, parse3(config.connectionString));
      }
      this.user = val("user", config);
      this.database = val("database", config);
      if (this.database === undefined) {
        this.database = this.user;
      }
      this.port = parseInt(val("port", config), 10);
      this.host = val("host", config);
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: val("password", config)
      });
      this.binary = val("binary", config);
      this.options = val("options", config);
      this.ssl = typeof config.ssl === "undefined" ? readSSLConfigFromEnvironment() : config.ssl;
      if (typeof this.ssl === "string") {
        if (this.ssl === "true") {
          this.ssl = true;
        }
      }
      if (this.ssl === "no-verify") {
        this.ssl = { rejectUnauthorized: false };
      }
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this.client_encoding = val("client_encoding", config);
      this.replication = val("replication", config);
      this.isDomainSocket = !(this.host || "").indexOf("/");
      this.application_name = val("application_name", config, "PGAPPNAME");
      this.fallback_application_name = val("fallback_application_name", config, false);
      this.statement_timeout = val("statement_timeout", config, false);
      this.lock_timeout = val("lock_timeout", config, false);
      this.idle_in_transaction_session_timeout = val("idle_in_transaction_session_timeout", config, false);
      this.query_timeout = val("query_timeout", config, false);
      if (config.connectionTimeoutMillis === undefined) {
        this.connect_timeout = process.env.PGCONNECT_TIMEOUT || 0;
      } else {
        this.connect_timeout = Math.floor(config.connectionTimeoutMillis / 1000);
      }
      if (config.keepAlive === false) {
        this.keepalives = 0;
      } else if (config.keepAlive === true) {
        this.keepalives = 1;
      }
      if (typeof config.keepAliveInitialDelayMillis === "number") {
        this.keepalives_idle = Math.floor(config.keepAliveInitialDelayMillis / 1000);
      }
    }
    getLibpqConnectionString(cb) {
      const params = [];
      add(params, this, "user");
      add(params, this, "password");
      add(params, this, "port");
      add(params, this, "application_name");
      add(params, this, "fallback_application_name");
      add(params, this, "connect_timeout");
      add(params, this, "options");
      const ssl = typeof this.ssl === "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      add(params, ssl, "sslmode");
      add(params, ssl, "sslca");
      add(params, ssl, "sslkey");
      add(params, ssl, "sslcert");
      add(params, ssl, "sslrootcert");
      if (this.database) {
        params.push("dbname=" + quoteParamValue(this.database));
      }
      if (this.replication) {
        params.push("replication=" + quoteParamValue(this.replication));
      }
      if (this.host) {
        params.push("host=" + quoteParamValue(this.host));
      }
      if (this.isDomainSocket) {
        return cb(null, params.join(" "));
      }
      if (this.client_encoding) {
        params.push("client_encoding=" + quoteParamValue(this.client_encoding));
      }
      dns.lookup(this.host, function(err, address) {
        if (err)
          return cb(err, null);
        params.push("hostaddr=" + quoteParamValue(address));
        return cb(null, params.join(" "));
      });
    }
  }
  module.exports = ConnectionParameters;
});

// node_modules/pg/lib/result.js
var require_result = __commonJS((exports, module) => {
  var types = require_pg_types();
  var matchRegexp = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/;

  class Result {
    constructor(rowMode, types2) {
      this.command = null;
      this.rowCount = null;
      this.oid = null;
      this.rows = [];
      this.fields = [];
      this._parsers = undefined;
      this._types = types2;
      this.RowCtor = null;
      this.rowAsArray = rowMode === "array";
      if (this.rowAsArray) {
        this.parseRow = this._parseRowAsArray;
      }
      this._prebuiltEmptyResultObject = null;
    }
    addCommandComplete(msg) {
      let match;
      if (msg.text) {
        match = matchRegexp.exec(msg.text);
      } else {
        match = matchRegexp.exec(msg.command);
      }
      if (match) {
        this.command = match[1];
        if (match[3]) {
          this.oid = parseInt(match[2], 10);
          this.rowCount = parseInt(match[3], 10);
        } else if (match[2]) {
          this.rowCount = parseInt(match[2], 10);
        }
      }
    }
    _parseRowAsArray(rowData) {
      const row = new Array(rowData.length);
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        if (rawValue !== null) {
          row[i] = this._parsers[i](rawValue);
        } else {
          row[i] = null;
        }
      }
      return row;
    }
    parseRow(rowData) {
      const row = { ...this._prebuiltEmptyResultObject };
      for (let i = 0, len = rowData.length;i < len; i++) {
        const rawValue = rowData[i];
        const field = this.fields[i].name;
        if (rawValue !== null) {
          const v = this.fields[i].format === "binary" ? Buffer.from(rawValue) : rawValue;
          row[field] = this._parsers[i](v);
        } else {
          row[field] = null;
        }
      }
      return row;
    }
    addRow(row) {
      this.rows.push(row);
    }
    addFields(fieldDescriptions) {
      this.fields = fieldDescriptions;
      if (this.fields.length) {
        this._parsers = new Array(fieldDescriptions.length);
      }
      const row = {};
      for (let i = 0;i < fieldDescriptions.length; i++) {
        const desc = fieldDescriptions[i];
        row[desc.name] = null;
        if (this._types) {
          this._parsers[i] = this._types.getTypeParser(desc.dataTypeID, desc.format || "text");
        } else {
          this._parsers[i] = types.getTypeParser(desc.dataTypeID, desc.format || "text");
        }
      }
      this._prebuiltEmptyResultObject = { ...row };
    }
  }
  module.exports = Result;
});

// node_modules/pg/lib/query.js
var require_query = __commonJS((exports, module) => {
  var { EventEmitter: EventEmitter2 } = __require("events");
  var Result = require_result();
  var utils = require_utils2();

  class Query extends EventEmitter2 {
    constructor(config, values, callback) {
      super();
      config = utils.normalizeQueryConfig(config, values, callback);
      this.text = config.text;
      this.values = config.values;
      this.rows = config.rows;
      this.types = config.types;
      this.name = config.name;
      this.queryMode = config.queryMode;
      this.binary = config.binary;
      this.portal = config.portal || "";
      this.callback = config.callback;
      this._rowMode = config.rowMode;
      if (process.domain && config.callback) {
        this.callback = process.domain.bind(config.callback);
      }
      this._result = new Result(this._rowMode, this.types);
      this._results = this._result;
      this._canceledDueToError = false;
    }
    requiresPreparation() {
      if (this.queryMode === "extended") {
        return true;
      }
      if (this.name) {
        return true;
      }
      if (this.rows) {
        return true;
      }
      if (!this.text) {
        return false;
      }
      if (!this.values) {
        return false;
      }
      return this.values.length > 0;
    }
    _checkForMultirow() {
      if (this._result.command) {
        if (!Array.isArray(this._results)) {
          this._results = [this._result];
        }
        this._result = new Result(this._rowMode, this._result._types);
        this._results.push(this._result);
      }
    }
    handleRowDescription(msg) {
      this._checkForMultirow();
      this._result.addFields(msg.fields);
      this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(msg) {
      let row;
      if (this._canceledDueToError) {
        return;
      }
      try {
        row = this._result.parseRow(msg.fields);
      } catch (err) {
        this._canceledDueToError = err;
        return;
      }
      this.emit("row", row, this._result);
      if (this._accumulateRows) {
        this._result.addRow(row);
      }
    }
    handleCommandComplete(msg, connection) {
      this._checkForMultirow();
      this._result.addCommandComplete(msg);
      if (this.rows) {
        connection.sync();
      }
    }
    handleEmptyQuery(connection) {
      if (this.rows) {
        connection.sync();
      }
    }
    handleError(err, connection) {
      if (this._canceledDueToError) {
        err = this._canceledDueToError;
        this._canceledDueToError = false;
      }
      if (this.callback) {
        return this.callback(err);
      }
      this.emit("error", err);
    }
    handleReadyForQuery(con) {
      if (this._canceledDueToError) {
        return this.handleError(this._canceledDueToError, con);
      }
      if (this.callback) {
        try {
          this.callback(null, this._results);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
        }
      }
      this.emit("end", this._results);
    }
    submit(connection) {
      if (typeof this.text !== "string" && typeof this.name !== "string") {
        return new Error("A query must have either text or a name. Supplying neither is unsupported.");
      }
      const previous = connection.parsedStatements[this.name];
      if (this.text && previous && this.text !== previous) {
        return new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
      }
      if (this.values && !Array.isArray(this.values)) {
        return new Error("Query values must be an array");
      }
      if (this.requiresPreparation()) {
        connection.stream.cork && connection.stream.cork();
        try {
          this.prepare(connection);
        } finally {
          connection.stream.uncork && connection.stream.uncork();
        }
      } else {
        connection.query(this.text);
      }
      return null;
    }
    hasBeenParsed(connection) {
      return this.name && connection.parsedStatements[this.name];
    }
    handlePortalSuspended(connection) {
      this._getRows(connection, this.rows);
    }
    _getRows(connection, rows) {
      connection.execute({
        portal: this.portal,
        rows
      });
      if (!rows) {
        connection.sync();
      } else {
        connection.flush();
      }
    }
    prepare(connection) {
      if (!this.hasBeenParsed(connection)) {
        connection.parse({
          text: this.text,
          name: this.name,
          types: this.types
        });
      }
      try {
        connection.bind({
          portal: this.portal,
          statement: this.name,
          values: this.values,
          binary: this.binary,
          valueMapper: utils.prepareValue
        });
      } catch (err) {
        this.handleError(err, connection);
        return;
      }
      connection.describe({
        type: "P",
        name: this.portal || ""
      });
      this._getRows(connection, this.rows);
    }
    handleCopyInResponse(connection) {
      connection.sendCopyFail("No source stream defined");
    }
    handleCopyData(msg, connection) {}
  }
  module.exports = Query;
});

// node_modules/pg-protocol/dist/messages.js
var require_messages = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NoticeMessage = exports.DataRowMessage = exports.CommandCompleteMessage = exports.ReadyForQueryMessage = exports.NotificationResponseMessage = exports.BackendKeyDataMessage = exports.AuthenticationMD5Password = exports.ParameterStatusMessage = exports.ParameterDescriptionMessage = exports.RowDescriptionMessage = exports.Field = exports.CopyResponse = exports.CopyDataMessage = exports.DatabaseError = exports.copyDone = exports.emptyQuery = exports.replicationStart = exports.portalSuspended = exports.noData = exports.closeComplete = exports.bindComplete = exports.parseComplete = undefined;
  exports.parseComplete = {
    name: "parseComplete",
    length: 5
  };
  exports.bindComplete = {
    name: "bindComplete",
    length: 5
  };
  exports.closeComplete = {
    name: "closeComplete",
    length: 5
  };
  exports.noData = {
    name: "noData",
    length: 5
  };
  exports.portalSuspended = {
    name: "portalSuspended",
    length: 5
  };
  exports.replicationStart = {
    name: "replicationStart",
    length: 4
  };
  exports.emptyQuery = {
    name: "emptyQuery",
    length: 4
  };
  exports.copyDone = {
    name: "copyDone",
    length: 4
  };

  class DatabaseError extends Error {
    constructor(message, length, name) {
      super(message);
      this.length = length;
      this.name = name;
    }
  }
  exports.DatabaseError = DatabaseError;

  class CopyDataMessage {
    constructor(length, chunk) {
      this.length = length;
      this.chunk = chunk;
      this.name = "copyData";
    }
  }
  exports.CopyDataMessage = CopyDataMessage;

  class CopyResponse {
    constructor(length, name, binary, columnCount) {
      this.length = length;
      this.name = name;
      this.binary = binary;
      this.columnTypes = new Array(columnCount);
    }
  }
  exports.CopyResponse = CopyResponse;

  class Field {
    constructor(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, format) {
      this.name = name;
      this.tableID = tableID;
      this.columnID = columnID;
      this.dataTypeID = dataTypeID;
      this.dataTypeSize = dataTypeSize;
      this.dataTypeModifier = dataTypeModifier;
      this.format = format;
    }
  }
  exports.Field = Field;

  class RowDescriptionMessage {
    constructor(length, fieldCount) {
      this.length = length;
      this.fieldCount = fieldCount;
      this.name = "rowDescription";
      this.fields = new Array(this.fieldCount);
    }
  }
  exports.RowDescriptionMessage = RowDescriptionMessage;

  class ParameterDescriptionMessage {
    constructor(length, parameterCount) {
      this.length = length;
      this.parameterCount = parameterCount;
      this.name = "parameterDescription";
      this.dataTypeIDs = new Array(this.parameterCount);
    }
  }
  exports.ParameterDescriptionMessage = ParameterDescriptionMessage;

  class ParameterStatusMessage {
    constructor(length, parameterName, parameterValue) {
      this.length = length;
      this.parameterName = parameterName;
      this.parameterValue = parameterValue;
      this.name = "parameterStatus";
    }
  }
  exports.ParameterStatusMessage = ParameterStatusMessage;

  class AuthenticationMD5Password {
    constructor(length, salt) {
      this.length = length;
      this.salt = salt;
      this.name = "authenticationMD5Password";
    }
  }
  exports.AuthenticationMD5Password = AuthenticationMD5Password;

  class BackendKeyDataMessage {
    constructor(length, processID, secretKey) {
      this.length = length;
      this.processID = processID;
      this.secretKey = secretKey;
      this.name = "backendKeyData";
    }
  }
  exports.BackendKeyDataMessage = BackendKeyDataMessage;

  class NotificationResponseMessage {
    constructor(length, processId, channel, payload) {
      this.length = length;
      this.processId = processId;
      this.channel = channel;
      this.payload = payload;
      this.name = "notification";
    }
  }
  exports.NotificationResponseMessage = NotificationResponseMessage;

  class ReadyForQueryMessage {
    constructor(length, status) {
      this.length = length;
      this.status = status;
      this.name = "readyForQuery";
    }
  }
  exports.ReadyForQueryMessage = ReadyForQueryMessage;

  class CommandCompleteMessage {
    constructor(length, text) {
      this.length = length;
      this.text = text;
      this.name = "commandComplete";
    }
  }
  exports.CommandCompleteMessage = CommandCompleteMessage;

  class DataRowMessage {
    constructor(length, fields) {
      this.length = length;
      this.fields = fields;
      this.name = "dataRow";
      this.fieldCount = fields.length;
    }
  }
  exports.DataRowMessage = DataRowMessage;

  class NoticeMessage {
    constructor(length, message) {
      this.length = length;
      this.message = message;
      this.name = "notice";
    }
  }
  exports.NoticeMessage = NoticeMessage;
});

// node_modules/pg-protocol/dist/buffer-writer.js
var require_buffer_writer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Writer = undefined;

  class Writer {
    constructor(size = 256) {
      this.size = size;
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(size);
    }
    ensure(size) {
      const remaining = this.buffer.length - this.offset;
      if (remaining < size) {
        const oldBuffer = this.buffer;
        const newSize = oldBuffer.length + (oldBuffer.length >> 1) + size;
        this.buffer = Buffer.allocUnsafe(newSize);
        oldBuffer.copy(this.buffer);
      }
    }
    addInt32(num) {
      this.ensure(4);
      this.buffer[this.offset++] = num >>> 24 & 255;
      this.buffer[this.offset++] = num >>> 16 & 255;
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addInt16(num) {
      this.ensure(2);
      this.buffer[this.offset++] = num >>> 8 & 255;
      this.buffer[this.offset++] = num >>> 0 & 255;
      return this;
    }
    addCString(string3) {
      if (!string3) {
        this.ensure(1);
      } else {
        const len = Buffer.byteLength(string3);
        this.ensure(len + 1);
        this.buffer.write(string3, this.offset, "utf-8");
        this.offset += len;
      }
      this.buffer[this.offset++] = 0;
      return this;
    }
    addString(string3 = "") {
      const len = Buffer.byteLength(string3);
      this.ensure(len);
      this.buffer.write(string3, this.offset);
      this.offset += len;
      return this;
    }
    add(otherBuffer) {
      this.ensure(otherBuffer.length);
      otherBuffer.copy(this.buffer, this.offset);
      this.offset += otherBuffer.length;
      return this;
    }
    join(code) {
      if (code) {
        this.buffer[this.headerPosition] = code;
        const length = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(length, this.headerPosition + 1);
      }
      return this.buffer.slice(code ? 0 : 5, this.offset);
    }
    flush(code) {
      const result = this.join(code);
      this.offset = 5;
      this.headerPosition = 0;
      this.buffer = Buffer.allocUnsafe(this.size);
      return result;
    }
  }
  exports.Writer = Writer;
});

// node_modules/pg-protocol/dist/serializer.js
var require_serializer = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.serialize = undefined;
  var buffer_writer_1 = require_buffer_writer();
  var writer = new buffer_writer_1.Writer;
  var startup = (opts) => {
    writer.addInt16(3).addInt16(0);
    for (const key of Object.keys(opts)) {
      writer.addCString(key).addCString(opts[key]);
    }
    writer.addCString("client_encoding").addCString("UTF8");
    const bodyBuffer = writer.addCString("").flush();
    const length = bodyBuffer.length + 4;
    return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();
  };
  var requestSsl = () => {
    const response = Buffer.allocUnsafe(8);
    response.writeInt32BE(8, 0);
    response.writeInt32BE(80877103, 4);
    return response;
  };
  var password = (password2) => {
    return writer.addCString(password2).flush(112);
  };
  var sendSASLInitialResponseMessage = function(mechanism, initialResponse) {
    writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);
    return writer.flush(112);
  };
  var sendSCRAMClientFinalMessage = function(additionalData) {
    return writer.addString(additionalData).flush(112);
  };
  var query = (text) => {
    return writer.addCString(text).flush(81);
  };
  var emptyArray = [];
  var parse3 = (query2) => {
    const name = query2.name || "";
    if (name.length > 63) {
      console.error("Warning! Postgres only supports 63 characters for query names.");
      console.error("You supplied %s (%s)", name, name.length);
      console.error("This can cause conflicts and silent errors executing queries");
    }
    const types = query2.types || emptyArray;
    const len = types.length;
    const buffer = writer.addCString(name).addCString(query2.text).addInt16(len);
    for (let i = 0;i < len; i++) {
      buffer.addInt32(types[i]);
    }
    return writer.flush(80);
  };
  var paramWriter = new buffer_writer_1.Writer;
  var writeValues = function(values, valueMapper) {
    for (let i = 0;i < values.length; i++) {
      const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];
      if (mappedVal == null) {
        writer.addInt16(0);
        paramWriter.addInt32(-1);
      } else if (mappedVal instanceof Buffer) {
        writer.addInt16(1);
        paramWriter.addInt32(mappedVal.length);
        paramWriter.add(mappedVal);
      } else {
        writer.addInt16(0);
        paramWriter.addInt32(Buffer.byteLength(mappedVal));
        paramWriter.addString(mappedVal);
      }
    }
  };
  var bind = (config = {}) => {
    const portal = config.portal || "";
    const statement = config.statement || "";
    const binary = config.binary || false;
    const values = config.values || emptyArray;
    const len = values.length;
    writer.addCString(portal).addCString(statement);
    writer.addInt16(len);
    writeValues(values, config.valueMapper);
    writer.addInt16(len);
    writer.add(paramWriter.flush());
    writer.addInt16(1);
    writer.addInt16(binary ? 1 : 0);
    return writer.flush(66);
  };
  var emptyExecute = Buffer.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]);
  var execute = (config) => {
    if (!config || !config.portal && !config.rows) {
      return emptyExecute;
    }
    const portal = config.portal || "";
    const rows = config.rows || 0;
    const portalLength = Buffer.byteLength(portal);
    const len = 4 + portalLength + 1 + 4;
    const buff = Buffer.allocUnsafe(1 + len);
    buff[0] = 69;
    buff.writeInt32BE(len, 1);
    buff.write(portal, 5, "utf-8");
    buff[portalLength + 5] = 0;
    buff.writeUInt32BE(rows, buff.length - 4);
    return buff;
  };
  var cancel = (processID, secretKey) => {
    const buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32BE(16, 0);
    buffer.writeInt16BE(1234, 4);
    buffer.writeInt16BE(5678, 6);
    buffer.writeInt32BE(processID, 8);
    buffer.writeInt32BE(secretKey, 12);
    return buffer;
  };
  var cstringMessage = (code, string3) => {
    const stringLen = Buffer.byteLength(string3);
    const len = 4 + stringLen + 1;
    const buffer = Buffer.allocUnsafe(1 + len);
    buffer[0] = code;
    buffer.writeInt32BE(len, 1);
    buffer.write(string3, 5, "utf-8");
    buffer[len] = 0;
    return buffer;
  };
  var emptyDescribePortal = writer.addCString("P").flush(68);
  var emptyDescribeStatement = writer.addCString("S").flush(68);
  var describe = (msg) => {
    return msg.name ? cstringMessage(68, `${msg.type}${msg.name || ""}`) : msg.type === "P" ? emptyDescribePortal : emptyDescribeStatement;
  };
  var close = (msg) => {
    const text = `${msg.type}${msg.name || ""}`;
    return cstringMessage(67, text);
  };
  var copyData = (chunk) => {
    return writer.add(chunk).flush(100);
  };
  var copyFail = (message) => {
    return cstringMessage(102, message);
  };
  var codeOnlyBuffer = (code) => Buffer.from([code, 0, 0, 0, 4]);
  var flushBuffer = codeOnlyBuffer(72);
  var syncBuffer = codeOnlyBuffer(83);
  var endBuffer = codeOnlyBuffer(88);
  var copyDoneBuffer = codeOnlyBuffer(99);
  var serialize2 = {
    startup,
    password,
    requestSsl,
    sendSASLInitialResponseMessage,
    sendSCRAMClientFinalMessage,
    query,
    parse: parse3,
    bind,
    execute,
    describe,
    close,
    flush: () => flushBuffer,
    sync: () => syncBuffer,
    end: () => endBuffer,
    copyData,
    copyDone: () => copyDoneBuffer,
    copyFail,
    cancel
  };
  exports.serialize = serialize2;
});

// node_modules/pg-protocol/dist/buffer-reader.js
var require_buffer_reader = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BufferReader = undefined;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class BufferReader {
    constructor(offset = 0) {
      this.offset = offset;
      this.buffer = emptyBuffer;
      this.encoding = "utf-8";
    }
    setBuffer(offset, buffer) {
      this.offset = offset;
      this.buffer = buffer;
    }
    int16() {
      const result = this.buffer.readInt16BE(this.offset);
      this.offset += 2;
      return result;
    }
    byte() {
      const result = this.buffer[this.offset];
      this.offset++;
      return result;
    }
    int32() {
      const result = this.buffer.readInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    uint32() {
      const result = this.buffer.readUInt32BE(this.offset);
      this.offset += 4;
      return result;
    }
    string(length) {
      const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
    cstring() {
      const start = this.offset;
      let end = start;
      while (this.buffer[end++] !== 0) {}
      this.offset = end;
      return this.buffer.toString(this.encoding, start, end - 1);
    }
    bytes(length) {
      const result = this.buffer.slice(this.offset, this.offset + length);
      this.offset += length;
      return result;
    }
  }
  exports.BufferReader = BufferReader;
});

// node_modules/pg-protocol/dist/parser.js
var require_parser = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Parser = undefined;
  var messages_1 = require_messages();
  var buffer_reader_1 = require_buffer_reader();
  var CODE_LENGTH = 1;
  var LEN_LENGTH = 4;
  var HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;
  var emptyBuffer = Buffer.allocUnsafe(0);

  class Parser {
    constructor(opts) {
      this.buffer = emptyBuffer;
      this.bufferLength = 0;
      this.bufferOffset = 0;
      this.reader = new buffer_reader_1.BufferReader;
      if ((opts === null || opts === undefined ? undefined : opts.mode) === "binary") {
        throw new Error("Binary mode not supported yet");
      }
      this.mode = (opts === null || opts === undefined ? undefined : opts.mode) || "text";
    }
    parse(buffer, callback) {
      this.mergeBuffer(buffer);
      const bufferFullLength = this.bufferOffset + this.bufferLength;
      let offset = this.bufferOffset;
      while (offset + HEADER_LENGTH <= bufferFullLength) {
        const code = this.buffer[offset];
        const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);
        const fullMessageLength = CODE_LENGTH + length;
        if (fullMessageLength + offset <= bufferFullLength) {
          const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);
          callback(message);
          offset += fullMessageLength;
        } else {
          break;
        }
      }
      if (offset === bufferFullLength) {
        this.buffer = emptyBuffer;
        this.bufferLength = 0;
        this.bufferOffset = 0;
      } else {
        this.bufferLength = bufferFullLength - offset;
        this.bufferOffset = offset;
      }
    }
    mergeBuffer(buffer) {
      if (this.bufferLength > 0) {
        const newLength = this.bufferLength + buffer.byteLength;
        const newFullLength = newLength + this.bufferOffset;
        if (newFullLength > this.buffer.byteLength) {
          let newBuffer;
          if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {
            newBuffer = this.buffer;
          } else {
            let newBufferLength = this.buffer.byteLength * 2;
            while (newLength >= newBufferLength) {
              newBufferLength *= 2;
            }
            newBuffer = Buffer.allocUnsafe(newBufferLength);
          }
          this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);
          this.buffer = newBuffer;
          this.bufferOffset = 0;
        }
        buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);
        this.bufferLength = newLength;
      } else {
        this.buffer = buffer;
        this.bufferOffset = 0;
        this.bufferLength = buffer.byteLength;
      }
    }
    handlePacket(offset, code, length, bytes) {
      switch (code) {
        case 50:
          return messages_1.bindComplete;
        case 49:
          return messages_1.parseComplete;
        case 51:
          return messages_1.closeComplete;
        case 110:
          return messages_1.noData;
        case 115:
          return messages_1.portalSuspended;
        case 99:
          return messages_1.copyDone;
        case 87:
          return messages_1.replicationStart;
        case 73:
          return messages_1.emptyQuery;
        case 68:
          return this.parseDataRowMessage(offset, length, bytes);
        case 67:
          return this.parseCommandCompleteMessage(offset, length, bytes);
        case 90:
          return this.parseReadyForQueryMessage(offset, length, bytes);
        case 65:
          return this.parseNotificationMessage(offset, length, bytes);
        case 82:
          return this.parseAuthenticationResponse(offset, length, bytes);
        case 83:
          return this.parseParameterStatusMessage(offset, length, bytes);
        case 75:
          return this.parseBackendKeyData(offset, length, bytes);
        case 69:
          return this.parseErrorMessage(offset, length, bytes, "error");
        case 78:
          return this.parseErrorMessage(offset, length, bytes, "notice");
        case 84:
          return this.parseRowDescriptionMessage(offset, length, bytes);
        case 116:
          return this.parseParameterDescriptionMessage(offset, length, bytes);
        case 71:
          return this.parseCopyInMessage(offset, length, bytes);
        case 72:
          return this.parseCopyOutMessage(offset, length, bytes);
        case 100:
          return this.parseCopyData(offset, length, bytes);
        default:
          return new messages_1.DatabaseError("received invalid response: " + code.toString(16), length, "error");
      }
    }
    parseReadyForQueryMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const status = this.reader.string(1);
      return new messages_1.ReadyForQueryMessage(length, status);
    }
    parseCommandCompleteMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const text = this.reader.cstring();
      return new messages_1.CommandCompleteMessage(length, text);
    }
    parseCopyData(offset, length, bytes) {
      const chunk = bytes.slice(offset, offset + (length - 4));
      return new messages_1.CopyDataMessage(length, chunk);
    }
    parseCopyInMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyInResponse");
    }
    parseCopyOutMessage(offset, length, bytes) {
      return this.parseCopyMessage(offset, length, bytes, "copyOutResponse");
    }
    parseCopyMessage(offset, length, bytes, messageName) {
      this.reader.setBuffer(offset, bytes);
      const isBinary = this.reader.byte() !== 0;
      const columnCount = this.reader.int16();
      const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);
      for (let i = 0;i < columnCount; i++) {
        message.columnTypes[i] = this.reader.int16();
      }
      return message;
    }
    parseNotificationMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processId = this.reader.int32();
      const channel = this.reader.cstring();
      const payload = this.reader.cstring();
      return new messages_1.NotificationResponseMessage(length, processId, channel, payload);
    }
    parseRowDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const message = new messages_1.RowDescriptionMessage(length, fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        message.fields[i] = this.parseField();
      }
      return message;
    }
    parseField() {
      const name = this.reader.cstring();
      const tableID = this.reader.uint32();
      const columnID = this.reader.int16();
      const dataTypeID = this.reader.uint32();
      const dataTypeSize = this.reader.int16();
      const dataTypeModifier = this.reader.int32();
      const mode = this.reader.int16() === 0 ? "text" : "binary";
      return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);
    }
    parseParameterDescriptionMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const parameterCount = this.reader.int16();
      const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);
      for (let i = 0;i < parameterCount; i++) {
        message.dataTypeIDs[i] = this.reader.int32();
      }
      return message;
    }
    parseDataRowMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const fieldCount = this.reader.int16();
      const fields = new Array(fieldCount);
      for (let i = 0;i < fieldCount; i++) {
        const len = this.reader.int32();
        fields[i] = len === -1 ? null : this.reader.string(len);
      }
      return new messages_1.DataRowMessage(length, fields);
    }
    parseParameterStatusMessage(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const name = this.reader.cstring();
      const value2 = this.reader.cstring();
      return new messages_1.ParameterStatusMessage(length, name, value2);
    }
    parseBackendKeyData(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const processID = this.reader.int32();
      const secretKey = this.reader.int32();
      return new messages_1.BackendKeyDataMessage(length, processID, secretKey);
    }
    parseAuthenticationResponse(offset, length, bytes) {
      this.reader.setBuffer(offset, bytes);
      const code = this.reader.int32();
      const message = {
        name: "authenticationOk",
        length
      };
      switch (code) {
        case 0:
          break;
        case 3:
          if (message.length === 8) {
            message.name = "authenticationCleartextPassword";
          }
          break;
        case 5:
          if (message.length === 12) {
            message.name = "authenticationMD5Password";
            const salt = this.reader.bytes(4);
            return new messages_1.AuthenticationMD5Password(length, salt);
          }
          break;
        case 10:
          {
            message.name = "authenticationSASL";
            message.mechanisms = [];
            let mechanism;
            do {
              mechanism = this.reader.cstring();
              if (mechanism) {
                message.mechanisms.push(mechanism);
              }
            } while (mechanism);
          }
          break;
        case 11:
          message.name = "authenticationSASLContinue";
          message.data = this.reader.string(length - 8);
          break;
        case 12:
          message.name = "authenticationSASLFinal";
          message.data = this.reader.string(length - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + code);
      }
      return message;
    }
    parseErrorMessage(offset, length, bytes, name) {
      this.reader.setBuffer(offset, bytes);
      const fields = {};
      let fieldType = this.reader.string(1);
      while (fieldType !== "\x00") {
        fields[fieldType] = this.reader.cstring();
        fieldType = this.reader.string(1);
      }
      const messageValue = fields.M;
      const message = name === "notice" ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);
      message.severity = fields.S;
      message.code = fields.C;
      message.detail = fields.D;
      message.hint = fields.H;
      message.position = fields.P;
      message.internalPosition = fields.p;
      message.internalQuery = fields.q;
      message.where = fields.W;
      message.schema = fields.s;
      message.table = fields.t;
      message.column = fields.c;
      message.dataType = fields.d;
      message.constraint = fields.n;
      message.file = fields.F;
      message.line = fields.L;
      message.routine = fields.R;
      return message;
    }
  }
  exports.Parser = Parser;
});

// node_modules/pg-protocol/dist/index.js
var require_dist = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DatabaseError = exports.serialize = exports.parse = undefined;
  var messages_1 = require_messages();
  Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
    return messages_1.DatabaseError;
  } });
  var serializer_1 = require_serializer();
  Object.defineProperty(exports, "serialize", { enumerable: true, get: function() {
    return serializer_1.serialize;
  } });
  var parser_1 = require_parser();
  function parse3(stream, callback) {
    const parser = new parser_1.Parser;
    stream.on("data", (buffer) => parser.parse(buffer, callback));
    return new Promise((resolve) => stream.on("end", () => resolve()));
  }
  exports.parse = parse3;
});

// node_modules/pg-cloudflare/dist/empty.js
var require_empty = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = {};
});

// node_modules/pg/lib/stream.js
var require_stream = __commonJS((exports, module) => {
  var { getStream, getSecureStream } = getStreamFuncs();
  module.exports = {
    getStream,
    getSecureStream
  };
  function getNodejsStreamFuncs() {
    function getStream2(ssl) {
      const net = __require("net");
      return new net.Socket;
    }
    function getSecureStream2(options) {
      const tls = __require("tls");
      return tls.connect(options);
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function getCloudflareStreamFuncs() {
    function getStream2(ssl) {
      const { CloudflareSocket } = require_empty();
      return new CloudflareSocket(ssl);
    }
    function getSecureStream2(options) {
      options.socket.startTls(options);
      return options.socket;
    }
    return {
      getStream: getStream2,
      getSecureStream: getSecureStream2
    };
  }
  function isCloudflareRuntime() {
    if (typeof navigator === "object" && navigator !== null && typeof navigator.userAgent === "string") {
      return navigator.userAgent === "Cloudflare-Workers";
    }
    if (typeof Response === "function") {
      const resp = new Response(null, { cf: { thing: true } });
      if (typeof resp.cf === "object" && resp.cf !== null && resp.cf.thing) {
        return true;
      }
    }
    return false;
  }
  function getStreamFuncs() {
    if (isCloudflareRuntime()) {
      return getCloudflareStreamFuncs();
    }
    return getNodejsStreamFuncs();
  }
});

// node_modules/pg/lib/connection.js
var require_connection = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var { parse: parse3, serialize: serialize2 } = require_dist();
  var { getStream, getSecureStream } = require_stream();
  var flushBuffer = serialize2.flush();
  var syncBuffer = serialize2.sync();
  var endBuffer = serialize2.end();

  class Connection extends EventEmitter2 {
    constructor(config) {
      super();
      config = config || {};
      this.stream = config.stream || getStream(config.ssl);
      if (typeof this.stream === "function") {
        this.stream = this.stream(config);
      }
      this._keepAlive = config.keepAlive;
      this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;
      this.lastBuffer = false;
      this.parsedStatements = {};
      this.ssl = config.ssl || false;
      this._ending = false;
      this._emitMessage = false;
      const self2 = this;
      this.on("newListener", function(eventName) {
        if (eventName === "message") {
          self2._emitMessage = true;
        }
      });
    }
    connect(port, host) {
      const self2 = this;
      this._connecting = true;
      this.stream.setNoDelay(true);
      this.stream.connect(port, host);
      this.stream.once("connect", function() {
        if (self2._keepAlive) {
          self2.stream.setKeepAlive(true, self2._keepAliveInitialDelayMillis);
        }
        self2.emit("connect");
      });
      const reportStreamError = function(error3) {
        if (self2._ending && (error3.code === "ECONNRESET" || error3.code === "EPIPE")) {
          return;
        }
        self2.emit("error", error3);
      };
      this.stream.on("error", reportStreamError);
      this.stream.on("close", function() {
        self2.emit("end");
      });
      if (!this.ssl) {
        return this.attachListeners(this.stream);
      }
      this.stream.once("data", function(buffer) {
        const responseCode = buffer.toString("utf8");
        switch (responseCode) {
          case "S":
            break;
          case "N":
            self2.stream.end();
            return self2.emit("error", new Error("The server does not support SSL connections"));
          default:
            self2.stream.end();
            return self2.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        const options = {
          socket: self2.stream
        };
        if (self2.ssl !== true) {
          Object.assign(options, self2.ssl);
          if ("key" in self2.ssl) {
            options.key = self2.ssl.key;
          }
        }
        const net = __require("net");
        if (net.isIP && net.isIP(host) === 0) {
          options.servername = host;
        }
        try {
          self2.stream = getSecureStream(options);
        } catch (err) {
          return self2.emit("error", err);
        }
        self2.attachListeners(self2.stream);
        self2.stream.on("error", reportStreamError);
        self2.emit("sslconnect");
      });
    }
    attachListeners(stream) {
      parse3(stream, (msg) => {
        const eventName = msg.name === "error" ? "errorMessage" : msg.name;
        if (this._emitMessage) {
          this.emit("message", msg);
        }
        this.emit(eventName, msg);
      });
    }
    requestSsl() {
      this.stream.write(serialize2.requestSsl());
    }
    startup(config) {
      this.stream.write(serialize2.startup(config));
    }
    cancel(processID, secretKey) {
      this._send(serialize2.cancel(processID, secretKey));
    }
    password(password) {
      this._send(serialize2.password(password));
    }
    sendSASLInitialResponseMessage(mechanism, initialResponse) {
      this._send(serialize2.sendSASLInitialResponseMessage(mechanism, initialResponse));
    }
    sendSCRAMClientFinalMessage(additionalData) {
      this._send(serialize2.sendSCRAMClientFinalMessage(additionalData));
    }
    _send(buffer) {
      if (!this.stream.writable) {
        return false;
      }
      return this.stream.write(buffer);
    }
    query(text) {
      this._send(serialize2.query(text));
    }
    parse(query) {
      this._send(serialize2.parse(query));
    }
    bind(config) {
      this._send(serialize2.bind(config));
    }
    execute(config) {
      this._send(serialize2.execute(config));
    }
    flush() {
      if (this.stream.writable) {
        this.stream.write(flushBuffer);
      }
    }
    sync() {
      this._ending = true;
      this._send(syncBuffer);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      this._ending = true;
      if (!this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(endBuffer, () => {
        this.stream.end();
      });
    }
    close(msg) {
      this._send(serialize2.close(msg));
    }
    describe(msg) {
      this._send(serialize2.describe(msg));
    }
    sendCopyFromChunk(chunk) {
      this._send(serialize2.copyData(chunk));
    }
    endCopyFrom() {
      this._send(serialize2.copyDone());
    }
    sendCopyFail(msg) {
      this._send(serialize2.copyFail(msg));
    }
  }
  module.exports = Connection;
});

// node_modules/split2/index.js
var require_split2 = __commonJS((exports, module) => {
  var { Transform: Transform2 } = __require("stream");
  var { StringDecoder } = __require("string_decoder");
  var kLast = Symbol("last");
  var kDecoder = Symbol("decoder");
  function transform4(chunk, enc, cb) {
    let list;
    if (this.overflow) {
      const buf = this[kDecoder].write(chunk);
      list = buf.split(this.matcher);
      if (list.length === 1)
        return cb();
      list.shift();
      this.overflow = false;
    } else {
      this[kLast] += this[kDecoder].write(chunk);
      list = this[kLast].split(this.matcher);
    }
    this[kLast] = list.pop();
    for (let i = 0;i < list.length; i++) {
      try {
        push(this, this.mapper(list[i]));
      } catch (error3) {
        return cb(error3);
      }
    }
    this.overflow = this[kLast].length > this.maxLength;
    if (this.overflow && !this.skipOverflow) {
      cb(new Error("maximum buffer reached"));
      return;
    }
    cb();
  }
  function flush(cb) {
    this[kLast] += this[kDecoder].end();
    if (this[kLast]) {
      try {
        push(this, this.mapper(this[kLast]));
      } catch (error3) {
        return cb(error3);
      }
    }
    cb();
  }
  function push(self2, val) {
    if (val !== undefined) {
      self2.push(val);
    }
  }
  function noop(incoming) {
    return incoming;
  }
  function split(matcher, mapper, options) {
    matcher = matcher || /\r?\n/;
    mapper = mapper || noop;
    options = options || {};
    switch (arguments.length) {
      case 1:
        if (typeof matcher === "function") {
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof matcher === "object" && !(matcher instanceof RegExp) && !matcher[Symbol.split]) {
          options = matcher;
          matcher = /\r?\n/;
        }
        break;
      case 2:
        if (typeof matcher === "function") {
          options = mapper;
          mapper = matcher;
          matcher = /\r?\n/;
        } else if (typeof mapper === "object") {
          options = mapper;
          mapper = noop;
        }
    }
    options = Object.assign({}, options);
    options.autoDestroy = true;
    options.transform = transform4;
    options.flush = flush;
    options.readableObjectMode = true;
    const stream = new Transform2(options);
    stream[kLast] = "";
    stream[kDecoder] = new StringDecoder("utf8");
    stream.matcher = matcher;
    stream.mapper = mapper;
    stream.maxLength = options.maxLength;
    stream.skipOverflow = options.skipOverflow || false;
    stream.overflow = false;
    stream._destroy = function(err, cb) {
      this._writableState.errorEmitted = false;
      cb(err);
    };
    return stream;
  }
  module.exports = split;
});

// node_modules/pgpass/lib/helper.js
var require_helper = __commonJS((exports, module) => {
  var path = __require("path");
  var Stream = __require("stream").Stream;
  var split = require_split2();
  var util = __require("util");
  var defaultPort = 5432;
  var isWin = process.platform === "win32";
  var warnStream = process.stderr;
  var S_IRWXG = 56;
  var S_IRWXO = 7;
  var S_IFMT = 61440;
  var S_IFREG = 32768;
  function isRegFile(mode) {
    return (mode & S_IFMT) == S_IFREG;
  }
  var fieldNames = ["host", "port", "database", "user", "password"];
  var nrOfFields = fieldNames.length;
  var passKey = fieldNames[nrOfFields - 1];
  function warn() {
    var isWritable = warnStream instanceof Stream && warnStream.writable === true;
    if (isWritable) {
      var args = Array.prototype.slice.call(arguments).concat(`
`);
      warnStream.write(util.format.apply(util, args));
    }
  }
  Object.defineProperty(exports, "isWin", {
    get: function() {
      return isWin;
    },
    set: function(val) {
      isWin = val;
    }
  });
  exports.warnTo = function(stream) {
    var old = warnStream;
    warnStream = stream;
    return old;
  };
  exports.getFileName = function(rawEnv) {
    var env2 = rawEnv || process.env;
    var file = env2.PGPASSFILE || (isWin ? path.join(env2.APPDATA || "./", "postgresql", "pgpass.conf") : path.join(env2.HOME || "./", ".pgpass"));
    return file;
  };
  exports.usePgPass = function(stats, fname) {
    if (Object.prototype.hasOwnProperty.call(process.env, "PGPASSWORD")) {
      return false;
    }
    if (isWin) {
      return true;
    }
    fname = fname || "<unkn>";
    if (!isRegFile(stats.mode)) {
      warn('WARNING: password file "%s" is not a plain file', fname);
      return false;
    }
    if (stats.mode & (S_IRWXG | S_IRWXO)) {
      warn('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', fname);
      return false;
    }
    return true;
  };
  var matcher = exports.match = function(connInfo, entry) {
    return fieldNames.slice(0, -1).reduce(function(prev, field, idx) {
      if (idx == 1) {
        if (Number(connInfo[field] || defaultPort) === Number(entry[field])) {
          return prev && true;
        }
      }
      return prev && (entry[field] === "*" || entry[field] === connInfo[field]);
    }, true);
  };
  exports.getPassword = function(connInfo, stream, cb) {
    var pass;
    var lineStream = stream.pipe(split());
    function onLine(line) {
      var entry = parseLine(line);
      if (entry && isValidEntry(entry) && matcher(connInfo, entry)) {
        pass = entry[passKey];
        lineStream.end();
      }
    }
    var onEnd = function() {
      stream.destroy();
      cb(pass);
    };
    var onErr = function(err) {
      stream.destroy();
      warn("WARNING: error on reading file: %s", err);
      cb(undefined);
    };
    stream.on("error", onErr);
    lineStream.on("data", onLine).on("end", onEnd).on("error", onErr);
  };
  var parseLine = exports.parseLine = function(line) {
    if (line.length < 11 || line.match(/^\s+#/)) {
      return null;
    }
    var curChar = "";
    var prevChar = "";
    var fieldIdx = 0;
    var startIdx = 0;
    var endIdx = 0;
    var obj = {};
    var isLastField = false;
    var addToObj = function(idx, i0, i1) {
      var field = line.substring(i0, i1);
      if (!Object.hasOwnProperty.call(process.env, "PGPASS_NO_DEESCAPE")) {
        field = field.replace(/\\([:\\])/g, "$1");
      }
      obj[fieldNames[idx]] = field;
    };
    for (var i = 0;i < line.length - 1; i += 1) {
      curChar = line.charAt(i + 1);
      prevChar = line.charAt(i);
      isLastField = fieldIdx == nrOfFields - 1;
      if (isLastField) {
        addToObj(fieldIdx, startIdx);
        break;
      }
      if (i >= 0 && curChar == ":" && prevChar !== "\\") {
        addToObj(fieldIdx, startIdx, i + 1);
        startIdx = i + 2;
        fieldIdx += 1;
      }
    }
    obj = Object.keys(obj).length === nrOfFields ? obj : null;
    return obj;
  };
  var isValidEntry = exports.isValidEntry = function(entry) {
    var rules = {
      0: function(x) {
        return x.length > 0;
      },
      1: function(x) {
        if (x === "*") {
          return true;
        }
        x = Number(x);
        return isFinite(x) && x > 0 && x < 9007199254740992 && Math.floor(x) === x;
      },
      2: function(x) {
        return x.length > 0;
      },
      3: function(x) {
        return x.length > 0;
      },
      4: function(x) {
        return x.length > 0;
      }
    };
    for (var idx = 0;idx < fieldNames.length; idx += 1) {
      var rule = rules[idx];
      var value2 = entry[fieldNames[idx]] || "";
      var res = rule(value2);
      if (!res) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/pgpass/lib/index.js
var require_lib2 = __commonJS((exports, module) => {
  var path = __require("path");
  var fs = __require("fs");
  var helper = require_helper();
  module.exports = function(connInfo, cb) {
    var file = helper.getFileName();
    fs.stat(file, function(err, stat) {
      if (err || !helper.usePgPass(stat, file)) {
        return cb(undefined);
      }
      var st = fs.createReadStream(file);
      helper.getPassword(connInfo, st, cb);
    });
  };
  module.exports.warnTo = helper.warnTo;
});

// node_modules/pg/lib/client.js
var require_client = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var utils = require_utils2();
  var sasl = require_sasl();
  var TypeOverrides = require_type_overrides();
  var ConnectionParameters = require_connection_parameters();
  var Query = require_query();
  var defaults = require_defaults();
  var Connection = require_connection();
  var crypto2 = require_utils3();

  class Client extends EventEmitter2 {
    constructor(config) {
      super();
      this.connectionParameters = new ConnectionParameters(config);
      this.user = this.connectionParameters.user;
      this.database = this.connectionParameters.database;
      this.port = this.connectionParameters.port;
      this.host = this.connectionParameters.host;
      Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: this.connectionParameters.password
      });
      this.replication = this.connectionParameters.replication;
      const c = config || {};
      this._Promise = c.Promise || global.Promise;
      this._types = new TypeOverrides(c.types);
      this._ending = false;
      this._ended = false;
      this._connecting = false;
      this._connected = false;
      this._connectionError = false;
      this._queryable = true;
      this.enableChannelBinding = Boolean(c.enableChannelBinding);
      this.connection = c.connection || new Connection({
        stream: c.stream,
        ssl: this.connectionParameters.ssl,
        keepAlive: c.keepAlive || false,
        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,
        encoding: this.connectionParameters.client_encoding || "utf8"
      });
      this.queryQueue = [];
      this.binary = c.binary || defaults.binary;
      this.processID = null;
      this.secretKey = null;
      this.ssl = this.connectionParameters.ssl || false;
      if (this.ssl && this.ssl.key) {
        Object.defineProperty(this.ssl, "key", {
          enumerable: false
        });
      }
      this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(err) {
      const enqueueError = (query) => {
        process.nextTick(() => {
          query.handleError(err, this.connection);
        });
      };
      if (this.activeQuery) {
        enqueueError(this.activeQuery);
        this.activeQuery = null;
      }
      this.queryQueue.forEach(enqueueError);
      this.queryQueue.length = 0;
    }
    _connect(callback) {
      const self2 = this;
      const con = this.connection;
      this._connectionCallback = callback;
      if (this._connecting || this._connected) {
        const err = new Error("Client has already been connected. You cannot reuse a client.");
        process.nextTick(() => {
          callback(err);
        });
        return;
      }
      this._connecting = true;
      if (this._connectionTimeoutMillis > 0) {
        this.connectionTimeoutHandle = setTimeout(() => {
          con._ending = true;
          con.stream.destroy(new Error("timeout expired"));
        }, this._connectionTimeoutMillis);
        if (this.connectionTimeoutHandle.unref) {
          this.connectionTimeoutHandle.unref();
        }
      }
      if (this.host && this.host.indexOf("/") === 0) {
        con.connect(this.host + "/.s.PGSQL." + this.port);
      } else {
        con.connect(this.port, this.host);
      }
      con.on("connect", function() {
        if (self2.ssl) {
          con.requestSsl();
        } else {
          con.startup(self2.getStartupConf());
        }
      });
      con.on("sslconnect", function() {
        con.startup(self2.getStartupConf());
      });
      this._attachListeners(con);
      con.once("end", () => {
        const error3 = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle);
        this._errorAllQueries(error3);
        this._ended = true;
        if (!this._ending) {
          if (this._connecting && !this._connectionError) {
            if (this._connectionCallback) {
              this._connectionCallback(error3);
            } else {
              this._handleErrorEvent(error3);
            }
          } else if (!this._connectionError) {
            this._handleErrorEvent(error3);
          }
        }
        process.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(callback) {
      if (callback) {
        this._connect(callback);
        return;
      }
      return new this._Promise((resolve, reject) => {
        this._connect((error3) => {
          if (error3) {
            reject(error3);
          } else {
            resolve();
          }
        });
      });
    }
    _attachListeners(con) {
      con.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this));
      con.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this));
      con.on("authenticationSASL", this._handleAuthSASL.bind(this));
      con.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this));
      con.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this));
      con.on("backendKeyData", this._handleBackendKeyData.bind(this));
      con.on("error", this._handleErrorEvent.bind(this));
      con.on("errorMessage", this._handleErrorMessage.bind(this));
      con.on("readyForQuery", this._handleReadyForQuery.bind(this));
      con.on("notice", this._handleNotice.bind(this));
      con.on("rowDescription", this._handleRowDescription.bind(this));
      con.on("dataRow", this._handleDataRow.bind(this));
      con.on("portalSuspended", this._handlePortalSuspended.bind(this));
      con.on("emptyQuery", this._handleEmptyQuery.bind(this));
      con.on("commandComplete", this._handleCommandComplete.bind(this));
      con.on("parseComplete", this._handleParseComplete.bind(this));
      con.on("copyInResponse", this._handleCopyInResponse.bind(this));
      con.on("copyData", this._handleCopyData.bind(this));
      con.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(cb) {
      const con = this.connection;
      if (typeof this.password === "function") {
        this._Promise.resolve().then(() => this.password()).then((pass) => {
          if (pass !== undefined) {
            if (typeof pass !== "string") {
              con.emit("error", new TypeError("Password must be a string"));
              return;
            }
            this.connectionParameters.password = this.password = pass;
          } else {
            this.connectionParameters.password = this.password = null;
          }
          cb();
        }).catch((err) => {
          con.emit("error", err);
        });
      } else if (this.password !== null) {
        cb();
      } else {
        try {
          const pgPass = require_lib2();
          pgPass(this.connectionParameters, (pass) => {
            if (pass !== undefined) {
              this.connectionParameters.password = this.password = pass;
            }
            cb();
          });
        } catch (e) {
          this.emit("error", e);
        }
      }
    }
    _handleAuthCleartextPassword(msg) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(msg) {
      this._checkPgPass(async () => {
        try {
          const hashedPassword = await crypto2.postgresMd5PasswordHash(this.user, this.password, msg.salt);
          this.connection.password(hashedPassword);
        } catch (e) {
          this.emit("error", e);
        }
      });
    }
    _handleAuthSASL(msg) {
      this._checkPgPass(() => {
        try {
          this.saslSession = sasl.startSession(msg.mechanisms, this.enableChannelBinding && this.connection.stream);
          this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);
        } catch (err) {
          this.connection.emit("error", err);
        }
      });
    }
    async _handleAuthSASLContinue(msg) {
      try {
        await sasl.continueSession(this.saslSession, this.password, msg.data, this.enableChannelBinding && this.connection.stream);
        this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleAuthSASLFinal(msg) {
      try {
        sasl.finalizeSession(this.saslSession, msg.data);
        this.saslSession = null;
      } catch (err) {
        this.connection.emit("error", err);
      }
    }
    _handleBackendKeyData(msg) {
      this.processID = msg.processID;
      this.secretKey = msg.secretKey;
    }
    _handleReadyForQuery(msg) {
      if (this._connecting) {
        this._connecting = false;
        this._connected = true;
        clearTimeout(this.connectionTimeoutHandle);
        if (this._connectionCallback) {
          this._connectionCallback(null, this);
          this._connectionCallback = null;
        }
        this.emit("connect");
      }
      const { activeQuery } = this;
      this.activeQuery = null;
      this.readyForQuery = true;
      if (activeQuery) {
        activeQuery.handleReadyForQuery(this.connection);
      }
      this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(err) {
      if (this._connectionError) {
        return;
      }
      this._connectionError = true;
      clearTimeout(this.connectionTimeoutHandle);
      if (this._connectionCallback) {
        return this._connectionCallback(err);
      }
      this.emit("error", err);
    }
    _handleErrorEvent(err) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(err);
      }
      this._queryable = false;
      this._errorAllQueries(err);
      this.emit("error", err);
    }
    _handleErrorMessage(msg) {
      if (this._connecting) {
        return this._handleErrorWhileConnecting(msg);
      }
      const activeQuery = this.activeQuery;
      if (!activeQuery) {
        this._handleErrorEvent(msg);
        return;
      }
      this.activeQuery = null;
      activeQuery.handleError(msg, this.connection);
    }
    _handleRowDescription(msg) {
      this.activeQuery.handleRowDescription(msg);
    }
    _handleDataRow(msg) {
      this.activeQuery.handleDataRow(msg);
    }
    _handlePortalSuspended(msg) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(msg) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(msg) {
      if (this.activeQuery == null) {
        const error3 = new Error("Received unexpected commandComplete message from backend.");
        this._handleErrorEvent(error3);
        return;
      }
      this.activeQuery.handleCommandComplete(msg, this.connection);
    }
    _handleParseComplete() {
      if (this.activeQuery == null) {
        const error3 = new Error("Received unexpected parseComplete message from backend.");
        this._handleErrorEvent(error3);
        return;
      }
      if (this.activeQuery.name) {
        this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;
      }
    }
    _handleCopyInResponse(msg) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(msg) {
      this.activeQuery.handleCopyData(msg, this.connection);
    }
    _handleNotification(msg) {
      this.emit("notification", msg);
    }
    _handleNotice(msg) {
      this.emit("notice", msg);
    }
    getStartupConf() {
      const params = this.connectionParameters;
      const data = {
        user: params.user,
        database: params.database
      };
      const appName = params.application_name || params.fallback_application_name;
      if (appName) {
        data.application_name = appName;
      }
      if (params.replication) {
        data.replication = "" + params.replication;
      }
      if (params.statement_timeout) {
        data.statement_timeout = String(parseInt(params.statement_timeout, 10));
      }
      if (params.lock_timeout) {
        data.lock_timeout = String(parseInt(params.lock_timeout, 10));
      }
      if (params.idle_in_transaction_session_timeout) {
        data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));
      }
      if (params.options) {
        data.options = params.options;
      }
      return data;
    }
    cancel(client, query) {
      if (client.activeQuery === query) {
        const con = this.connection;
        if (this.host && this.host.indexOf("/") === 0) {
          con.connect(this.host + "/.s.PGSQL." + this.port);
        } else {
          con.connect(this.port, this.host);
        }
        con.on("connect", function() {
          con.cancel(client.processID, client.secretKey);
        });
      } else if (client.queryQueue.indexOf(query) !== -1) {
        client.queryQueue.splice(client.queryQueue.indexOf(query), 1);
      }
    }
    setTypeParser(oid, format, parseFn) {
      return this._types.setTypeParser(oid, format, parseFn);
    }
    getTypeParser(oid, format) {
      return this._types.getTypeParser(oid, format);
    }
    escapeIdentifier(str) {
      return utils.escapeIdentifier(str);
    }
    escapeLiteral(str) {
      return utils.escapeLiteral(str);
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) {
        this.activeQuery = this.queryQueue.shift();
        if (this.activeQuery) {
          this.readyForQuery = false;
          this.hasExecuted = true;
          const queryError = this.activeQuery.submit(this.connection);
          if (queryError) {
            process.nextTick(() => {
              this.activeQuery.handleError(queryError, this.connection);
              this.readyForQuery = true;
              this._pulseQueryQueue();
            });
          }
        } else if (this.hasExecuted) {
          this.activeQuery = null;
          this.emit("drain");
        }
      }
    }
    query(config, values, callback) {
      let query;
      let result;
      let readTimeout;
      let readTimeoutTimer;
      let queryCallback;
      if (config === null || config === undefined) {
        throw new TypeError("Client was passed a null or undefined query");
      } else if (typeof config.submit === "function") {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        result = query = config;
        if (typeof values === "function") {
          query.callback = query.callback || values;
        }
      } else {
        readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
        query = new Query(config, values, callback);
        if (!query.callback) {
          result = new this._Promise((resolve, reject) => {
            query.callback = (err, res) => err ? reject(err) : resolve(res);
          }).catch((err) => {
            Error.captureStackTrace(err);
            throw err;
          });
        }
      }
      if (readTimeout) {
        queryCallback = query.callback;
        readTimeoutTimer = setTimeout(() => {
          const error3 = new Error("Query read timeout");
          process.nextTick(() => {
            query.handleError(error3, this.connection);
          });
          queryCallback(error3);
          query.callback = () => {};
          const index = this.queryQueue.indexOf(query);
          if (index > -1) {
            this.queryQueue.splice(index, 1);
          }
          this._pulseQueryQueue();
        }, readTimeout);
        query.callback = (err, res) => {
          clearTimeout(readTimeoutTimer);
          queryCallback(err, res);
        };
      }
      if (this.binary && !query.binary) {
        query.binary = true;
      }
      if (query._result && !query._result._types) {
        query._result._types = this._types;
      }
      if (!this._queryable) {
        process.nextTick(() => {
          query.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
        });
        return result;
      }
      if (this._ending) {
        process.nextTick(() => {
          query.handleError(new Error("Client was closed and is not queryable"), this.connection);
        });
        return result;
      }
      this.queryQueue.push(query);
      this._pulseQueryQueue();
      return result;
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(cb) {
      this._ending = true;
      if (!this.connection._connecting || this._ended) {
        if (cb) {
          cb();
        } else {
          return this._Promise.resolve();
        }
      }
      if (this.activeQuery || !this._queryable) {
        this.connection.stream.destroy();
      } else {
        this.connection.end();
      }
      if (cb) {
        this.connection.once("end", cb);
      } else {
        return new this._Promise((resolve) => {
          this.connection.once("end", resolve);
        });
      }
    }
  }
  Client.Query = Query;
  module.exports = Client;
});

// node_modules/pg-pool/index.js
var require_pg_pool = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var NOOP = function() {};
  var removeWhere = (list, predicate) => {
    const i = list.findIndex(predicate);
    return i === -1 ? undefined : list.splice(i, 1)[0];
  };

  class IdleItem {
    constructor(client, idleListener, timeoutId) {
      this.client = client;
      this.idleListener = idleListener;
      this.timeoutId = timeoutId;
    }
  }

  class PendingItem {
    constructor(callback) {
      this.callback = callback;
    }
  }
  function throwOnDoubleRelease() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  function promisify(Promise3, callback) {
    if (callback) {
      return { callback, result: undefined };
    }
    let rej;
    let res;
    const cb = function(err, client) {
      err ? rej(err) : res(client);
    };
    const result = new Promise3(function(resolve, reject) {
      res = resolve;
      rej = reject;
    }).catch((err) => {
      Error.captureStackTrace(err);
      throw err;
    });
    return { callback: cb, result };
  }
  function makeIdleListener(pool, client) {
    return function idleListener(err) {
      err.client = client;
      client.removeListener("error", idleListener);
      client.on("error", () => {
        pool.log("additional client error after disconnection due to error", err);
      });
      pool._remove(client);
      pool.emit("error", err, client);
    };
  }

  class Pool extends EventEmitter2 {
    constructor(options, Client) {
      super();
      this.options = Object.assign({}, options);
      if (options != null && "password" in options) {
        Object.defineProperty(this.options, "password", {
          configurable: true,
          enumerable: false,
          writable: true,
          value: options.password
        });
      }
      if (options != null && options.ssl && options.ssl.key) {
        Object.defineProperty(this.options.ssl, "key", {
          enumerable: false
        });
      }
      this.options.max = this.options.max || this.options.poolSize || 10;
      this.options.min = this.options.min || 0;
      this.options.maxUses = this.options.maxUses || Infinity;
      this.options.allowExitOnIdle = this.options.allowExitOnIdle || false;
      this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0;
      this.log = this.options.log || function() {};
      this.Client = this.options.Client || Client || require_lib3().Client;
      this.Promise = this.options.Promise || global.Promise;
      if (typeof this.options.idleTimeoutMillis === "undefined") {
        this.options.idleTimeoutMillis = 1e4;
      }
      this._clients = [];
      this._idle = [];
      this._expired = new WeakSet;
      this._pendingQueue = [];
      this._endCallback = undefined;
      this.ending = false;
      this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _isAboveMin() {
      return this._clients.length > this.options.min;
    }
    _pulseQueue() {
      this.log("pulse queue");
      if (this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending");
        if (this._idle.length) {
          this._idle.slice().map((item) => {
            this._remove(item.client);
          });
        }
        if (!this._clients.length) {
          this.ended = true;
          this._endCallback();
        }
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) {
        return;
      }
      const pendingItem = this._pendingQueue.shift();
      if (this._idle.length) {
        const idleItem = this._idle.pop();
        clearTimeout(idleItem.timeoutId);
        const client = idleItem.client;
        client.ref && client.ref();
        const idleListener = idleItem.idleListener;
        return this._acquireClient(client, pendingItem, idleListener, false);
      }
      if (!this._isFull()) {
        return this.newClient(pendingItem);
      }
      throw new Error("unexpected condition");
    }
    _remove(client, callback) {
      const removed = removeWhere(this._idle, (item) => item.client === client);
      if (removed !== undefined) {
        clearTimeout(removed.timeoutId);
      }
      this._clients = this._clients.filter((c) => c !== client);
      const context = this;
      client.end(() => {
        context.emit("remove", client);
        if (typeof callback === "function") {
          callback();
        }
      });
    }
    connect(cb) {
      if (this.ending) {
        const err = new Error("Cannot use a pool after calling end on the pool");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      const response = promisify(this.Promise, cb);
      const result = response.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length) {
          process.nextTick(() => this._pulseQueue());
        }
        if (!this.options.connectionTimeoutMillis) {
          this._pendingQueue.push(new PendingItem(response.callback));
          return result;
        }
        const queueCallback = (err, res, done) => {
          clearTimeout(tid);
          response.callback(err, res, done);
        };
        const pendingItem = new PendingItem(queueCallback);
        const tid = setTimeout(() => {
          removeWhere(this._pendingQueue, (i) => i.callback === queueCallback);
          pendingItem.timedOut = true;
          response.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        if (tid.unref) {
          tid.unref();
        }
        this._pendingQueue.push(pendingItem);
        return result;
      }
      this.newClient(new PendingItem(response.callback));
      return result;
    }
    newClient(pendingItem) {
      const client = new this.Client(this.options);
      this._clients.push(client);
      const idleListener = makeIdleListener(this, client);
      this.log("checking client timeout");
      let tid;
      let timeoutHit = false;
      if (this.options.connectionTimeoutMillis) {
        tid = setTimeout(() => {
          this.log("ending client due to timeout");
          timeoutHit = true;
          client.connection ? client.connection.stream.destroy() : client.end();
        }, this.options.connectionTimeoutMillis);
      }
      this.log("connecting new client");
      client.connect((err) => {
        if (tid) {
          clearTimeout(tid);
        }
        client.on("error", idleListener);
        if (err) {
          this.log("client failed to connect", err);
          this._clients = this._clients.filter((c) => c !== client);
          if (timeoutHit) {
            err = new Error("Connection terminated due to connection timeout", { cause: err });
          }
          this._pulseQueue();
          if (!pendingItem.timedOut) {
            pendingItem.callback(err, undefined, NOOP);
          }
        } else {
          this.log("new client connected");
          if (this.options.maxLifetimeSeconds !== 0) {
            const maxLifetimeTimeout = setTimeout(() => {
              this.log("ending client due to expired lifetime");
              this._expired.add(client);
              const idleIndex = this._idle.findIndex((idleItem) => idleItem.client === client);
              if (idleIndex !== -1) {
                this._acquireClient(client, new PendingItem((err2, client2, clientRelease) => clientRelease()), idleListener, false);
              }
            }, this.options.maxLifetimeSeconds * 1000);
            maxLifetimeTimeout.unref();
            client.once("end", () => clearTimeout(maxLifetimeTimeout));
          }
          return this._acquireClient(client, pendingItem, idleListener, true);
        }
      });
    }
    _acquireClient(client, pendingItem, idleListener, isNew) {
      if (isNew) {
        this.emit("connect", client);
      }
      this.emit("acquire", client);
      client.release = this._releaseOnce(client, idleListener);
      client.removeListener("error", idleListener);
      if (!pendingItem.timedOut) {
        if (isNew && this.options.verify) {
          this.options.verify(client, (err) => {
            if (err) {
              client.release(err);
              return pendingItem.callback(err, undefined, NOOP);
            }
            pendingItem.callback(undefined, client, client.release);
          });
        } else {
          pendingItem.callback(undefined, client, client.release);
        }
      } else {
        if (isNew && this.options.verify) {
          this.options.verify(client, client.release);
        } else {
          client.release();
        }
      }
    }
    _releaseOnce(client, idleListener) {
      let released = false;
      return (err) => {
        if (released) {
          throwOnDoubleRelease();
        }
        released = true;
        this._release(client, idleListener, err);
      };
    }
    _release(client, idleListener, err) {
      client.on("error", idleListener);
      client._poolUseCount = (client._poolUseCount || 0) + 1;
      this.emit("release", err, client);
      if (err || this.ending || !client._queryable || client._ending || client._poolUseCount >= this.options.maxUses) {
        if (client._poolUseCount >= this.options.maxUses) {
          this.log("remove expended client");
        }
        return this._remove(client, this._pulseQueue.bind(this));
      }
      const isExpired = this._expired.has(client);
      if (isExpired) {
        this.log("remove expired client");
        this._expired.delete(client);
        return this._remove(client, this._pulseQueue.bind(this));
      }
      let tid;
      if (this.options.idleTimeoutMillis && this._isAboveMin()) {
        tid = setTimeout(() => {
          this.log("remove idle client");
          this._remove(client, this._pulseQueue.bind(this));
        }, this.options.idleTimeoutMillis);
        if (this.options.allowExitOnIdle) {
          tid.unref();
        }
      }
      if (this.options.allowExitOnIdle) {
        client.unref();
      }
      this._idle.push(new IdleItem(client, idleListener, tid));
      this._pulseQueue();
    }
    query(text, values, cb) {
      if (typeof text === "function") {
        const response2 = promisify(this.Promise, text);
        setImmediate(function() {
          return response2.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        });
        return response2.result;
      }
      if (typeof values === "function") {
        cb = values;
        values = undefined;
      }
      const response = promisify(this.Promise, cb);
      cb = response.callback;
      this.connect((err, client) => {
        if (err) {
          return cb(err);
        }
        let clientReleased = false;
        const onError = (err2) => {
          if (clientReleased) {
            return;
          }
          clientReleased = true;
          client.release(err2);
          cb(err2);
        };
        client.once("error", onError);
        this.log("dispatching query");
        try {
          client.query(text, values, (err2, res) => {
            this.log("query dispatched");
            client.removeListener("error", onError);
            if (clientReleased) {
              return;
            }
            clientReleased = true;
            client.release(err2);
            if (err2) {
              return cb(err2);
            }
            return cb(undefined, res);
          });
        } catch (err2) {
          client.release(err2);
          return cb(err2);
        }
      });
      return response.result;
    }
    end(cb) {
      this.log("ending");
      if (this.ending) {
        const err = new Error("Called end on pool more than once");
        return cb ? cb(err) : this.Promise.reject(err);
      }
      this.ending = true;
      const promised = promisify(this.Promise, cb);
      this._endCallback = promised.callback;
      this._pulseQueue();
      return promised.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((acc, client) => acc + (this._expired.has(client) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  }
  module.exports = Pool;
});

// node_modules/pg/lib/native/query.js
var require_query2 = __commonJS((exports, module) => {
  var EventEmitter2 = __require("events").EventEmitter;
  var util = __require("util");
  var utils = require_utils2();
  var NativeQuery = module.exports = function(config, values, callback) {
    EventEmitter2.call(this);
    config = utils.normalizeQueryConfig(config, values, callback);
    this.text = config.text;
    this.values = config.values;
    this.name = config.name;
    this.queryMode = config.queryMode;
    this.callback = config.callback;
    this.state = "new";
    this._arrayMode = config.rowMode === "array";
    this._emitRowEvents = false;
    this.on("newListener", function(event) {
      if (event === "row")
        this._emitRowEvents = true;
    }.bind(this));
  };
  util.inherits(NativeQuery, EventEmitter2);
  var errorFieldMap = {
    sqlState: "code",
    statementPosition: "position",
    messagePrimary: "message",
    context: "where",
    schemaName: "schema",
    tableName: "table",
    columnName: "column",
    dataTypeName: "dataType",
    constraintName: "constraint",
    sourceFile: "file",
    sourceLine: "line",
    sourceFunction: "routine"
  };
  NativeQuery.prototype.handleError = function(err) {
    const fields = this.native.pq.resultErrorFields();
    if (fields) {
      for (const key in fields) {
        const normalizedFieldName = errorFieldMap[key] || key;
        err[normalizedFieldName] = fields[key];
      }
    }
    if (this.callback) {
      this.callback(err);
    } else {
      this.emit("error", err);
    }
    this.state = "error";
  };
  NativeQuery.prototype.then = function(onSuccess, onFailure) {
    return this._getPromise().then(onSuccess, onFailure);
  };
  NativeQuery.prototype.catch = function(callback) {
    return this._getPromise().catch(callback);
  };
  NativeQuery.prototype._getPromise = function() {
    if (this._promise)
      return this._promise;
    this._promise = new Promise(function(resolve, reject) {
      this._once("end", resolve);
      this._once("error", reject);
    }.bind(this));
    return this._promise;
  };
  NativeQuery.prototype.submit = function(client) {
    this.state = "running";
    const self2 = this;
    this.native = client.native;
    client.native.arrayMode = this._arrayMode;
    let after = function(err, rows, results) {
      client.native.arrayMode = false;
      setImmediate(function() {
        self2.emit("_done");
      });
      if (err) {
        return self2.handleError(err);
      }
      if (self2._emitRowEvents) {
        if (results.length > 1) {
          rows.forEach((rowOfRows, i) => {
            rowOfRows.forEach((row) => {
              self2.emit("row", row, results[i]);
            });
          });
        } else {
          rows.forEach(function(row) {
            self2.emit("row", row, results);
          });
        }
      }
      self2.state = "end";
      self2.emit("end", results);
      if (self2.callback) {
        self2.callback(null, results);
      }
    };
    if (process.domain) {
      after = process.domain.bind(after);
    }
    if (this.name) {
      if (this.name.length > 63) {
        console.error("Warning! Postgres only supports 63 characters for query names.");
        console.error("You supplied %s (%s)", this.name, this.name.length);
        console.error("This can cause conflicts and silent errors executing queries");
      }
      const values = (this.values || []).map(utils.prepareValue);
      if (client.namedQueries[this.name]) {
        if (this.text && client.namedQueries[this.name] !== this.text) {
          const err = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return after(err);
        }
        return client.native.execute(this.name, values, after);
      }
      return client.native.prepare(this.name, this.text, values.length, function(err) {
        if (err)
          return after(err);
        client.namedQueries[self2.name] = self2.text;
        return self2.native.execute(self2.name, values, after);
      });
    } else if (this.values) {
      if (!Array.isArray(this.values)) {
        const err = new Error("Query values must be an array");
        return after(err);
      }
      const vals = this.values.map(utils.prepareValue);
      client.native.query(this.text, vals, after);
    } else if (this.queryMode === "extended") {
      client.native.query(this.text, [], after);
    } else {
      client.native.query(this.text, after);
    }
  };
});

// node_modules/pg/lib/native/client.js
var require_client2 = __commonJS((exports, module) => {
  var Native;
  try {
    Native = (()=>{throw new Error("Cannot require module "+"pg-native");})();
  } catch (e) {
    throw e;
  }
  var TypeOverrides = require_type_overrides();
  var EventEmitter2 = __require("events").EventEmitter;
  var util = __require("util");
  var ConnectionParameters = require_connection_parameters();
  var NativeQuery = require_query2();
  var Client = module.exports = function(config) {
    EventEmitter2.call(this);
    config = config || {};
    this._Promise = config.Promise || global.Promise;
    this._types = new TypeOverrides(config.types);
    this.native = new Native({
      types: this._types
    });
    this._queryQueue = [];
    this._ending = false;
    this._connecting = false;
    this._connected = false;
    this._queryable = true;
    const cp = this.connectionParameters = new ConnectionParameters(config);
    if (config.nativeConnectionString)
      cp.nativeConnectionString = config.nativeConnectionString;
    this.user = cp.user;
    Object.defineProperty(this, "password", {
      configurable: true,
      enumerable: false,
      writable: true,
      value: cp.password
    });
    this.database = cp.database;
    this.host = cp.host;
    this.port = cp.port;
    this.namedQueries = {};
  };
  Client.Query = NativeQuery;
  util.inherits(Client, EventEmitter2);
  Client.prototype._errorAllQueries = function(err) {
    const enqueueError = (query) => {
      process.nextTick(() => {
        query.native = this.native;
        query.handleError(err);
      });
    };
    if (this._hasActiveQuery()) {
      enqueueError(this._activeQuery);
      this._activeQuery = null;
    }
    this._queryQueue.forEach(enqueueError);
    this._queryQueue.length = 0;
  };
  Client.prototype._connect = function(cb) {
    const self2 = this;
    if (this._connecting) {
      process.nextTick(() => cb(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true;
    this.connectionParameters.getLibpqConnectionString(function(err, conString) {
      if (self2.connectionParameters.nativeConnectionString)
        conString = self2.connectionParameters.nativeConnectionString;
      if (err)
        return cb(err);
      self2.native.connect(conString, function(err2) {
        if (err2) {
          self2.native.end();
          return cb(err2);
        }
        self2._connected = true;
        self2.native.on("error", function(err3) {
          self2._queryable = false;
          self2._errorAllQueries(err3);
          self2.emit("error", err3);
        });
        self2.native.on("notification", function(msg) {
          self2.emit("notification", {
            channel: msg.relname,
            payload: msg.extra
          });
        });
        self2.emit("connect");
        self2._pulseQueryQueue(true);
        cb();
      });
    });
  };
  Client.prototype.connect = function(callback) {
    if (callback) {
      this._connect(callback);
      return;
    }
    return new this._Promise((resolve, reject) => {
      this._connect((error3) => {
        if (error3) {
          reject(error3);
        } else {
          resolve();
        }
      });
    });
  };
  Client.prototype.query = function(config, values, callback) {
    let query;
    let result;
    let readTimeout;
    let readTimeoutTimer;
    let queryCallback;
    if (config === null || config === undefined) {
      throw new TypeError("Client was passed a null or undefined query");
    } else if (typeof config.submit === "function") {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      result = query = config;
      if (typeof values === "function") {
        config.callback = values;
      }
    } else {
      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;
      query = new NativeQuery(config, values, callback);
      if (!query.callback) {
        let resolveOut, rejectOut;
        result = new this._Promise((resolve, reject) => {
          resolveOut = resolve;
          rejectOut = reject;
        }).catch((err) => {
          Error.captureStackTrace(err);
          throw err;
        });
        query.callback = (err, res) => err ? rejectOut(err) : resolveOut(res);
      }
    }
    if (readTimeout) {
      queryCallback = query.callback;
      readTimeoutTimer = setTimeout(() => {
        const error3 = new Error("Query read timeout");
        process.nextTick(() => {
          query.handleError(error3, this.connection);
        });
        queryCallback(error3);
        query.callback = () => {};
        const index = this._queryQueue.indexOf(query);
        if (index > -1) {
          this._queryQueue.splice(index, 1);
        }
        this._pulseQueryQueue();
      }, readTimeout);
      query.callback = (err, res) => {
        clearTimeout(readTimeoutTimer);
        queryCallback(err, res);
      };
    }
    if (!this._queryable) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client has encountered a connection error and is not queryable"));
      });
      return result;
    }
    if (this._ending) {
      query.native = this.native;
      process.nextTick(() => {
        query.handleError(new Error("Client was closed and is not queryable"));
      });
      return result;
    }
    this._queryQueue.push(query);
    this._pulseQueryQueue();
    return result;
  };
  Client.prototype.end = function(cb) {
    const self2 = this;
    this._ending = true;
    if (!this._connected) {
      this.once("connect", this.end.bind(this, cb));
    }
    let result;
    if (!cb) {
      result = new this._Promise(function(resolve, reject) {
        cb = (err) => err ? reject(err) : resolve();
      });
    }
    this.native.end(function() {
      self2._errorAllQueries(new Error("Connection terminated"));
      process.nextTick(() => {
        self2.emit("end");
        if (cb)
          cb();
      });
    });
    return result;
  };
  Client.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Client.prototype._pulseQueryQueue = function(initialConnection) {
    if (!this._connected) {
      return;
    }
    if (this._hasActiveQuery()) {
      return;
    }
    const query = this._queryQueue.shift();
    if (!query) {
      if (!initialConnection) {
        this.emit("drain");
      }
      return;
    }
    this._activeQuery = query;
    query.submit(this);
    const self2 = this;
    query.once("_done", function() {
      self2._pulseQueryQueue();
    });
  };
  Client.prototype.cancel = function(query) {
    if (this._activeQuery === query) {
      this.native.cancel(function() {});
    } else if (this._queryQueue.indexOf(query) !== -1) {
      this._queryQueue.splice(this._queryQueue.indexOf(query), 1);
    }
  };
  Client.prototype.ref = function() {};
  Client.prototype.unref = function() {};
  Client.prototype.setTypeParser = function(oid, format, parseFn) {
    return this._types.setTypeParser(oid, format, parseFn);
  };
  Client.prototype.getTypeParser = function(oid, format) {
    return this._types.getTypeParser(oid, format);
  };
});

// node_modules/pg/lib/index.js
var require_lib3 = __commonJS((exports, module) => {
  var Client = require_client();
  var defaults = require_defaults();
  var Connection = require_connection();
  var Result = require_result();
  var utils = require_utils2();
  var Pool = require_pg_pool();
  var TypeOverrides = require_type_overrides();
  var { DatabaseError } = require_dist();
  var { escapeIdentifier, escapeLiteral } = require_utils2();
  var poolFactory = (Client2) => {
    return class BoundPool extends Pool {
      constructor(options) {
        super(options, Client2);
      }
    };
  };
  var PG = function(clientConstructor) {
    this.defaults = defaults;
    this.Client = clientConstructor;
    this.Query = this.Client.Query;
    this.Pool = poolFactory(this.Client);
    this._pools = [];
    this.Connection = Connection;
    this.types = require_pg_types();
    this.DatabaseError = DatabaseError;
    this.TypeOverrides = TypeOverrides;
    this.escapeIdentifier = escapeIdentifier;
    this.escapeLiteral = escapeLiteral;
    this.Result = Result;
    this.utils = utils;
  };
  if (typeof process.env.NODE_PG_FORCE_NATIVE !== "undefined") {
    module.exports = new PG(require_client2());
  } else {
    module.exports = new PG(Client);
    Object.defineProperty(module.exports, "native", {
      configurable: true,
      enumerable: false,
      get() {
        let native = null;
        try {
          native = new PG(require_client2());
        } catch (err) {
          if (err.code !== "MODULE_NOT_FOUND") {
            throw err;
          }
        }
        Object.defineProperty(module.exports, "native", {
          value: native
        });
        return native;
      }
    });
  }
});

// node_modules/luxon/build/node/luxon.js
var require_luxon = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class LuxonError extends Error {
  }

  class InvalidDateTimeError extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  }

  class InvalidIntervalError extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  }

  class InvalidDurationError extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  }

  class ConflictingSpecificationError extends LuxonError {
  }

  class InvalidUnitError extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  }

  class InvalidArgumentError extends LuxonError {
  }

  class ZoneIsAbstractError extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  }
  var n = "numeric";
  var s = "short";
  var l = "long";
  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };
  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
  };
  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };
  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };
  var TIME_SIMPLE = {
    hour: n,
    minute: n
  };
  var TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };
  var TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
  };
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
  };
  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };

  class Zone {
    get type() {
      throw new ZoneIsAbstractError;
    }
    get name() {
      throw new ZoneIsAbstractError;
    }
    get ianaName() {
      return this.name;
    }
    get isUniversal() {
      throw new ZoneIsAbstractError;
    }
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError;
    }
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError;
    }
    offset(ts) {
      throw new ZoneIsAbstractError;
    }
    equals(otherZone) {
      throw new ZoneIsAbstractError;
    }
    get isValid() {
      throw new ZoneIsAbstractError;
    }
  }
  var singleton$1 = null;

  class SystemZone extends Zone {
    static get instance() {
      if (singleton$1 === null) {
        singleton$1 = new SystemZone;
      }
      return singleton$1;
    }
    get type() {
      return "system";
    }
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    equals(otherZone) {
      return otherZone.type === "system";
    }
    get isValid() {
      return true;
    }
  }
  var dtfCache = new Map;
  function makeDTF(zoneName) {
    let dtf = dtfCache.get(zoneName);
    if (dtf === undefined) {
      dtf = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zoneName,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
      dtfCache.set(zoneName, dtf);
    }
    return dtf;
  }
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  function hackyOffset(dtf, date3) {
    const formatted = dtf.format(date3).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  }
  function partsOffset(dtf, date3) {
    const formatted = dtf.formatToParts(date3);
    const filled = [];
    for (let i = 0;i < formatted.length; i++) {
      const {
        type: type3,
        value: value2
      } = formatted[i];
      const pos = typeToPos[type3];
      if (type3 === "era") {
        filled[pos] = value2;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value2, 10);
      }
    }
    return filled;
  }
  var ianaZoneCache = new Map;

  class IANAZone extends Zone {
    static create(name) {
      let zone = ianaZoneCache.get(name);
      if (zone === undefined) {
        ianaZoneCache.set(name, zone = new IANAZone(name));
      }
      return zone;
    }
    static resetCache() {
      ianaZoneCache.clear();
      dtfCache.clear();
    }
    static isValidSpecifier(s2) {
      return this.isValidZone(s2);
    }
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", {
          timeZone: zone
        }).format();
        return true;
      } catch (e) {
        return false;
      }
    }
    constructor(name) {
      super();
      this.zoneName = name;
      this.valid = IANAZone.isValidZone(name);
    }
    get type() {
      return "iana";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      if (!this.valid)
        return NaN;
      const date3 = new Date(ts);
      if (isNaN(date3))
        return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date3) : hackyOffset(dtf, date3);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0
      });
      let asTS = +date3;
      const over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return (asUTC - asTS) / (60 * 1000);
    }
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    get isValid() {
      return this.valid;
    }
  }
  var intlLFCache = {};
  function getCachedLF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  }
  var intlDTCache = new Map;
  function getCachedDTF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache.get(key);
    if (dtf === undefined) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache.set(key, dtf);
    }
    return dtf;
  }
  var intlNumCache = new Map;
  function getCachedINF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache.get(key);
    if (inf === undefined) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache.set(key, inf);
    }
    return inf;
  }
  var intlRelCache = new Map;
  function getCachedRTF(locString, opts = {}) {
    const {
      base,
      ...cacheKeyOpts
    } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache.get(key);
    if (inf === undefined) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache.set(key, inf);
    }
    return inf;
  }
  var sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  }
  var intlResolvedOptionsCache = new Map;
  function getCachedIntResolvedOptions(locString) {
    let opts = intlResolvedOptionsCache.get(locString);
    if (opts === undefined) {
      opts = new Intl.DateTimeFormat(locString).resolvedOptions();
      intlResolvedOptionsCache.set(locString, opts);
    }
    return opts;
  }
  var weekInfoCache = new Map;
  function getCachedWeekInfo(locString) {
    let data = weekInfoCache.get(locString);
    if (!data) {
      const locale = new Intl.Locale(locString);
      data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
      if (!("minimalDays" in data)) {
        data = {
          ...fallbackWeekSettings,
          ...data
        };
      }
      weekInfoCache.set(locString, data);
    }
    return data;
  }
  function parseLocaleString(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const {
        numberingSystem,
        calendar
      } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  }
  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  }
  function mapMonths(f) {
    const ms = [];
    for (let i = 1;i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  }
  function mapWeekdays(f) {
    const ms = [];
    for (let i = 1;i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  }
  function listStuff(loc, length, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  }
  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || getCachedIntResolvedOptions(loc.locale).numberingSystem === "latn";
    }
  }

  class PolyNumberFormatter {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const {
        padTo,
        floor,
        ...otherOpts
      } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = {
          useGrouping: false,
          ...opts
        };
        if (opts.padTo > 0)
          intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  }

  class PolyDateFormatter {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = undefined;
      let z = undefined;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
            minutes: dt.offset
          });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({
          minutes: dt.offset
        });
        this.originalZone = dt.zone;
      }
      const intlOpts = {
        ...this.opts
      };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({
          value: value2
        }) => value2).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }

  class PolyRelFormatter {
    constructor(intl, isEnglish, opts) {
      this.opts = {
        style: "long",
        ...opts
      };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  }
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };

  class Locale {
    static fromOpts(opts) {
      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
    }
    static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache.clear();
      intlNumCache.clear();
      intlRelCache.clear();
      intlResolvedOptionsCache.clear();
      weekInfoCache.clear();
    }
    static fromObject({
      locale,
      numberingSystem,
      outputCalendar,
      weekSettings
    } = {}) {
      return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = {
        format: {},
        standalone: {}
      };
      this.monthsCache = {
        format: {},
        standalone: {}
      };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: true
      });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: false
      });
    }
    months(length, format = false) {
      return listStuff(this, length, months, () => {
        const monthSpecialCase = this.intl === "ja" || this.intl.startsWith("ja-");
        format &= !monthSpecialCase;
        const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          const mapper = !monthSpecialCase ? (dt) => this.extract(dt, intl, "month") : (dt) => this.dtFormatter(dt, intl).format();
          this.monthsCache[formatStr][length] = mapMonths(mapper);
        }
        return this.monthsCache[formatStr][length];
      });
    }
    weekdays(length, format = false) {
      return listStuff(this, length, weekdays, () => {
        const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
        }
        return this.weekdaysCache[formatStr][length];
      });
    }
    meridiems() {
      return listStuff(this, undefined, () => meridiems, () => {
        if (!this.meridiemCache) {
          const intl = {
            hour: "numeric",
            hourCycle: "h12"
          };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
        }
        return this.meridiemCache;
      });
    }
    eras(length) {
      return listStuff(this, length, eras, () => {
        const intl = {
          era: length
        };
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
        }
        return this.eraCache[length];
      });
    }
    extract(dt, intlOpts, field) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || getCachedIntResolvedOptions(this.intl).locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
    toString() {
      return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
    }
  }
  var singleton = null;

  class FixedOffsetZone extends Zone {
    static get utcInstance() {
      if (singleton === null) {
        singleton = new FixedOffsetZone(0);
      }
      return singleton;
    }
    static instance(offset2) {
      return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
    }
    static parseSpecifier(s2) {
      if (s2) {
        const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }
    constructor(offset2) {
      super();
      this.fixed = offset2;
    }
    get type() {
      return "fixed";
    }
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    offsetName() {
      return this.name;
    }
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }
    get isUniversal() {
      return true;
    }
    offset() {
      return this.fixed;
    }
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    get isValid() {
      return true;
    }
  }

  class InvalidZone extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    get type() {
      return "invalid";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName() {
      return null;
    }
    formatOffset() {
      return "";
    }
    offset() {
      return NaN;
    }
    equals() {
      return false;
    }
    get isValid() {
      return false;
    }
  }
  function normalizeZone(input, defaultZone2) {
    if (isUndefined(input) || input === null) {
      return defaultZone2;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default")
        return defaultZone2;
      else if (lowered === "local" || lowered === "system")
        return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt")
        return FixedOffsetZone.utcInstance;
      else
        return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
      return input;
    } else {
      return new InvalidZone(input);
    }
  }
  var numberingSystems = {
    arab: "[٠-٩]",
    arabext: "[۰-۹]",
    bali: "[᭐-᭙]",
    beng: "[০-৯]",
    deva: "[०-९]",
    fullwide: "[０-９]",
    gujr: "[૦-૯]",
    hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
    khmr: "[០-៩]",
    knda: "[೦-೯]",
    laoo: "[໐-໙]",
    limb: "[᥆-᥏]",
    mlym: "[൦-൯]",
    mong: "[᠐-᠙]",
    mymr: "[၀-၉]",
    orya: "[୦-୯]",
    tamldec: "[௦-௯]",
    telu: "[౦-౯]",
    thai: "[๐-๙]",
    tibt: "[༠-༩]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  function parseDigits(str) {
    let value2 = parseInt(str, 10);
    if (isNaN(value2)) {
      value2 = "";
      for (let i = 0;i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value2 += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value2 += code - min;
            }
          }
        }
      }
      return parseInt(value2, 10);
    } else {
      return value2;
    }
  }
  var digitRegexCache = new Map;
  function resetDigitRegexCache() {
    digitRegexCache.clear();
  }
  function digitRegex({
    numberingSystem
  }, append = "") {
    const ns = numberingSystem || "latn";
    let appendCache = digitRegexCache.get(ns);
    if (appendCache === undefined) {
      appendCache = new Map;
      digitRegexCache.set(ns, appendCache);
    }
    let regex = appendCache.get(append);
    if (regex === undefined) {
      regex = new RegExp(`${numberingSystems[ns]}${append}`);
      appendCache.set(append, regex);
    }
    return regex;
  }
  var now = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;

  class Settings {
    static get now() {
      return now;
    }
    static set now(n2) {
      now = n2;
    }
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    static get defaultLocale() {
      return defaultLocale;
    }
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    static set throwOnInvalid(t2) {
      throwOnInvalid = t2;
    }
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
      DateTime.resetCache();
      resetDigitRegexCache();
    }
  }

  class Invalid {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  }
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  function unitOutOfRange(unit, value2) {
    return new Invalid("unit out of range", `you specified ${value2} (of type ${typeof value2}) as a ${unit}, which is invalid`);
  }
  function dayOfWeek(year, month, day) {
    const d = new Date(Date.UTC(year, month - 1, day));
    if (year < 100 && year >= 0) {
      d.setUTCFullYear(d.getUTCFullYear() - 1900);
    }
    const js = d.getUTCDay();
    return js === 0 ? 7 : js;
  }
  function computeOrdinal(year, month, day) {
    return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  }
  function uncomputeOrdinal(year, ordinal) {
    const table = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day = ordinal - table[month0];
    return {
      month: month0 + 1,
      day
    };
  }
  function isoWeekdayToLocal(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  }
  function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const {
      year,
      month,
      day
    } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
    let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return {
      weekYear,
      weekNumber,
      weekday,
      ...timeObject(gregObj)
    };
  }
  function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const {
      weekYear,
      weekNumber,
      weekday
    } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const {
      month,
      day
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day,
      ...timeObject(weekData)
    };
  }
  function gregorianToOrdinal(gregData) {
    const {
      year,
      month,
      day
    } = gregData;
    const ordinal = computeOrdinal(year, month, day);
    return {
      year,
      ordinal,
      ...timeObject(gregData)
    };
  }
  function ordinalToGregorian(ordinalData) {
    const {
      year,
      ordinal
    } = ordinalData;
    const {
      month,
      day
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day,
      ...timeObject(ordinalData)
    };
  }
  function usesLocalWeekValues(obj, loc) {
    const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
      }
      if (!isUndefined(obj.localWeekday))
        obj.weekday = obj.localWeekday;
      if (!isUndefined(obj.localWeekNumber))
        obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined(obj.localWeekYear))
        obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return {
        minDaysInFirstWeek: 4,
        startOfWeek: 1
      };
    }
  }
  function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else
      return false;
  }
  function hasInvalidOrdinalData(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else
      return false;
  }
  function hasInvalidGregorianData(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else
      return false;
  }
  function hasInvalidTimeData(obj) {
    const {
      hour,
      minute,
      second,
      millisecond
    } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else
      return false;
  }
  function isUndefined(o) {
    return typeof o === "undefined";
  }
  function isNumber(o) {
    return typeof o === "number";
  }
  function isInteger(o) {
    return typeof o === "number" && o % 1 === 0;
  }
  function isString(o) {
    return typeof o === "string";
  }
  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }
  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e) {
      return false;
    }
  }
  function hasLocaleWeekInfo() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && (("weekInfo" in Intl.Locale.prototype) || ("getWeekInfo" in Intl.Locale.prototype));
    } catch (e) {
      return false;
    }
  }
  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }
  function bestBy(arr, by, compare) {
    if (arr.length === 0) {
      return;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }
  function pick3(obj, keys) {
    return keys.reduce((a, k) => {
      a[k] = obj[k];
      return a;
    }, {});
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function validateWeekSettings(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  }
  function integerBetween(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  }
  function floorMod(x, n2) {
    return x - n2 * Math.floor(x / n2);
  }
  function padStart(input, n2 = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n2, "0");
    } else {
      padded = ("" + input).padStart(n2, "0");
    }
    return padded;
  }
  function parseInteger(string3) {
    if (isUndefined(string3) || string3 === null || string3 === "") {
      return;
    } else {
      return parseInt(string3, 10);
    }
  }
  function parseFloating(string3) {
    if (isUndefined(string3) || string3 === null || string3 === "") {
      return;
    } else {
      return parseFloat(string3);
    }
  }
  function parseMillis(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return;
    } else {
      const f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  }
  function roundTo(number3, digits, rounding = "round") {
    const factor = 10 ** digits;
    switch (rounding) {
      case "expand":
        return number3 > 0 ? Math.ceil(number3 * factor) / factor : Math.floor(number3 * factor) / factor;
      case "trunc":
        return Math.trunc(number3 * factor) / factor;
      case "round":
        return Math.round(number3 * factor) / factor;
      case "floor":
        return Math.floor(number3 * factor) / factor;
      case "ceil":
        return Math.ceil(number3 * factor) / factor;
      default:
        throw new RangeError(`Value rounding ${rounding} is out of range`);
    }
  }
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
  }
  function daysInMonth(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }
  function objToLocalTS(obj) {
    let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
    if (obj.year < 100 && obj.year >= 0) {
      d = new Date(d);
      d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d;
  }
  function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  }
  function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  }
  function untruncateYear(year) {
    if (year > 99) {
      return year;
    } else
      return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
  }
  function parseZoneInfo(ts, offsetFormat, locale, timeZone = null) {
    const date3 = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = {
      timeZoneName: offsetFormat,
      ...intlOpts
    };
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date3).find((m) => m.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  }
  function signedOffset(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }
  function asNumber(value2) {
    const numericValue = Number(value2);
    if (typeof value2 === "boolean" || value2 === "" || !Number.isFinite(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value2}`);
    return numericValue;
  }
  function normalizeObject(obj, normalizer) {
    const normalized = {};
    for (const u in obj) {
      if (hasOwnProperty(obj, u)) {
        const v = obj[u];
        if (v === undefined || v === null)
          continue;
        normalized[normalizer(u)] = asNumber(v);
      }
    }
    return normalized;
  }
  function formatOffset(offset2, format) {
    const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
    switch (format) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  }
  function timeObject(obj) {
    return pick3(obj, ["hour", "minute", "second", "millisecond"]);
  }
  var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  function months(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }
  var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  function weekdays(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  function eras(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  }
  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }
  function weekdayForDateTime(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  }
  function monthForDateTime(dt, length) {
    return months(length)[dt.month - 1];
  }
  function eraForDateTime(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  }
  function formatRelativeTime(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  }
  function stringifyTokens(splits, tokenToString) {
    let s2 = "";
    for (const token of splits) {
      if (token.literal) {
        s2 += token.val;
      } else {
        s2 += tokenToString(token.val);
      }
    }
    return s2;
  }
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };

  class Formatter {
    static create(locale, opts = {}) {
      return new Formatter(locale, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0;i < fmt.length; i++) {
        const c = fmt.charAt(i);
        if (c === "'") {
          if (currentFull.length > 0 || bracketed) {
            splits.push({
              literal: bracketed || /^\s+$/.test(currentFull),
              val: currentFull === "" ? "'" : currentFull
            });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c;
        } else if (c === current) {
          currentFull += c;
        } else {
          if (currentFull.length > 0) {
            splits.push({
              literal: /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          currentFull = c;
          current = c;
        }
      }
      if (currentFull.length > 0) {
        splits.push({
          literal: bracketed || /^\s+$/.test(currentFull),
          val: currentFull
        });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }
    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n2, p = 0, signDisplay = undefined) {
      if (this.opts.forceSimple) {
        return padStart(n2, p);
      }
      const opts = {
        ...this.opts
      };
      if (p > 0) {
        opts.padTo = p;
      }
      if (signDisplay) {
        opts.signDisplay = signDisplay;
      }
      return this.loc.numberFormatter(opts).format(n2);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string3 = (opts, extract3) => this.loc.extract(dt, opts, extract3), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string3({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string3(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string3(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"), maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string3({
        era: length
      }, "era"), tokenToString = (token) => {
        switch (token) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            return formatOffset2({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            return formatOffset2({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string3({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string3({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string3({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string3({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter ? string3({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string3({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter ? string3({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string3({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string3({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string3({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
      return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const invertLargest = this.opts.signMode === "negativeLargestOnly" ? -1 : 1;
      const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "milliseconds";
          case "s":
            return "seconds";
          case "m":
            return "minutes";
          case "h":
            return "hours";
          case "d":
            return "days";
          case "w":
            return "weeks";
          case "M":
            return "months";
          case "y":
            return "years";
          default:
            return null;
        }
      }, tokenToString = (lildur, info) => (token) => {
        const mapped3 = tokenToField(token);
        if (mapped3) {
          const inversionFactor = info.isNegativeDuration && mapped3 !== info.largestUnit ? invertLargest : 1;
          let signDisplay;
          if (this.opts.signMode === "negativeLargestOnly" && mapped3 !== info.largestUnit) {
            signDisplay = "never";
          } else if (this.opts.signMode === "all") {
            signDisplay = "always";
          } else {
            signDisplay = "auto";
          }
          return this.num(lildur.get(mapped3) * inversionFactor, token.length, signDisplay);
        } else {
          return token;
        }
      }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, {
        literal: literal3,
        val
      }) => literal3 ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t2) => t2)), durationInfo = {
        isNegativeDuration: collapsed < 0,
        largestUnit: Object.keys(collapsed.values)[0]
      };
      return stringifyTokens(tokens, tokenToString(collapsed, durationInfo));
    }
  }
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  function combineRegexes(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}$`);
  }
  function combineExtractors(...extractors) {
    return (m) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m, cursor);
      return [{
        ...mergedVals,
        ...val
      }, zone || mergedZone, next];
    }, [{}, null, 1]).slice(0, 2);
  }
  function parse3(s2, ...patterns3) {
    if (s2 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns3) {
      const m = regex.exec(s2);
      if (m) {
        return extractor(m);
      }
    }
    return [null, null];
  }
  function simpleParse(...keys) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0;i < keys.length; i++) {
        ret[keys[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  }
  var offsetRegex = /(?:([Zz])|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:[Tt]${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  function int(match2, pos, fallback) {
    const m = match2[pos];
    return isUndefined(m) ? fallback : parseInteger(m);
  }
  function extractISOYmd(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  }
  function extractISOTime(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  }
  function extractISOOffset(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  }
  function extractIANAZone(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  }
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  function extractISODuration(match2) {
    const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s2[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
    return [{
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }];
  }
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr)
      result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  }
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  function extractRFC2822(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset2;
    if (obsOffset) {
      offset2 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset2 = 0;
    } else {
      offset2 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset2)];
  }
  function preprocessRFC2822(s2) {
    return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  }
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  function extractRFC1123Or850(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  function extractASCII(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  function parseISODate(s2) {
    return parse3(s2, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
  }
  function parseRFC2822Date(s2) {
    return parse3(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
  }
  function parseHTTPDate(s2) {
    return parse3(s2, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
  }
  function parseISODuration(s2) {
    return parse3(s2, [isoDuration, extractISODuration]);
  }
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  function parseISOTimeOnly(s2) {
    return parse3(s2, [isoTimeOnly, extractISOTimeOnly]);
  }
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  function parseSQL(s2) {
    return parse3(s2, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
  }
  var INVALID$2 = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
  var reverseUnits = orderedUnits$1.slice(0).reverse();
  function clone$1(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : {
        ...dur.values,
        ...alts.values || {}
      },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  }
  function durationToMillis(matrix, vals) {
    var _vals$milliseconds;
    let sum = (_vals$milliseconds = vals.milliseconds) != null ? _vals$milliseconds : 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum += vals[unit] * matrix[unit]["milliseconds"];
      }
    }
    return sum;
  }
  function normalizeValues(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits$1.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits$1.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }
  function removeZeroes(vals) {
    const newVals = {};
    for (const [key, value2] of Object.entries(vals)) {
      if (value2 !== 0) {
        newVals[key] = value2;
      }
    }
    return newVals;
  }

  class Duration {
    constructor(config) {
      const accurate = config.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config.matrix) {
        matrix = config.matrix;
      }
      this.values = config.values;
      this.loc = config.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    static fromMillis(count, opts) {
      return Duration.fromObject({
        milliseconds: count
      }, opts);
    }
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
      }
      return new Duration({
        values: normalizeObject(obj, Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return Duration.fromMillis(durationLike);
      } else if (Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
      }
    }
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new Duration({
          invalid
        });
      }
    }
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    static isDuration(o) {
      return o && o.isLuxonDuration || false;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
    }
    toHuman(opts = {}) {
      if (!this.isValid)
        return INVALID$2;
      const showZeros = opts.showZeros !== false;
      const l2 = orderedUnits$1.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val) || val === 0 && !showZeros) {
          return null;
        }
        return this.loc.numberFormatter({
          style: "unit",
          unitDisplay: "long",
          ...opts,
          unit: unit.slice(0, -1)
        }).format(val);
      }).filter((n2) => n2);
      return this.loc.listFormatter({
        type: "conjunction",
        style: opts.listStyle || "narrow",
        ...opts
      }).format(l2);
    }
    toObject() {
      if (!this.isValid)
        return {};
      return {
        ...this.values
      };
    }
    toISO() {
      if (!this.isValid)
        return null;
      let s2 = "P";
      if (this.years !== 0)
        s2 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0)
        s2 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0)
        s2 += this.weeks + "W";
      if (this.days !== 0)
        s2 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s2 += "T";
      if (this.hours !== 0)
        s2 += this.hours + "H";
      if (this.minutes !== 0)
        s2 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s2 += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
      if (s2 === "P")
        s2 += "T0S";
      return s2;
    }
    toISOTime(opts = {}) {
      if (!this.isValid)
        return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 86400000)
        return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, {
        zone: "UTC"
      });
      return dateTime.toISOTime(opts);
    }
    toJSON() {
      return this.toISO();
    }
    toString() {
      return this.toISO();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    toMillis() {
      if (!this.isValid)
        return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    valueOf() {
      return this.toMillis();
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration), result = {};
      for (const k of orderedUnits$1) {
        if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    mapUnits(fn) {
      if (!this.isValid)
        return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber(fn(this.values[k], k));
      }
      return clone$1(this, {
        values: result
      }, true);
    }
    get(unit) {
      return this[Duration.normalizeUnit(unit)];
    }
    set(values) {
      if (!this.isValid)
        return this;
      const mixed = {
        ...this.values,
        ...normalizeObject(values, Duration.normalizeUnit)
      };
      return clone$1(this, {
        values: mixed
      });
    }
    reconfigure({
      locale,
      numberingSystem,
      conversionAccuracy,
      matrix
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem
      });
      const opts = {
        loc,
        matrix,
        conversionAccuracy
      };
      return clone$1(this, opts);
    }
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    normalize() {
      if (!this.isValid)
        return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone$1(this, {
        values: vals
      }, true);
    }
    rescale() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone$1(this, {
        values: vals
      }, true);
    }
    shiftTo(...units) {
      if (!this.isValid)
        return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u) => Duration.normalizeUnit(u));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits$1) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1000 - i * 1000) / 1000;
        } else if (isNumber(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone$1(this, {
        values: built
      }, true);
    }
    shiftToAll() {
      if (!this.isValid)
        return this;
      return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
    }
    negate() {
      if (!this.isValid)
        return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone$1(this, {
        values: negated
      }, true);
    }
    removeZeros() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.values);
      return clone$1(this, {
        values: vals
      }, true);
    }
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === undefined || v1 === 0)
          return v2 === undefined || v2 === 0;
        return v1 === v2;
      }
      for (const u of orderedUnits$1) {
        if (!eq(this.values[u], other.values[u])) {
          return false;
        }
      }
      return true;
    }
  }
  var INVALID$1 = "Invalid Interval";
  function validateStartEnd(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
    } else {
      return null;
    }
  }

  class Interval {
    constructor(config) {
      this.s = config.start;
      this.e = config.end;
      this.invalid = config.invalid || null;
      this.isLuxonInterval = true;
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new Interval({
          invalid
        });
      }
    }
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    static after(start, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
      return Interval.fromDateTimes(dt, dt.plus(dur));
    }
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return Interval.fromDateTimes(dt.minus(dur), dt);
    }
    static fromISO(text, opts) {
      const [s2, e] = (text || "").split("/", 2);
      if (s2 && e) {
        let start, startIsValid;
        try {
          start = DateTime.fromISO(s2, opts);
          startIsValid = start.isValid;
        } catch (e2) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e, opts);
          endIsValid = end.isValid;
        } catch (e2) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return Interval.fromDateTimes(start, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e, opts);
          if (dur.isValid) {
            return Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s2, opts);
          if (dur.isValid) {
            return Interval.before(end, dur);
          }
        }
      }
      return Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    static isInterval(o) {
      return o && o.isLuxonInterval || false;
    }
    get start() {
      return this.isValid ? this.s : null;
    }
    get end() {
      return this.isValid ? this.e : null;
    }
    get lastDateTime() {
      return this.isValid ? this.e ? this.e.minus(1) : null : null;
    }
    get isValid() {
      return this.invalidReason === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    count(unit = "milliseconds", opts) {
      if (!this.isValid)
        return NaN;
      const start = this.start.startOf(unit, opts);
      let end;
      if (opts != null && opts.useLocaleWeeks) {
        end = this.end.reconfigure({
          locale: start.locale
        });
      } else {
        end = this.end;
      }
      end = end.startOf(unit, opts);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    isAfter(dateTime) {
      if (!this.isValid)
        return false;
      return this.s > dateTime;
    }
    isBefore(dateTime) {
      if (!this.isValid)
        return false;
      return this.e <= dateTime;
    }
    contains(dateTime) {
      if (!this.isValid)
        return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    set({
      start,
      end
    } = {}) {
      if (!this.isValid)
        return this;
      return Interval.fromDateTimes(start || this.s, end || this.e);
    }
    splitAt(...dateTimes) {
      if (!this.isValid)
        return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d) => this.contains(d)).sort((a, b) => a.toMillis() - b.toMillis()), results = [];
      let {
        s: s2
      } = this, i = 0;
      while (s2 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s2, next));
        s2 = next;
        i += 1;
      }
      return results;
    }
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let {
        s: s2
      } = this, idx = 1, next;
      const results = [];
      while (s2 < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s2, next));
        s2 = next;
        idx += 1;
      }
      return results;
    }
    divideEqually(numberOfParts) {
      if (!this.isValid)
        return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    abutsStart(other) {
      if (!this.isValid)
        return false;
      return +this.e === +other.s;
    }
    abutsEnd(other) {
      if (!this.isValid)
        return false;
      return +other.e === +this.s;
    }
    engulfs(other) {
      if (!this.isValid)
        return false;
      return this.s <= other.s && this.e >= other.e;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    intersection(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s > other.s ? this.s : other.s, e = this.e < other.e ? this.e : other.e;
      if (s2 >= e) {
        return null;
      } else {
        return Interval.fromDateTimes(s2, e);
      }
    }
    union(other) {
      if (!this.isValid)
        return this;
      const s2 = this.s < other.s ? this.s : other.s, e = this.e > other.e ? this.e : other.e;
      return Interval.fromDateTimes(s2, e);
    }
    static merge(intervals) {
      const [found, final] = intervals.sort((a, b) => a.s - b.s).reduce(([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      }, [[], null]);
      if (final) {
        found.push(final);
      }
      return found;
    }
    static xor(intervals) {
      let start = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a, b) => a.time - b.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start = i.time;
        } else {
          if (start && +start !== +i.time) {
            results.push(Interval.fromDateTimes(start, i.time));
          }
          start = null;
        }
      }
      return Interval.merge(results);
    }
    difference(...intervals) {
      return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    toString() {
      if (!this.isValid)
        return INVALID$1;
      return `[${this.s.toISO()} – ${this.e.toISO()})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
    }
    toISO(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    toISODate() {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    toISOTime(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    toFormat(dateFormat, {
      separator = " – "
    } = {}) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    mapEndpoints(mapFn) {
      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  }

  class Info {
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime.now().setZone(zone).set({
        month: 12
      });
      return !zone.isUniversal && proto.offset !== proto.set({
        month: 6
      }).offset;
    }
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }
    static getStartOfWeek({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getStartOfWeek();
    }
    static getMinimumDaysInFirstWeek({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
    }
    static getWeekendWeekdays({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getWeekendDays().slice();
    }
    static months(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }
    static monthsFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }
    static weekdays(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }
    static weekdaysFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }
    static meridiems({
      locale = null
    } = {}) {
      return Locale.create(locale).meridiems();
    }
    static eras(length = "short", {
      locale = null
    } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }
    static features() {
      return {
        relative: hasRelative(),
        localeWeek: hasLocaleWeekInfo()
      };
    }
  }
  function dayDiff(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  }
  function highOrderDiffs(cursor, later, units) {
    const differs = [["years", (a, b) => b.year - a.year], ["quarters", (a, b) => b.quarter - a.quarter + (b.year - a.year) * 4], ["months", (a, b) => b.month - a.month + (b.year - a.year) * 12], ["weeks", (a, b) => {
      const days = dayDiff(a, b);
      return (days - days % 7) / 7;
    }], ["days", dayDiff]];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  }
  function diff(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter((u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0);
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({
          [lowestOrder]: 1
        });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  }
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  function intUnit(regex, post = (i) => i) {
    return {
      regex,
      deser: ([s2]) => post(parseDigits(s2))
    };
  }
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  function fixListRegex(s2) {
    return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  }
  function stripInsensitivities(s2) {
    return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  }
  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
      };
    }
  }
  function offset(regex, groups) {
    return {
      regex,
      deser: ([, h, m]) => signedOffset(h, m),
      groups
    };
  }
  function simple(regex) {
    return {
      regex,
      deser: ([s2]) => s2
    };
  }
  function escapeToken(value2) {
    return value2.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function unitForToken(token, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal3 = (t2) => ({
      regex: RegExp(escapeToken(t2.val)),
      deser: ([s2]) => s2,
      literal: true
    }), unitate = (t2) => {
      if (token.literal) {
        return literal3(t2);
      }
      switch (t2.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal3(t2);
      }
    };
    const unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token;
    return unit;
  }
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  function tokenForPart(part, formatOpts, resolvedOpts) {
    const {
      type: type3,
      value: value2
    } = part;
    if (type3 === "literal") {
      const isSpace = /^\s+$/.test(value2);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value2
      };
    }
    const style = formatOpts[type3];
    let actualType = type3;
    if (type3 === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return;
  }
  function buildRegex(units) {
    const re = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re}$`, units];
  }
  function match(input, regex, handlers) {
    const matches = input.match(regex);
    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty(handlers, i)) {
          const h = handlers[i], groups = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  }
  function dateTimeFromMatches(matches) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }
    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }
    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }
    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }
    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }
    const vals = Object.keys(matches).reduce((r, k) => {
      const f = toField(k);
      if (f) {
        r[f] = matches[k];
      }
      return r;
    }, {});
    return [vals, zone, specificOffset];
  }
  var dummyDateTimeCache = null;
  function getDummyDateTime() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  }
  function maybeExpandMacroToken(token, locale) {
    if (token.literal) {
      return token;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);
    if (tokens == null || tokens.includes(undefined)) {
      return token;
    }
    return tokens;
  }
  function expandMacroTokens(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t2) => maybeExpandMacroToken(t2, locale)));
  }

  class TokenParser {
    constructor(locale, format) {
      this.locale = locale;
      this.format = format;
      this.tokens = expandMacroTokens(Formatter.parseFormat(format), locale);
      this.units = this.tokens.map((t2) => unitForToken(t2, locale));
      this.disqualifyingUnit = this.units.find((t2) => t2.invalidReason);
      if (!this.disqualifyingUnit) {
        const [regexString, handlers] = buildRegex(this.units);
        this.regex = RegExp(regexString, "i");
        this.handlers = handlers;
      }
    }
    explainFromTokens(input) {
      if (!this.isValid) {
        return {
          input,
          tokens: this.tokens,
          invalidReason: this.invalidReason
        };
      } else {
        const [rawMatches, matches] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
        if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
          throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
        }
        return {
          input,
          tokens: this.tokens,
          regex: this.regex,
          rawMatches,
          matches,
          result,
          zone,
          specificOffset
        };
      }
    }
    get isValid() {
      return !this.disqualifyingUnit;
    }
    get invalidReason() {
      return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
    }
  }
  function explainFromTokens(locale, input, format) {
    const parser = new TokenParser(locale, format);
    return parser.explainFromTokens(input);
  }
  function parseFromTokens(locale, input, format) {
    const {
      result,
      zone,
      specificOffset,
      invalidReason
    } = explainFromTokens(locale, input, format);
    return [result, zone, specificOffset, invalidReason];
  }
  function formatOptsToTokens(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p) => tokenForPart(p, formatOpts, resolvedOpts));
  }
  var INVALID = "Invalid DateTime";
  var MAX_DATE = 8640000000000000;
  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  }
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }
  function possiblyCachedLocalWeekData(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
    }
    return dt.localWeekData;
  }
  function clone4(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({
      ...current,
      ...alts,
      old: current
    });
  }
  function fixOffset(localTS, o, tz) {
    let utcGuess = localTS - o * 60 * 1000;
    const o2 = tz.offset(utcGuess);
    if (o === o2) {
      return [utcGuess, o];
    }
    utcGuess -= (o2 - o) * 60 * 1000;
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }
    return [localTS - Math.min(o2, o3) * 60 * 1000, Math.max(o2, o3)];
  }
  function tsToObj(ts, offset2) {
    ts += offset2 * 60 * 1000;
    const d = new Date(ts);
    return {
      year: d.getUTCFullYear(),
      month: d.getUTCMonth() + 1,
      day: d.getUTCDate(),
      hour: d.getUTCHours(),
      minute: d.getUTCMinutes(),
      second: d.getUTCSeconds(),
      millisecond: d.getUTCMilliseconds()
    };
  }
  function objToTS(obj, offset2, zone) {
    return fixOffset(objToLocalTS(obj), offset2, zone);
  }
  function adjustTime(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c);
    let [ts, o] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o = inst.zone.offset(ts);
    }
    return {
      ts,
      o
    };
  }
  function parseDataToDateTime(parsed, parsedZone, opts, format, text, specificOffset) {
    const {
      setZone,
      zone
    } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(new Invalid("unparsable", `the input "${text}" can't be parsed as ${format}`));
    }
  }
  function toTechFormat(dt, format, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format) : null;
  }
  function toISODate(o, extended, precision) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c = "";
    if (longFormat && o.c.year >= 0)
      c += "+";
    c += padStart(o.c.year, longFormat ? 6 : 4);
    if (precision === "year")
      return c;
    if (extended) {
      c += "-";
      c += padStart(o.c.month);
      if (precision === "month")
        return c;
      c += "-";
    } else {
      c += padStart(o.c.month);
      if (precision === "month")
        return c;
    }
    c += padStart(o.c.day);
    return c;
  }
  function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision) {
    let showSeconds = !suppressSeconds || o.c.millisecond !== 0 || o.c.second !== 0, c = "";
    switch (precision) {
      case "day":
      case "month":
      case "year":
        break;
      default:
        c += padStart(o.c.hour);
        if (precision === "hour")
          break;
        if (extended) {
          c += ":";
          c += padStart(o.c.minute);
          if (precision === "minute")
            break;
          if (showSeconds) {
            c += ":";
            c += padStart(o.c.second);
          }
        } else {
          c += padStart(o.c.minute);
          if (precision === "minute")
            break;
          if (showSeconds) {
            c += padStart(o.c.second);
          }
        }
        if (precision === "second")
          break;
        if (showSeconds && (!suppressMilliseconds || o.c.millisecond !== 0)) {
          c += ".";
          c += padStart(o.c.millisecond, 3);
        }
    }
    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c += "Z";
      } else if (o.o < 0) {
        c += "-";
        c += padStart(Math.trunc(-o.o / 60));
        c += ":";
        c += padStart(Math.trunc(-o.o % 60));
      } else {
        c += "+";
        c += padStart(Math.trunc(o.o / 60));
        c += ":";
        c += padStart(Math.trunc(o.o % 60));
      }
    }
    if (extendedZone) {
      c += "[" + o.zone.ianaName + "]";
    }
    return c;
  }
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  function normalizeUnit(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  }
  function normalizeUnitWithLocalWeeks(unit) {
    switch (unit.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit);
    }
  }
  function guessOffsetForZone(zone) {
    if (zoneOffsetTs === undefined) {
      zoneOffsetTs = Settings.now();
    }
    if (zone.type !== "iana") {
      return zone.offset(zoneOffsetTs);
    }
    const zoneName = zone.name;
    let offsetGuess = zoneOffsetGuessCache.get(zoneName);
    if (offsetGuess === undefined) {
      offsetGuess = zone.offset(zoneOffsetTs);
      zoneOffsetGuessCache.set(zoneName, offsetGuess);
    }
    return offsetGuess;
  }
  function quickDT(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    }
    const loc = Locale.fromObject(opts);
    let ts, o;
    if (!isUndefined(obj.year)) {
      for (const u of orderedUnits) {
        if (isUndefined(obj[u])) {
          obj[u] = defaultUnitValues[u];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = guessOffsetForZone(zone);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = Settings.now();
    }
    return new DateTime({
      ts,
      zone,
      loc,
      o
    });
  }
  function diffRelative(start, end, opts) {
    const round = isUndefined(opts.round) ? true : opts.round, rounding = isUndefined(opts.rounding) ? "trunc" : opts.rounding, format = (c, unit) => {
      c = roundTo(c, round || opts.calendary ? 0 : 2, opts.calendary ? "round" : rounding);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else
          return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  }
  function lastOpts(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  }
  var zoneOffsetTs;
  var zoneOffsetGuessCache = new Map;

  class DateTime {
    constructor(config) {
      const zone = config.zone || Settings.defaultZone;
      let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
      let c = null, o = null;
      if (!invalid) {
        const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
        if (unchanged) {
          [c, o] = [config.old.c, config.old.o];
        } else {
          const ot = isNumber(config.o) && !config.old ? config.o : zone.offset(this.ts);
          c = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c.year) ? new Invalid("invalid input") : null;
          c = invalid ? null : c;
          o = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c;
      this.o = o;
      this.isLuxonDateTime = true;
    }
    static now() {
      return new DateTime({});
    }
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
      return quickDT({
        year,
        month,
        day,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({
        year,
        month,
        day,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static fromJSDate(date3, options = {}) {
      const ts = isDate(date3) ? date3.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return DateTime.invalid("Timestamp out of range");
      } else {
        return new DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new DateTime({
          ts: seconds * 1000,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const {
        minDaysInFirstWeek,
        startOfWeek
      } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u of units) {
        const v = normalized[u];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u] = defaultValues[u];
        } else {
          normalized[u] = objNow[u];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
      }
      if (!inst.isValid) {
        return DateTime.invalid(inst.invalid);
      }
      return inst;
    }
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    static fromString(text, fmt, opts = {}) {
      return DateTime.fromFormat(text, fmt, opts);
    }
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new DateTime({
          invalid
        });
      }
    }
    static isDateTime(o) {
      return o && o.isLuxonDateTime || false;
    }
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t2) => t2 ? t2.val : null).join("");
    }
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t2) => t2.val).join("");
    }
    static resetCache() {
      zoneOffsetTs = undefined;
      zoneOffsetGuessCache.clear();
    }
    get(unit) {
      return this[unit];
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    get zone() {
      return this._zone;
    }
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    get monthShort() {
      return this.isValid ? Info.months("short", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get monthLong() {
      return this.isValid ? Info.months("long", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1,
          day: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 86400000;
      const minuteMs = 60000;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c1 = tsToObj(ts1, o1);
      const c2 = tsToObj(ts2, o2);
      if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
        return [clone4(this, {
          ts: ts1
        }), clone4(this, {
          ts: ts2
        })];
      }
      return [this];
    }
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
    }
    resolvedLocaleOptions(opts = {}) {
      const {
        locale,
        numberingSystem,
        calendar
      } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
      return {
        locale,
        numberingSystem,
        outputCalendar: calendar
      };
    }
    toUTC(offset2 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset2), opts);
    }
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    setZone(zone, {
      keepLocalTime = false,
      keepCalendarTime = false
    } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone4(this, {
          ts: newTS,
          zone
        });
      }
    }
    reconfigure({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem,
        outputCalendar
      });
      return clone4(this, {
        loc
      });
    }
    setLocale(locale) {
      return this.reconfigure({
        locale
      });
    }
    set(values) {
      if (!this.isValid)
        return this;
      const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
      const {
        minDaysInFirstWeek,
        startOfWeek
      } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian({
          ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek),
          ...normalized
        }, minDaysInFirstWeek, startOfWeek);
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({
          ...gregorianToOrdinal(this.c),
          ...normalized
        });
      } else {
        mixed = {
          ...this.toObject(),
          ...normalized
        };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone4(this, {
        ts,
        o
      });
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return clone4(this, adjustTime(this, dur));
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone4(this, adjustTime(this, dur));
    }
    startOf(unit, {
      useLocaleWeeks = false
    } = {}) {
      if (!this.isValid)
        return this;
      const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        case "quarters":
        case "months":
          o.day = 1;
        case "weeks":
        case "days":
          o.hour = 0;
        case "hours":
          o.minute = 0;
        case "minutes":
          o.second = 0;
        case "seconds":
          o.millisecond = 0;
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const {
            weekday
          } = this;
          if (weekday < startOfWeek) {
            o.weekNumber = this.weekNumber - 1;
          }
          o.weekday = startOfWeek;
        } else {
          o.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }
      return this.set(o);
    }
    endOf(unit, opts) {
      return this.isValid ? this.plus({
        [unit]: 1
      }).startOf(unit, opts).minus(1) : this;
    }
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID;
    }
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false,
      precision = "milliseconds"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      precision = normalizeUnit(precision);
      const ext = format === "extended";
      let c = toISODate(this, ext, precision);
      if (orderedUnits.indexOf(precision) >= 3)
        c += "T";
      c += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision);
      return c;
    }
    toISODate({
      format = "extended",
      precision = "day"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format === "extended", normalizeUnit(precision));
    }
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended",
      precision = "milliseconds"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      precision = normalizeUnit(precision);
      let c = includePrefix && orderedUnits.indexOf(precision) >= 3 ? "T" : "";
      return c + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone, precision);
    }
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    toSQLTime({
      includeOffset = true,
      includeZone = false,
      includeOffsetSpace = true
    } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    toString() {
      return this.isValid ? this.toISO() : INVALID;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    valueOf() {
      return this.toMillis();
    }
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    toSeconds() {
      return this.isValid ? this.ts / 1000 : NaN;
    }
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1000) : NaN;
    }
    toJSON() {
      return this.toISO();
    }
    toBSON() {
      return this.toJSDate();
    }
    toObject(opts = {}) {
      if (!this.isValid)
        return {};
      const base = {
        ...this.c
      };
      if (opts.includeConfig) {
        base.outputCalendar = this.outputCalendar;
        base.numberingSystem = this.loc.numberingSystem;
        base.locale = this.loc.locale;
      }
      return base;
    }
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = {
        locale: this.locale,
        numberingSystem: this.numberingSystem,
        ...opts
      };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(DateTime.now(), unit, opts);
    }
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    hasSame(otherDateTime, unit, opts) {
      if (!this.isValid)
        return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, {
        keepLocalTime: true
      });
      return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
    }
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    toRelative(options = {}) {
      if (!this.isValid)
        return null;
      const base = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = undefined;
      }
      return diffRelative(base, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    toRelativeCalendar(options = {}) {
      if (!this.isValid)
        return null;
      return diffRelative(options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    static min(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    static max(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    static fromFormatExplain(text, fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    static fromStringExplain(text, fmt, options = {}) {
      return DateTime.fromFormatExplain(text, fmt, options);
    }
    static buildFormatParser(fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return new TokenParser(localeToUse, fmt);
    }
    static fromFormatParser(text, formatParser, opts = {}) {
      if (isUndefined(text) || isUndefined(formatParser)) {
        throw new InvalidArgumentError("fromFormatParser requires an input string and a format parser");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      if (!localeToUse.equals(formatParser.locale)) {
        throw new InvalidArgumentError(`fromFormatParser called with a locale of ${localeToUse}, ` + `but the format parser was created for ${formatParser.locale}`);
      }
      const {
        result,
        zone,
        specificOffset,
        invalidReason
      } = formatParser.explainFromTokens(text);
      if (invalidReason) {
        return DateTime.invalid(invalidReason);
      } else {
        return parseDataToDateTime(result, zone, opts, `format ${formatParser.format}`, text, specificOffset);
      }
    }
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    static get DATE_MED() {
      return DATE_MED;
    }
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    static get DATE_FULL() {
      return DATE_FULL;
    }
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }
  function friendlyDateTime(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
    }
  }
  var VERSION = "3.7.1";
  exports.DateTime = DateTime;
  exports.Duration = Duration;
  exports.FixedOffsetZone = FixedOffsetZone;
  exports.IANAZone = IANAZone;
  exports.Info = Info;
  exports.Interval = Interval;
  exports.InvalidZone = InvalidZone;
  exports.Settings = Settings;
  exports.SystemZone = SystemZone;
  exports.VERSION = VERSION;
  exports.Zone = Zone;
});

// node_modules/cron/dist/constants.js
var require_constants = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RE_RANGE = exports.RE_WILDCARDS = exports.PRESETS = exports.TIME_UNITS_LEN = exports.TIME_UNITS = exports.TIME_UNITS_MAP = exports.ALIASES = exports.PARSE_DEFAULTS = exports.CONSTRAINTS = undefined;
  exports.CONSTRAINTS = Object.freeze({
    second: [0, 59],
    minute: [0, 59],
    hour: [0, 23],
    dayOfMonth: [1, 31],
    month: [1, 12],
    dayOfWeek: [0, 7]
  });
  exports.PARSE_DEFAULTS = Object.freeze({
    second: "0",
    minute: "*",
    hour: "*",
    dayOfMonth: "*",
    month: "*",
    dayOfWeek: "*"
  });
  exports.ALIASES = Object.freeze({
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  });
  exports.TIME_UNITS_MAP = Object.freeze({
    SECOND: "second",
    MINUTE: "minute",
    HOUR: "hour",
    DAY_OF_MONTH: "dayOfMonth",
    MONTH: "month",
    DAY_OF_WEEK: "dayOfWeek"
  });
  exports.TIME_UNITS = Object.freeze(Object.values(exports.TIME_UNITS_MAP));
  exports.TIME_UNITS_LEN = exports.TIME_UNITS.length;
  exports.PRESETS = Object.freeze({
    "@yearly": "0 0 0 1 1 *",
    "@monthly": "0 0 0 1 * *",
    "@weekly": "0 0 0 * * 0",
    "@daily": "0 0 0 * * *",
    "@hourly": "0 0 * * * *",
    "@minutely": "0 * * * * *",
    "@secondly": "* * * * * *",
    "@weekdays": "0 0 0 * * 1-5",
    "@weekends": "0 0 0 * * 0,6"
  });
  exports.RE_WILDCARDS = /\*/g;
  exports.RE_RANGE = /^(\d+)(?:-(\d+))?(?:\/(\d+))?$/g;
});

// node_modules/cron/dist/errors.js
var require_errors3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ExclusiveParametersError = exports.CronError = undefined;

  class CronError extends Error {
  }
  exports.CronError = CronError;

  class ExclusiveParametersError extends CronError {
    constructor(param1, param2) {
      super(`You can't specify both ${param1} and ${param2}`);
    }
  }
  exports.ExclusiveParametersError = ExclusiveParametersError;
});

// node_modules/cron/dist/time.js
var require_time = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CronTime = undefined;
  var luxon_1 = require_luxon();
  var constants_1 = require_constants();
  var errors_1 = require_errors3();

  class CronTime {
    constructor(source, timeZone, utcOffset) {
      this.realDate = false;
      this.second = {};
      this.minute = {};
      this.hour = {};
      this.dayOfMonth = {};
      this.month = {};
      this.dayOfWeek = {};
      if (timeZone != null && utcOffset != null) {
        throw new errors_1.ExclusiveParametersError("timeZone", "utcOffset");
      }
      if (timeZone) {
        const dt = luxon_1.DateTime.fromObject({}, { zone: timeZone });
        if (!dt.isValid) {
          throw new errors_1.CronError("Invalid timezone.");
        }
        this.timeZone = timeZone;
      }
      if (utcOffset != null) {
        this.utcOffset = utcOffset;
      }
      if (timeZone == null && utcOffset == null) {
        const systemTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        this.timeZone = systemTimezone;
      }
      if (source instanceof Date || source instanceof luxon_1.DateTime) {
        this.source = source instanceof Date ? luxon_1.DateTime.fromJSDate(source) : source;
        this.realDate = true;
      } else {
        this.source = source;
        this._parse(this.source);
      }
    }
    static validateCronExpression(cronExpression) {
      try {
        new CronTime(cronExpression);
        return {
          valid: true
        };
      } catch (error3) {
        return {
          valid: false,
          error: error3
        };
      }
    }
    _getWeekDay(date3) {
      return date3.weekday === 7 ? 0 : date3.weekday;
    }
    sendAt(i) {
      let date3 = this.realDate && this.source instanceof luxon_1.DateTime ? this.source : luxon_1.DateTime.utc();
      if (this.timeZone) {
        date3 = date3.setZone(this.timeZone);
      }
      if (this.utcOffset !== undefined) {
        const sign = this.utcOffset < 0 ? "-" : "+";
        const offsetHours = Math.trunc(this.utcOffset / 60);
        const offsetHoursStr = String(Math.abs(offsetHours)).padStart(2, "0");
        const offsetMins = Math.abs(this.utcOffset - offsetHours * 60);
        const offsetMinsStr = String(offsetMins).padStart(2, "0");
        const utcZone = `UTC${sign}${offsetHoursStr}:${offsetMinsStr}`;
        date3 = date3.setZone(utcZone);
        if (!date3.isValid) {
          throw new errors_1.CronError("ERROR: You specified an invalid UTC offset.");
        }
      }
      if (this.realDate) {
        if (luxon_1.DateTime.local() > date3) {
          throw new errors_1.CronError("WARNING: Date in past. Will never be fired.");
        }
        return date3;
      }
      if (i === undefined || isNaN(i) || i < 0) {
        const nextDate = this.getNextDateFrom(date3);
        return nextDate;
      } else {
        const dates = [];
        for (;i > 0; i--) {
          date3 = this.getNextDateFrom(date3);
          dates.push(date3);
        }
        return dates;
      }
    }
    getTimeout() {
      return this.sendAt().toMillis() - luxon_1.DateTime.local().toMillis();
    }
    toString() {
      return this.toJSON().join(" ");
    }
    toJSON() {
      return constants_1.TIME_UNITS.map((unit) => {
        return this._wcOrAll(unit);
      });
    }
    getNextDateFrom(start, timeZone) {
      var _a, _b;
      if (start instanceof Date) {
        start = luxon_1.DateTime.fromJSDate(start);
      }
      if (timeZone) {
        start = start.setZone(timeZone);
      } else {
        timeZone = (_a = start.zone.zoneName) !== null && _a !== undefined ? _a : start.zone.fixed;
      }
      let date3 = luxon_1.DateTime.fromFormat(`${start.year}-${start.month}-${start.day} ${start.hour}:${start.minute}:${start.second}`, "yyyy-M-d H:m:s", {
        zone: "UTC"
      });
      const firstDate = date3.toMillis();
      if (!this.realDate) {
        if (date3.millisecond > 0) {
          date3 = date3.set({ millisecond: 0, second: date3.second + 1 });
        }
      }
      if (!date3.isValid) {
        throw new errors_1.CronError("ERROR: You specified an invalid date.");
      }
      const maxMatch = luxon_1.DateTime.now().plus({ years: 8 });
      while (true) {
        if (date3 > maxMatch) {
          throw new errors_1.CronError(`Something went wrong. No execution date was found in the next 8 years.
							Please provide the following string if you would like to help debug:
							Time Zone: ${(_b = timeZone === null || timeZone === undefined ? undefined : timeZone.toString()) !== null && _b !== undefined ? _b : '""'} - Cron String: ${this.source.toString()} - UTC offset: ${date3.offset} - current Date: ${luxon_1.DateTime.local().toString()}`);
        }
        if (!(date3.month in this.month) && Object.keys(this.month).length !== 12) {
          date3 = date3.plus({ month: 1 });
          date3 = date3.set({ day: 1, hour: 0, minute: 0, second: 0 });
          continue;
        }
        if (!(date3.day in this.dayOfMonth) && Object.keys(this.dayOfMonth).length !== 31 && !((this._getWeekDay(date3) in this.dayOfWeek) && Object.keys(this.dayOfWeek).length !== 7) || !(this._getWeekDay(date3) in this.dayOfWeek) && Object.keys(this.dayOfWeek).length !== 7 && !((date3.day in this.dayOfMonth) && Object.keys(this.dayOfMonth).length !== 31)) {
          date3 = date3.plus({ days: 1 });
          date3 = date3.set({ hour: 0, minute: 0, second: 0 });
          continue;
        }
        if (!(date3.hour in this.hour) && Object.keys(this.hour).length !== 24) {
          date3 = date3.plus({ hour: 1 });
          date3 = date3.set({ minute: 0, second: 0 });
          continue;
        }
        if (!(date3.minute in this.minute) && Object.keys(this.minute).length !== 60) {
          date3 = date3.plus({ minute: 1 });
          date3 = date3.set({ second: 0 });
          continue;
        }
        if (date3.toMillis() === firstDate || !(date3.second in this.second) && Object.keys(this.second).length !== 60) {
          date3 = date3.plus({ second: 1 });
          continue;
        }
        break;
      }
      const expectedHour = date3.hour;
      const expectedMinute = date3.minute;
      date3 = luxon_1.DateTime.fromFormat(`${date3.year}-${date3.month}-${date3.day} ${date3.hour}:${date3.minute}:${date3.second}`, "yyyy-M-d H:m:s", {
        zone: timeZone
      });
      const nonDSTReferenceDate = luxon_1.DateTime.fromFormat(`${date3.year}-1-1 0:0:0`, "yyyy-M-d H:m:s", { zone: timeZone });
      if ((expectedHour !== date3.hour || expectedMinute !== date3.minute) && nonDSTReferenceDate.offset !== date3.offset) {
        while (date3.minus({ minute: 1 }).offset !== nonDSTReferenceDate.offset) {
          date3 = date3.minus({ minute: 1 });
        }
        return date3;
      }
      const hourTestDate = date3.minus({ hour: 1 });
      const twoHourTestDate = date3.minus({ hour: 2 });
      if ((hourTestDate.hour === date3.hour || twoHourTestDate.hour === hourTestDate.hour) && hourTestDate > start) {
        date3 = hourTestDate;
      }
      const halfHourTestDate = date3.minus({ minute: 30 });
      if ((halfHourTestDate.minute === date3.minute || hourTestDate.minute === halfHourTestDate.minute) && halfHourTestDate > start) {
        date3 = halfHourTestDate;
      }
      return date3;
    }
    _wcOrAll(unit) {
      if (this._hasAll(unit)) {
        return "*";
      }
      const all = [];
      for (const time in this[unit]) {
        all.push(time);
      }
      return all.join(",");
    }
    _hasAll(unit) {
      const constraints = constants_1.CONSTRAINTS[unit];
      const low = constraints[0];
      const high = unit === constants_1.TIME_UNITS_MAP.DAY_OF_WEEK ? constraints[1] - 1 : constraints[1];
      for (let i = low, n = high;i < n; i++) {
        if (!(i in this[unit])) {
          return false;
        }
      }
      return true;
    }
    _parse(source) {
      var _a;
      source = source.toLowerCase();
      if (Object.keys(constants_1.PRESETS).includes(source)) {
        source = constants_1.PRESETS[source];
      }
      source = source.replace(/[a-z]{1,3}/gi, (alias) => {
        if (Object.keys(constants_1.ALIASES).includes(alias)) {
          return constants_1.ALIASES[alias].toString();
        }
        throw new errors_1.CronError(`Unknown alias: ${alias}`);
      });
      const units = source.trim().split(/\s+/);
      if (units.length < constants_1.TIME_UNITS_LEN - 1) {
        throw new errors_1.CronError("Too few fields");
      }
      if (units.length > constants_1.TIME_UNITS_LEN) {
        throw new errors_1.CronError("Too many fields");
      }
      const unitsLen = units.length;
      for (const unit of constants_1.TIME_UNITS) {
        const i = constants_1.TIME_UNITS.indexOf(unit);
        const cur = (_a = units[i - (constants_1.TIME_UNITS_LEN - unitsLen)]) !== null && _a !== undefined ? _a : constants_1.PARSE_DEFAULTS[unit];
        this._parseField(cur, unit);
      }
    }
    _parseField(value2, unit) {
      const typeObj = this[unit];
      let pointer2;
      const constraints = constants_1.CONSTRAINTS[unit];
      const low = constraints[0];
      const high = constraints[1];
      const fields = value2.split(",");
      fields.forEach((field) => {
        const wildcardIndex = field.indexOf("*");
        if (wildcardIndex !== -1 && wildcardIndex !== 0) {
          throw new errors_1.CronError(`Field (${field}) has an invalid wildcard expression`);
        }
      });
      value2 = value2.replace(constants_1.RE_WILDCARDS, `${low}-${high}`);
      const allRanges = value2.split(",");
      for (const range of allRanges) {
        const match = [...range.matchAll(constants_1.RE_RANGE)][0];
        if ((match === null || match === undefined ? undefined : match[1]) !== undefined) {
          const [, mLower, mUpper, mStep] = match;
          let lower = parseInt(mLower, 10);
          let upper = mUpper !== undefined ? parseInt(mUpper, 10) : undefined;
          const wasStepDefined = mStep !== undefined;
          const step = parseInt(mStep !== null && mStep !== undefined ? mStep : "1", 10);
          if (step === 0) {
            throw new errors_1.CronError(`Field (${unit}) has a step of zero`);
          }
          if (upper !== undefined && lower > upper) {
            throw new errors_1.CronError(`Field (${unit}) has an invalid range`);
          }
          const isOutOfRange = lower < low || upper !== undefined && upper > high || upper === undefined && lower > high;
          if (isOutOfRange) {
            throw new errors_1.CronError(`Field value (${value2}) is out of range`);
          }
          lower = Math.min(Math.max(low, ~~Math.abs(lower)), high);
          if (upper !== undefined) {
            upper = Math.min(high, ~~Math.abs(upper));
          } else {
            upper = wasStepDefined ? high : lower;
          }
          pointer2 = lower;
          do {
            typeObj[pointer2] = true;
            pointer2 += step;
          } while (pointer2 <= upper);
          if (unit === "dayOfWeek") {
            if (!typeObj[0] && !!typeObj[7])
              typeObj[0] = typeObj[7];
            delete typeObj[7];
          }
        } else {
          throw new errors_1.CronError(`Field (${unit}) cannot be parsed`);
        }
      }
    }
  }
  exports.CronTime = CronTime;
});

// node_modules/cron/dist/job.js
var require_job = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CronJob = undefined;
  var child_process_1 = __require("child_process");
  var errors_1 = require_errors3();
  var time_1 = require_time();

  class CronJob {
    get isActive() {
      return this._isActive;
    }
    get isCallbackRunning() {
      return this._isCallbackRunning;
    }
    constructor(cronTime, onTick, onComplete, start, timeZone, context, runOnInit, utcOffset, unrefTimeout, waitForCompletion, errorHandler, name, threshold) {
      this.unrefTimeout = false;
      this.lastExecution = null;
      this.runOnce = false;
      this.waitForCompletion = false;
      this.threshold = 250;
      this._isActive = false;
      this._isCallbackRunning = false;
      this._callbacks = [];
      this.context = context !== null && context !== undefined ? context : this;
      this.waitForCompletion = Boolean(waitForCompletion);
      this.errorHandler = errorHandler;
      if (timeZone != null && utcOffset != null) {
        throw new errors_1.ExclusiveParametersError("timeZone", "utcOffset");
      }
      if (timeZone != null) {
        this.cronTime = new time_1.CronTime(cronTime, timeZone, null);
      } else if (utcOffset != null) {
        this.cronTime = new time_1.CronTime(cronTime, null, utcOffset);
      } else {
        this.cronTime = new time_1.CronTime(cronTime, timeZone, utcOffset);
      }
      if (unrefTimeout != null) {
        this.unrefTimeout = unrefTimeout;
      }
      if (onComplete != null) {
        this.onComplete = this._fnWrap(onComplete);
      }
      if (threshold != null) {
        this.threshold = Math.abs(threshold);
      }
      if (name != null) {
        this.name = name;
      }
      if (this.cronTime.realDate) {
        this.runOnce = true;
      }
      this.addCallback(this._fnWrap(onTick));
      if (runOnInit) {
        this.lastExecution = new Date;
        this.fireOnTick();
      }
      if (start)
        this.start();
    }
    static from(params) {
      if (params.timeZone != null && params.utcOffset != null) {
        throw new errors_1.ExclusiveParametersError("timeZone", "utcOffset");
      }
      if (params.timeZone != null) {
        return new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, params.timeZone, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout, params.waitForCompletion, params.errorHandler, params.name, params.threshold);
      } else if (params.utcOffset != null) {
        return new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, null, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout, params.waitForCompletion, params.errorHandler, params.name, params.threshold);
      } else {
        return new CronJob(params.cronTime, params.onTick, params.onComplete, params.start, params.timeZone, params.context, params.runOnInit, params.utcOffset, params.unrefTimeout, params.waitForCompletion, params.errorHandler, params.name, params.threshold);
      }
    }
    _fnWrap(cmd) {
      var _a, _b;
      switch (typeof cmd) {
        case "function": {
          return cmd;
        }
        case "string": {
          const [command, ...args] = cmd.split(" ");
          return child_process_1.spawn.bind(undefined, command !== null && command !== undefined ? command : cmd, args, {});
        }
        case "object": {
          return child_process_1.spawn.bind(undefined, cmd.command, (_a = cmd.args) !== null && _a !== undefined ? _a : [], (_b = cmd.options) !== null && _b !== undefined ? _b : {});
        }
      }
    }
    addCallback(callback) {
      if (typeof callback === "function") {
        this._callbacks.push(callback);
      }
    }
    setTime(time) {
      if (!(time instanceof time_1.CronTime)) {
        throw new errors_1.CronError("time must be an instance of CronTime.");
      }
      const wasRunning = this._isActive;
      this.stop();
      this.cronTime = time;
      if (time.realDate)
        this.runOnce = true;
      if (wasRunning)
        this.start();
    }
    nextDate() {
      return this.cronTime.sendAt();
    }
    fireOnTick() {
      return __awaiter(this, undefined, undefined, function* () {
        if (this.waitForCompletion && this._isCallbackRunning)
          return;
        this._isCallbackRunning = true;
        try {
          for (const callback of this._callbacks) {
            const result = callback.call(this.context, this.onComplete);
            if (this.waitForCompletion)
              yield result;
          }
        } catch (error3) {
          if (this.errorHandler != null)
            this.errorHandler(error3);
          else
            console.error("[Cron] error in callback", error3);
        } finally {
          this._isCallbackRunning = false;
        }
      });
    }
    nextDates(i) {
      return this.cronTime.sendAt(i !== null && i !== undefined ? i : 0);
    }
    start() {
      if (this._isActive)
        return;
      this._isActive = true;
      const MAXDELAY = 2147483647;
      let timeout = this.cronTime.getTimeout();
      let remaining = 0;
      let startTime;
      const setCronTimeout = (t2) => {
        startTime = Date.now();
        this._timeout = setTimeout(callbackWrapper, t2);
        if (this.unrefTimeout && typeof this._timeout.unref === "function") {
          this._timeout.unref();
        }
      };
      const callbackWrapper = () => {
        const diff = startTime + timeout - Date.now();
        if (diff > 0) {
          let newTimeout = this.cronTime.getTimeout();
          if (newTimeout > diff) {
            newTimeout = diff;
          }
          remaining += newTimeout;
        }
        if (remaining) {
          if (remaining > MAXDELAY) {
            remaining -= MAXDELAY;
            timeout = MAXDELAY;
          } else {
            timeout = remaining;
            remaining = 0;
          }
          setCronTimeout(timeout);
        } else {
          this.lastExecution = new Date;
          this._isActive = false;
          if (!this.runOnce)
            this.start();
          this.fireOnTick();
        }
      };
      if (timeout >= 0) {
        if (timeout > MAXDELAY) {
          remaining = timeout - MAXDELAY;
          timeout = MAXDELAY;
        }
        setCronTimeout(timeout);
      } else {
        const absoluteTimeout = Math.abs(timeout);
        const message = `[Cron] Missed execution deadline by ${absoluteTimeout}ms for job${this.name ? ` "${this.name}"` : ""} with cron expression '${String(this.cronTime.source)}'`;
        if (absoluteTimeout <= this.threshold) {
          console.warn(`${message}. Executing immediately.`);
          this.lastExecution = new Date;
          this.fireOnTick();
        } else {
          console.warn(`${message}. Skipping execution as it exceeds threshold (${this.threshold}ms).`);
        }
        timeout = this.cronTime.getTimeout();
        setCronTimeout(timeout);
      }
    }
    lastDate() {
      return this.lastExecution;
    }
    _executeOnComplete() {
      return __awaiter(this, undefined, undefined, function* () {
        if (typeof this.onComplete !== "function")
          return;
        try {
          yield this.onComplete.call(this.context);
        } catch (error3) {
          console.error("[Cron] error in onComplete callback:", error3);
        }
      });
    }
    _waitForJobCompletion() {
      return __awaiter(this, undefined, undefined, function* () {
        while (this._isCallbackRunning) {
          yield new Promise((resolve) => setTimeout(resolve, 100));
        }
      });
    }
    stop() {
      if (this._timeout)
        clearTimeout(this._timeout);
      this._isActive = false;
      if (!this.waitForCompletion) {
        this._executeOnComplete();
        return;
      }
      return Promise.resolve().then(() => __awaiter(this, undefined, undefined, function* () {
        yield this._waitForJobCompletion();
        yield this._executeOnComplete();
      }));
    }
  }
  exports.CronJob = CronJob;
});

// node_modules/cron/dist/index.js
var require_dist2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.validateCronExpression = exports.timeout = exports.sendAt = exports.CronTime = exports.CronJob = undefined;
  var time_1 = require_time();
  var job_1 = require_job();
  Object.defineProperty(exports, "CronJob", { enumerable: true, get: function() {
    return job_1.CronJob;
  } });
  var time_2 = require_time();
  Object.defineProperty(exports, "CronTime", { enumerable: true, get: function() {
    return time_2.CronTime;
  } });
  var sendAt = (cronTime) => new time_1.CronTime(cronTime).sendAt();
  exports.sendAt = sendAt;
  var timeout = (cronTime) => new time_1.CronTime(cronTime).getTimeout();
  exports.timeout = timeout;
  exports.validateCronExpression = time_1.CronTime.validateCronExpression;
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS((exports, module) => {
  module.exports = function() {
    return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
  };
});

// node_modules/qrcode/lib/core/utils.js
var require_utils4 = __commonJS((exports) => {
  var toSJISFunction;
  var CODEWORDS_COUNT = [
    0,
    26,
    44,
    70,
    100,
    134,
    172,
    196,
    242,
    292,
    346,
    404,
    466,
    532,
    581,
    655,
    733,
    815,
    901,
    991,
    1085,
    1156,
    1258,
    1364,
    1474,
    1588,
    1706,
    1828,
    1921,
    2051,
    2185,
    2323,
    2465,
    2611,
    2761,
    2876,
    3034,
    3196,
    3362,
    3532,
    3706
  ];
  exports.getSymbolSize = function getSymbolSize(version) {
    if (!version)
      throw new Error('"version" cannot be null or undefined');
    if (version < 1 || version > 40)
      throw new Error('"version" should be in range from 1 to 40');
    return version * 4 + 17;
  };
  exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
    return CODEWORDS_COUNT[version];
  };
  exports.getBCHDigit = function(data) {
    let digit = 0;
    while (data !== 0) {
      digit++;
      data >>>= 1;
    }
    return digit;
  };
  exports.setToSJISFunction = function setToSJISFunction(f) {
    if (typeof f !== "function") {
      throw new Error('"toSJISFunc" is not a valid function.');
    }
    toSJISFunction = f;
  };
  exports.isKanjiModeEnabled = function() {
    return typeof toSJISFunction !== "undefined";
  };
  exports.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS((exports) => {
  exports.L = { bit: 1 };
  exports.M = { bit: 0 };
  exports.Q = { bit: 3 };
  exports.H = { bit: 2 };
  function fromString(string3) {
    if (typeof string3 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string3.toLowerCase();
    switch (lcStr) {
      case "l":
      case "low":
        return exports.L;
      case "m":
      case "medium":
        return exports.M;
      case "q":
      case "quartile":
        return exports.Q;
      case "h":
      case "high":
        return exports.H;
      default:
        throw new Error("Unknown EC Level: " + string3);
    }
  }
  exports.isValid = function isValid(level) {
    return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
  };
  exports.from = function from(value2, defaultValue) {
    if (exports.isValid(value2)) {
      return value2;
    }
    try {
      return fromString(value2);
    } catch (e) {
      return defaultValue;
    }
  };
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS((exports, module) => {
  function BitBuffer() {
    this.buffer = [];
    this.length = 0;
  }
  BitBuffer.prototype = {
    get: function(index) {
      const bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
    },
    put: function(num, length) {
      for (let i = 0;i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) === 1);
      }
    },
    getLengthInBits: function() {
      return this.length;
    },
    putBit: function(bit) {
      const bufIndex = Math.floor(this.length / 8);
      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }
      if (bit) {
        this.buffer[bufIndex] |= 128 >>> this.length % 8;
      }
      this.length++;
    }
  };
  module.exports = BitBuffer;
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS((exports, module) => {
  function BitMatrix(size) {
    if (!size || size < 1) {
      throw new Error("BitMatrix size must be defined and greater than 0");
    }
    this.size = size;
    this.data = new Uint8Array(size * size);
    this.reservedBit = new Uint8Array(size * size);
  }
  BitMatrix.prototype.set = function(row, col, value2, reserved) {
    const index = row * this.size + col;
    this.data[index] = value2;
    if (reserved)
      this.reservedBit[index] = true;
  };
  BitMatrix.prototype.get = function(row, col) {
    return this.data[row * this.size + col];
  };
  BitMatrix.prototype.xor = function(row, col, value2) {
    this.data[row * this.size + col] ^= value2;
  };
  BitMatrix.prototype.isReserved = function(row, col) {
    return this.reservedBit[row * this.size + col];
  };
  module.exports = BitMatrix;
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS((exports) => {
  var getSymbolSize = require_utils4().getSymbolSize;
  exports.getRowColCoords = function getRowColCoords(version) {
    if (version === 1)
      return [];
    const posCount = Math.floor(version / 7) + 2;
    const size = getSymbolSize(version);
    const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
    const positions = [size - 7];
    for (let i = 1;i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals;
    }
    positions.push(6);
    return positions.reverse();
  };
  exports.getPositions = function getPositions(version) {
    const coords = [];
    const pos = exports.getRowColCoords(version);
    const posLength = pos.length;
    for (let i = 0;i < posLength; i++) {
      for (let j = 0;j < posLength; j++) {
        if (i === 0 && j === 0 || i === 0 && j === posLength - 1 || i === posLength - 1 && j === 0) {
          continue;
        }
        coords.push([pos[i], pos[j]]);
      }
    }
    return coords;
  };
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS((exports) => {
  var getSymbolSize = require_utils4().getSymbolSize;
  var FINDER_PATTERN_SIZE = 7;
  exports.getPositions = function getPositions(version) {
    const size = getSymbolSize(version);
    return [
      [0, 0],
      [size - FINDER_PATTERN_SIZE, 0],
      [0, size - FINDER_PATTERN_SIZE]
    ];
  };
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS((exports) => {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7
  };
  var PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10
  };
  exports.isValid = function isValid(mask) {
    return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
  };
  exports.from = function from(value2) {
    return exports.isValid(value2) ? parseInt(value2, 10) : undefined;
  };
  exports.getPenaltyN1 = function getPenaltyN1(data) {
    const size = data.size;
    let points = 0;
    let sameCountCol = 0;
    let sameCountRow = 0;
    let lastCol = null;
    let lastRow = null;
    for (let row = 0;row < size; row++) {
      sameCountCol = sameCountRow = 0;
      lastCol = lastRow = null;
      for (let col = 0;col < size; col++) {
        let module2 = data.get(row, col);
        if (module2 === lastCol) {
          sameCountCol++;
        } else {
          if (sameCountCol >= 5)
            points += PenaltyScores.N1 + (sameCountCol - 5);
          lastCol = module2;
          sameCountCol = 1;
        }
        module2 = data.get(col, row);
        if (module2 === lastRow) {
          sameCountRow++;
        } else {
          if (sameCountRow >= 5)
            points += PenaltyScores.N1 + (sameCountRow - 5);
          lastRow = module2;
          sameCountRow = 1;
        }
      }
      if (sameCountCol >= 5)
        points += PenaltyScores.N1 + (sameCountCol - 5);
      if (sameCountRow >= 5)
        points += PenaltyScores.N1 + (sameCountRow - 5);
    }
    return points;
  };
  exports.getPenaltyN2 = function getPenaltyN2(data) {
    const size = data.size;
    let points = 0;
    for (let row = 0;row < size - 1; row++) {
      for (let col = 0;col < size - 1; col++) {
        const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
        if (last === 4 || last === 0)
          points++;
      }
    }
    return points * PenaltyScores.N2;
  };
  exports.getPenaltyN3 = function getPenaltyN3(data) {
    const size = data.size;
    let points = 0;
    let bitsCol = 0;
    let bitsRow = 0;
    for (let row = 0;row < size; row++) {
      bitsCol = bitsRow = 0;
      for (let col = 0;col < size; col++) {
        bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
          points++;
        bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
          points++;
      }
    }
    return points * PenaltyScores.N3;
  };
  exports.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0;
    const modulesCount = data.data.length;
    for (let i = 0;i < modulesCount; i++)
      darkCount += data.data[i];
    const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
    return k * PenaltyScores.N4;
  };
  function getMaskAt(maskPattern, i, j) {
    switch (maskPattern) {
      case exports.Patterns.PATTERN000:
        return (i + j) % 2 === 0;
      case exports.Patterns.PATTERN001:
        return i % 2 === 0;
      case exports.Patterns.PATTERN010:
        return j % 3 === 0;
      case exports.Patterns.PATTERN011:
        return (i + j) % 3 === 0;
      case exports.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
      case exports.Patterns.PATTERN101:
        return i * j % 2 + i * j % 3 === 0;
      case exports.Patterns.PATTERN110:
        return (i * j % 2 + i * j % 3) % 2 === 0;
      case exports.Patterns.PATTERN111:
        return (i * j % 3 + (i + j) % 2) % 2 === 0;
      default:
        throw new Error("bad maskPattern:" + maskPattern);
    }
  }
  exports.applyMask = function applyMask(pattern2, data) {
    const size = data.size;
    for (let col = 0;col < size; col++) {
      for (let row = 0;row < size; row++) {
        if (data.isReserved(row, col))
          continue;
        data.xor(row, col, getMaskAt(pattern2, row, col));
      }
    }
  };
  exports.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length;
    let bestPattern = 0;
    let lowerPenalty = Infinity;
    for (let p = 0;p < numPatterns; p++) {
      setupFormatFunc(p);
      exports.applyMask(p, data);
      const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
      exports.applyMask(p, data);
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty;
        bestPattern = p;
      }
    }
    return bestPattern;
  };
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS((exports) => {
  var ECLevel = require_error_correction_level();
  var EC_BLOCKS_TABLE = [
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    2,
    2,
    1,
    2,
    2,
    4,
    1,
    2,
    4,
    4,
    2,
    4,
    4,
    4,
    2,
    4,
    6,
    5,
    2,
    4,
    6,
    6,
    2,
    5,
    8,
    8,
    4,
    5,
    8,
    8,
    4,
    5,
    8,
    11,
    4,
    8,
    10,
    11,
    4,
    9,
    12,
    16,
    4,
    9,
    16,
    16,
    6,
    10,
    12,
    18,
    6,
    10,
    17,
    16,
    6,
    11,
    16,
    19,
    6,
    13,
    18,
    21,
    7,
    14,
    21,
    25,
    8,
    16,
    20,
    25,
    8,
    17,
    23,
    25,
    9,
    17,
    23,
    34,
    9,
    18,
    25,
    30,
    10,
    20,
    27,
    32,
    12,
    21,
    29,
    35,
    12,
    23,
    34,
    37,
    12,
    25,
    34,
    40,
    13,
    26,
    35,
    42,
    14,
    28,
    38,
    45,
    15,
    29,
    40,
    48,
    16,
    31,
    43,
    51,
    17,
    33,
    45,
    54,
    18,
    35,
    48,
    57,
    19,
    37,
    51,
    60,
    19,
    38,
    53,
    63,
    20,
    40,
    56,
    66,
    21,
    43,
    59,
    70,
    22,
    45,
    62,
    74,
    24,
    47,
    65,
    77,
    25,
    49,
    68,
    81
  ];
  var EC_CODEWORDS_TABLE = [
    7,
    10,
    13,
    17,
    10,
    16,
    22,
    28,
    15,
    26,
    36,
    44,
    20,
    36,
    52,
    64,
    26,
    48,
    72,
    88,
    36,
    64,
    96,
    112,
    40,
    72,
    108,
    130,
    48,
    88,
    132,
    156,
    60,
    110,
    160,
    192,
    72,
    130,
    192,
    224,
    80,
    150,
    224,
    264,
    96,
    176,
    260,
    308,
    104,
    198,
    288,
    352,
    120,
    216,
    320,
    384,
    132,
    240,
    360,
    432,
    144,
    280,
    408,
    480,
    168,
    308,
    448,
    532,
    180,
    338,
    504,
    588,
    196,
    364,
    546,
    650,
    224,
    416,
    600,
    700,
    224,
    442,
    644,
    750,
    252,
    476,
    690,
    816,
    270,
    504,
    750,
    900,
    300,
    560,
    810,
    960,
    312,
    588,
    870,
    1050,
    336,
    644,
    952,
    1110,
    360,
    700,
    1020,
    1200,
    390,
    728,
    1050,
    1260,
    420,
    784,
    1140,
    1350,
    450,
    812,
    1200,
    1440,
    480,
    868,
    1290,
    1530,
    510,
    924,
    1350,
    1620,
    540,
    980,
    1440,
    1710,
    570,
    1036,
    1530,
    1800,
    570,
    1064,
    1590,
    1890,
    600,
    1120,
    1680,
    1980,
    630,
    1204,
    1770,
    2100,
    660,
    1260,
    1860,
    2220,
    720,
    1316,
    1950,
    2310,
    750,
    1372,
    2040,
    2430
  ];
  exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ECLevel.L:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
      case ECLevel.M:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
      case ECLevel.H:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
      default:
        return;
    }
  };
  exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ECLevel.L:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
      case ECLevel.M:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
      case ECLevel.Q:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
      case ECLevel.H:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
      default:
        return;
    }
  };
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS((exports) => {
  var EXP_TABLE = new Uint8Array(512);
  var LOG_TABLE = new Uint8Array(256);
  (function initTables() {
    let x = 1;
    for (let i = 0;i < 255; i++) {
      EXP_TABLE[i] = x;
      LOG_TABLE[x] = i;
      x <<= 1;
      if (x & 256) {
        x ^= 285;
      }
    }
    for (let i = 255;i < 512; i++) {
      EXP_TABLE[i] = EXP_TABLE[i - 255];
    }
  })();
  exports.log = function log(n) {
    if (n < 1)
      throw new Error("log(" + n + ")");
    return LOG_TABLE[n];
  };
  exports.exp = function exp(n) {
    return EXP_TABLE[n];
  };
  exports.mul = function mul(x, y) {
    if (x === 0 || y === 0)
      return 0;
    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
  };
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS((exports) => {
  var GF = require_galois_field();
  exports.mul = function mul(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1);
    for (let i = 0;i < p1.length; i++) {
      for (let j = 0;j < p2.length; j++) {
        coeff[i + j] ^= GF.mul(p1[i], p2[j]);
      }
    }
    return coeff;
  };
  exports.mod = function mod(divident, divisor) {
    let result = new Uint8Array(divident);
    while (result.length - divisor.length >= 0) {
      const coeff = result[0];
      for (let i = 0;i < divisor.length; i++) {
        result[i] ^= GF.mul(divisor[i], coeff);
      }
      let offset = 0;
      while (offset < result.length && result[offset] === 0)
        offset++;
      result = result.slice(offset);
    }
    return result;
  };
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1]);
    for (let i = 0;i < degree; i++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
    }
    return poly;
  };
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS((exports, module) => {
  var Polynomial = require_polynomial();
  function ReedSolomonEncoder(degree) {
    this.genPoly = undefined;
    this.degree = degree;
    if (this.degree)
      this.initialize(this.degree);
  }
  ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  ReedSolomonEncoder.prototype.encode = function encode(data) {
    if (!this.genPoly) {
      throw new Error("Encoder not initialized");
    }
    const paddedData = new Uint8Array(data.length + this.degree);
    paddedData.set(data);
    const remainder = Polynomial.mod(paddedData, this.genPoly);
    const start = this.degree - remainder.length;
    if (start > 0) {
      const buff = new Uint8Array(this.degree);
      buff.set(remainder, start);
      return buff;
    }
    return remainder;
  };
  module.exports = ReedSolomonEncoder;
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS((exports) => {
  exports.isValid = function isValid(version) {
    return !isNaN(version) && version >= 1 && version <= 40;
  };
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS((exports) => {
  var numeric = "[0-9]+";
  var alphanumeric = "[A-Z $%*+\\-./:]+";
  var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|" + "[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|" + "[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|" + "[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
  kanji = kanji.replace(/u/g, "\\u");
  var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + `)(?:.|[\r
]))+`;
  exports.KANJI = new RegExp(kanji, "g");
  exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
  exports.BYTE = new RegExp(byte, "g");
  exports.NUMERIC = new RegExp(numeric, "g");
  exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
  var TEST_KANJI = new RegExp("^" + kanji + "$");
  var TEST_NUMERIC = new RegExp("^" + numeric + "$");
  var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
  exports.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };
  exports.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };
  exports.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS((exports) => {
  var VersionCheck = require_version_check();
  var Regex = require_regex();
  exports.NUMERIC = {
    id: "Numeric",
    bit: 1 << 0,
    ccBits: [10, 12, 14]
  };
  exports.ALPHANUMERIC = {
    id: "Alphanumeric",
    bit: 1 << 1,
    ccBits: [9, 11, 13]
  };
  exports.BYTE = {
    id: "Byte",
    bit: 1 << 2,
    ccBits: [8, 16, 16]
  };
  exports.KANJI = {
    id: "Kanji",
    bit: 1 << 3,
    ccBits: [8, 10, 12]
  };
  exports.MIXED = {
    bit: -1
  };
  exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
    if (!mode.ccBits)
      throw new Error("Invalid mode: " + mode);
    if (!VersionCheck.isValid(version)) {
      throw new Error("Invalid version: " + version);
    }
    if (version >= 1 && version < 10)
      return mode.ccBits[0];
    else if (version < 27)
      return mode.ccBits[1];
    return mode.ccBits[2];
  };
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr))
      return exports.NUMERIC;
    else if (Regex.testAlphanumeric(dataStr))
      return exports.ALPHANUMERIC;
    else if (Regex.testKanji(dataStr))
      return exports.KANJI;
    else
      return exports.BYTE;
  };
  exports.toString = function toString(mode) {
    if (mode && mode.id)
      return mode.id;
    throw new Error("Invalid mode");
  };
  exports.isValid = function isValid(mode) {
    return mode && mode.bit && mode.ccBits;
  };
  function fromString(string3) {
    if (typeof string3 !== "string") {
      throw new Error("Param is not a string");
    }
    const lcStr = string3.toLowerCase();
    switch (lcStr) {
      case "numeric":
        return exports.NUMERIC;
      case "alphanumeric":
        return exports.ALPHANUMERIC;
      case "kanji":
        return exports.KANJI;
      case "byte":
        return exports.BYTE;
      default:
        throw new Error("Unknown mode: " + string3);
    }
  }
  exports.from = function from(value2, defaultValue) {
    if (exports.isValid(value2)) {
      return value2;
    }
    try {
      return fromString(value2);
    } catch (e) {
      return defaultValue;
    }
  };
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS((exports) => {
  var Utils = require_utils4();
  var ECCode = require_error_correction_code();
  var ECLevel = require_error_correction_level();
  var Mode = require_mode();
  var VersionCheck = require_version_check();
  var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
  var G18_BCH = Utils.getBCHDigit(G18);
  function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
    for (let currentVersion = 1;currentVersion <= 40; currentVersion++) {
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
        return currentVersion;
      }
    }
    return;
  }
  function getReservedBitsCount(mode, version) {
    return Mode.getCharCountIndicator(mode, version) + 4;
  }
  function getTotalBitsFromDataArray(segments, version) {
    let totalBits = 0;
    segments.forEach(function(data) {
      const reservedBits = getReservedBitsCount(data.mode, version);
      totalBits += reservedBits + data.getBitsLength();
    });
    return totalBits;
  }
  function getBestVersionForMixedData(segments, errorCorrectionLevel) {
    for (let currentVersion = 1;currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments, currentVersion);
      if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
        return currentVersion;
      }
    }
    return;
  }
  exports.from = function from(value2, defaultValue) {
    if (VersionCheck.isValid(value2)) {
      return parseInt(value2, 10);
    }
    return defaultValue;
  };
  exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
    if (!VersionCheck.isValid(version)) {
      throw new Error("Invalid QR Code version");
    }
    if (typeof mode === "undefined")
      mode = Mode.BYTE;
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (mode === Mode.MIXED)
      return dataTotalCodewordsBits;
    const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
    switch (mode) {
      case Mode.NUMERIC:
        return Math.floor(usableBits / 10 * 3);
      case Mode.ALPHANUMERIC:
        return Math.floor(usableBits / 11 * 2);
      case Mode.KANJI:
        return Math.floor(usableBits / 13);
      case Mode.BYTE:
      default:
        return Math.floor(usableBits / 8);
    }
  };
  exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
    let seg;
    const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl);
      }
      if (data.length === 0) {
        return 1;
      }
      seg = data[0];
    } else {
      seg = data;
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
  };
  exports.getEncodedBits = function getEncodedBits(version) {
    if (!VersionCheck.isValid(version) || version < 7) {
      throw new Error("Invalid QR Code version");
    }
    let d = version << 12;
    while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
      d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
    }
    return version << 12 | d;
  };
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS((exports) => {
  var Utils = require_utils4();
  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  var G15_BCH = Utils.getBCHDigit(G15);
  exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
    const data = errorCorrectionLevel.bit << 3 | mask;
    let d = data << 10;
    while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
      d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
    }
    return (data << 10 | d) ^ G15_MASK;
  };
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  function NumericData(data) {
    this.mode = Mode.NUMERIC;
    this.data = data.toString();
  }
  NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
  };
  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };
  NumericData.prototype.write = function write(bitBuffer) {
    let i, group, value2;
    for (i = 0;i + 3 <= this.data.length; i += 3) {
      group = this.data.substr(i, 3);
      value2 = parseInt(group, 10);
      bitBuffer.put(value2, 10);
    }
    const remainingNum = this.data.length - i;
    if (remainingNum > 0) {
      group = this.data.substr(i);
      value2 = parseInt(group, 10);
      bitBuffer.put(value2, remainingNum * 3 + 1);
    }
  };
  module.exports = NumericData;
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  var ALPHA_NUM_CHARS = [
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    " ",
    "$",
    "%",
    "*",
    "+",
    "-",
    ".",
    "/",
    ":"
  ];
  function AlphanumericData(data) {
    this.mode = Mode.ALPHANUMERIC;
    this.data = data;
  }
  AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
  };
  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };
  AlphanumericData.prototype.write = function write(bitBuffer) {
    let i;
    for (i = 0;i + 2 <= this.data.length; i += 2) {
      let value2 = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
      value2 += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
      bitBuffer.put(value2, 11);
    }
    if (this.data.length % 2) {
      bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
    }
  };
  module.exports = AlphanumericData;
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  function ByteData(data) {
    this.mode = Mode.BYTE;
    if (typeof data === "string") {
      this.data = new TextEncoder().encode(data);
    } else {
      this.data = new Uint8Array(data);
    }
  }
  ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
  };
  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };
  ByteData.prototype.write = function(bitBuffer) {
    for (let i = 0, l = this.data.length;i < l; i++) {
      bitBuffer.put(this.data[i], 8);
    }
  };
  module.exports = ByteData;
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS((exports, module) => {
  var Mode = require_mode();
  var Utils = require_utils4();
  function KanjiData(data) {
    this.mode = Mode.KANJI;
    this.data = data;
  }
  KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
  };
  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };
  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };
  KanjiData.prototype.write = function(bitBuffer) {
    let i;
    for (i = 0;i < this.data.length; i++) {
      let value2 = Utils.toSJIS(this.data[i]);
      if (value2 >= 33088 && value2 <= 40956) {
        value2 -= 33088;
      } else if (value2 >= 57408 && value2 <= 60351) {
        value2 -= 49472;
      } else {
        throw new Error("Invalid SJIS character: " + this.data[i] + `
` + "Make sure your charset is UTF-8");
      }
      value2 = (value2 >>> 8 & 255) * 192 + (value2 & 255);
      bitBuffer.put(value2, 13);
    }
  };
  module.exports = KanjiData;
});

// node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS((exports, module) => {
  var dijkstra = {
    single_source_shortest_paths: function(graph, s, d) {
      var predecessors = {};
      var costs = {};
      costs[s] = 0;
      var open = dijkstra.PriorityQueue.make();
      open.push(s, 0);
      var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
      while (!open.empty()) {
        closest = open.pop();
        u = closest.value;
        cost_of_s_to_u = closest.cost;
        adjacent_nodes = graph[u] || {};
        for (v in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v)) {
            cost_of_e = adjacent_nodes[v];
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
            cost_of_s_to_v = costs[v];
            first_visit = typeof costs[v] === "undefined";
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v] = cost_of_s_to_u_plus_cost_of_e;
              open.push(v, cost_of_s_to_u_plus_cost_of_e);
              predecessors[v] = u;
            }
          }
        }
      }
      if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
        var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
        throw new Error(msg);
      }
      return predecessors;
    },
    extract_shortest_path_from_predecessor_list: function(predecessors, d) {
      var nodes = [];
      var u = d;
      var predecessor;
      while (u) {
        nodes.push(u);
        predecessor = predecessors[u];
        u = predecessors[u];
      }
      nodes.reverse();
      return nodes;
    },
    find_path: function(graph, s, d) {
      var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
      return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
    },
    PriorityQueue: {
      make: function(opts) {
        var T = dijkstra.PriorityQueue, t2 = {}, key;
        opts = opts || {};
        for (key in T) {
          if (T.hasOwnProperty(key)) {
            t2[key] = T[key];
          }
        }
        t2.queue = [];
        t2.sorter = opts.sorter || T.default_sorter;
        return t2;
      },
      default_sorter: function(a, b) {
        return a.cost - b.cost;
      },
      push: function(value2, cost) {
        var item = { value: value2, cost };
        this.queue.push(item);
        this.queue.sort(this.sorter);
      },
      pop: function() {
        return this.queue.shift();
      },
      empty: function() {
        return this.queue.length === 0;
      }
    }
  };
  if (typeof module !== "undefined") {
    module.exports = dijkstra;
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS((exports) => {
  var Mode = require_mode();
  var NumericData = require_numeric_data();
  var AlphanumericData = require_alphanumeric_data();
  var ByteData = require_byte_data();
  var KanjiData = require_kanji_data();
  var Regex = require_regex();
  var Utils = require_utils4();
  var dijkstra = require_dijkstra();
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length;
  }
  function getSegments(regex, mode, str) {
    const segments = [];
    let result;
    while ((result = regex.exec(str)) !== null) {
      segments.push({
        data: result[0],
        index: result.index,
        mode,
        length: result[0].length
      });
    }
    return segments;
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
    const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
    let byteSegs;
    let kanjiSegs;
    if (Utils.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
      kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
      kanjiSegs = [];
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
    return segs.sort(function(s1, s2) {
      return s1.index - s2.index;
    }).map(function(obj) {
      return {
        data: obj.data,
        mode: obj.mode,
        length: obj.length
      };
    });
  }
  function getSegmentBitsLength(length, mode) {
    switch (mode) {
      case Mode.NUMERIC:
        return NumericData.getBitsLength(length);
      case Mode.ALPHANUMERIC:
        return AlphanumericData.getBitsLength(length);
      case Mode.KANJI:
        return KanjiData.getBitsLength(length);
      case Mode.BYTE:
        return ByteData.getBitsLength(length);
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function(acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data;
        return acc;
      }
      acc.push(curr);
      return acc;
    }, []);
  }
  function buildNodes(segs) {
    const nodes = [];
    for (let i = 0;i < segs.length; i++) {
      const seg = segs[i];
      switch (seg.mode) {
        case Mode.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode.BYTE, length: seg.length }
          ]);
          break;
        case Mode.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode.BYTE, length: seg.length }
          ]);
          break;
        case Mode.KANJI:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
          ]);
          break;
        case Mode.BYTE:
          nodes.push([
            { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
          ]);
      }
    }
    return nodes;
  }
  function buildGraph(nodes, version) {
    const table = {};
    const graph = { start: {} };
    let prevNodeIds = ["start"];
    for (let i = 0;i < nodes.length; i++) {
      const nodeGroup = nodes[i];
      const currentNodeIds = [];
      for (let j = 0;j < nodeGroup.length; j++) {
        const node = nodeGroup[j];
        const key = "" + i + j;
        currentNodeIds.push(key);
        table[key] = { node, lastCount: 0 };
        graph[key] = {};
        for (let n = 0;n < prevNodeIds.length; n++) {
          const prevNodeId = prevNodeIds[n];
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
            table[prevNodeId].lastCount += node.length;
          } else {
            if (table[prevNodeId])
              table[prevNodeId].lastCount = node.length;
            graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
          }
        }
      }
      prevNodeIds = currentNodeIds;
    }
    for (let n = 0;n < prevNodeIds.length; n++) {
      graph[prevNodeIds[n]].end = 0;
    }
    return { map: graph, table };
  }
  function buildSingleSegment(data, modesHint) {
    let mode;
    const bestMode = Mode.getBestModeForData(data);
    mode = Mode.from(modesHint, bestMode);
    if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
      throw new Error('"' + data + '"' + " cannot be encoded with mode " + Mode.toString(mode) + `.
 Suggested mode is: ` + Mode.toString(bestMode));
    }
    if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
      mode = Mode.BYTE;
    }
    switch (mode) {
      case Mode.NUMERIC:
        return new NumericData(data);
      case Mode.ALPHANUMERIC:
        return new AlphanumericData(data);
      case Mode.KANJI:
        return new KanjiData(data);
      case Mode.BYTE:
        return new ByteData(data);
    }
  }
  exports.fromArray = function fromArray(array3) {
    return array3.reduce(function(acc, seg) {
      if (typeof seg === "string") {
        acc.push(buildSingleSegment(seg, null));
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode));
      }
      return acc;
    }, []);
  };
  exports.fromString = function fromString(data, version) {
    const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
    const nodes = buildNodes(segs);
    const graph = buildGraph(nodes, version);
    const path = dijkstra.find_path(graph.map, "start", "end");
    const optimizedSegs = [];
    for (let i = 1;i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node);
    }
    return exports.fromArray(mergeSegments(optimizedSegs));
  };
  exports.rawSplit = function rawSplit(data) {
    return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
  };
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS((exports) => {
  var Utils = require_utils4();
  var ECLevel = require_error_correction_level();
  var BitBuffer = require_bit_buffer();
  var BitMatrix = require_bit_matrix();
  var AlignmentPattern = require_alignment_pattern();
  var FinderPattern = require_finder_pattern();
  var MaskPattern = require_mask_pattern();
  var ECCode = require_error_correction_code();
  var ReedSolomonEncoder = require_reed_solomon_encoder();
  var Version = require_version();
  var FormatInfo = require_format_info();
  var Mode = require_mode();
  var Segments = require_segments();
  function setupFinderPattern(matrix, version) {
    const size = matrix.size;
    const pos = FinderPattern.getPositions(version);
    for (let i = 0;i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -1;r <= 7; r++) {
        if (row + r <= -1 || size <= row + r)
          continue;
        for (let c = -1;c <= 7; c++) {
          if (col + c <= -1 || size <= col + c)
            continue;
          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupTimingPattern(matrix) {
    const size = matrix.size;
    for (let r = 8;r < size - 8; r++) {
      const value2 = r % 2 === 0;
      matrix.set(r, 6, value2, true);
      matrix.set(6, r, value2, true);
    }
  }
  function setupAlignmentPattern(matrix, version) {
    const pos = AlignmentPattern.getPositions(version);
    for (let i = 0;i < pos.length; i++) {
      const row = pos[i][0];
      const col = pos[i][1];
      for (let r = -2;r <= 2; r++) {
        for (let c = -2;c <= 2; c++) {
          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  function setupVersionInfo(matrix, version) {
    const size = matrix.size;
    const bits = Version.getEncodedBits(version);
    let row, col, mod;
    for (let i = 0;i < 18; i++) {
      row = Math.floor(i / 3);
      col = i % 3 + size - 8 - 3;
      mod = (bits >> i & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
    const size = matrix.size;
    const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
    let i, mod;
    for (i = 0;i < 15; i++) {
      mod = (bits >> i & 1) === 1;
      if (i < 6) {
        matrix.set(i, 8, mod, true);
      } else if (i < 8) {
        matrix.set(i + 1, 8, mod, true);
      } else {
        matrix.set(size - 15 + i, 8, mod, true);
      }
      if (i < 8) {
        matrix.set(8, size - i - 1, mod, true);
      } else if (i < 9) {
        matrix.set(8, 15 - i - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i - 1, mod, true);
      }
    }
    matrix.set(size - 8, 8, 1, true);
  }
  function setupData(matrix, data) {
    const size = matrix.size;
    let inc = -1;
    let row = size - 1;
    let bitIndex = 7;
    let byteIndex = 0;
    for (let col = size - 1;col > 0; col -= 2) {
      if (col === 6)
        col--;
      while (true) {
        for (let c = 0;c < 2; c++) {
          if (!matrix.isReserved(row, col - c)) {
            let dark = false;
            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) === 1;
            }
            matrix.set(row, col - c, dark);
            bitIndex--;
            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }
        row += inc;
        if (row < 0 || size <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  function createData(version, errorCorrectionLevel, segments) {
    const buffer = new BitBuffer;
    segments.forEach(function(data) {
      buffer.put(data.mode.bit, 4);
      buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
      data.write(buffer);
    });
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer.put(0, 4);
    }
    while (buffer.getLengthInBits() % 8 !== 0) {
      buffer.putBit(0);
    }
    const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
    for (let i = 0;i < remainingByte; i++) {
      buffer.put(i % 2 ? 17 : 236, 8);
    }
    return createCodewords(buffer, version, errorCorrectionLevel);
  }
  function createCodewords(bitBuffer, version, errorCorrectionLevel) {
    const totalCodewords = Utils.getSymbolTotalCodewords(version);
    const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    const dataTotalCodewords = totalCodewords - ecTotalCodewords;
    const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
    const blocksInGroup2 = totalCodewords % ecTotalBlocks;
    const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
    const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
    const rs = new ReedSolomonEncoder(ecCount);
    let offset = 0;
    const dcData = new Array(ecTotalBlocks);
    const ecData = new Array(ecTotalBlocks);
    let maxDataSize = 0;
    const buffer = new Uint8Array(bitBuffer.buffer);
    for (let b = 0;b < ecTotalBlocks; b++) {
      const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
      dcData[b] = buffer.slice(offset, offset + dataSize);
      ecData[b] = rs.encode(dcData[b]);
      offset += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    }
    const data = new Uint8Array(totalCodewords);
    let index = 0;
    let i, r;
    for (i = 0;i < maxDataSize; i++) {
      for (r = 0;r < ecTotalBlocks; r++) {
        if (i < dcData[r].length) {
          data[index++] = dcData[r][i];
        }
      }
    }
    for (i = 0;i < ecCount; i++) {
      for (r = 0;r < ecTotalBlocks; r++) {
        data[index++] = ecData[r][i];
      }
    }
    return data;
  }
  function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
    let segments;
    if (Array.isArray(data)) {
      segments = Segments.fromArray(data);
    } else if (typeof data === "string") {
      let estimatedVersion = version;
      if (!estimatedVersion) {
        const rawSegments = Segments.rawSplit(data);
        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
      }
      segments = Segments.fromString(data, estimatedVersion || 40);
    } else {
      throw new Error("Invalid data");
    }
    const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
    if (!bestVersion) {
      throw new Error("The amount of data is too big to be stored in a QR Code");
    }
    if (!version) {
      version = bestVersion;
    } else if (version < bestVersion) {
      throw new Error(`
` + `The chosen QR Code version cannot contain this amount of data.
` + "Minimum version required to store current data is: " + bestVersion + `.
`);
    }
    const dataBits = createData(version, errorCorrectionLevel, segments);
    const moduleCount = Utils.getSymbolSize(version);
    const modules = new BitMatrix(moduleCount);
    setupFinderPattern(modules, version);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version);
    setupFormatInfo(modules, errorCorrectionLevel, 0);
    if (version >= 7) {
      setupVersionInfo(modules, version);
    }
    setupData(modules, dataBits);
    if (isNaN(maskPattern)) {
      maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
    }
    MaskPattern.applyMask(maskPattern, modules);
    setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
    return {
      modules,
      version,
      errorCorrectionLevel,
      maskPattern,
      segments
    };
  }
  exports.create = function create(data, options) {
    if (typeof data === "undefined" || data === "") {
      throw new Error("No input text");
    }
    let errorCorrectionLevel = ECLevel.M;
    let version;
    let mask;
    if (typeof options !== "undefined") {
      errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);
      if (options.toSJISFunc) {
        Utils.setToSJISFunction(options.toSJISFunc);
      }
    }
    return createSymbol(data, version, errorCorrectionLevel, mask);
  };
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream = __require("stream");
  var ChunkStream = module.exports = function() {
    Stream.call(this);
    this._buffers = [];
    this._buffered = 0;
    this._reads = [];
    this._paused = false;
    this._encoding = "utf8";
    this.writable = true;
  };
  util.inherits(ChunkStream, Stream);
  ChunkStream.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
    process.nextTick(function() {
      this._process();
      if (this._paused && this._reads && this._reads.length > 0) {
        this._paused = false;
        this.emit("drain");
      }
    }.bind(this));
  };
  ChunkStream.prototype.write = function(data, encoding) {
    if (!this.writable) {
      this.emit("error", new Error("Stream not writable"));
      return false;
    }
    let dataBuffer;
    if (Buffer.isBuffer(data)) {
      dataBuffer = data;
    } else {
      dataBuffer = Buffer.from(data, encoding || this._encoding);
    }
    this._buffers.push(dataBuffer);
    this._buffered += dataBuffer.length;
    this._process();
    if (this._reads && this._reads.length === 0) {
      this._paused = true;
    }
    return this.writable && !this._paused;
  };
  ChunkStream.prototype.end = function(data, encoding) {
    if (data) {
      this.write(data, encoding);
    }
    this.writable = false;
    if (!this._buffers) {
      return;
    }
    if (this._buffers.length === 0) {
      this._end();
    } else {
      this._buffers.push(null);
      this._process();
    }
  };
  ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
  ChunkStream.prototype._end = function() {
    if (this._reads.length > 0) {
      this.emit("error", new Error("Unexpected end of input"));
    }
    this.destroy();
  };
  ChunkStream.prototype.destroy = function() {
    if (!this._buffers) {
      return;
    }
    this.writable = false;
    this._reads = null;
    this._buffers = null;
    this.emit("close");
  };
  ChunkStream.prototype._processReadAllowingLess = function(read) {
    this._reads.shift();
    let smallerBuf = this._buffers[0];
    if (smallerBuf.length > read.length) {
      this._buffered -= read.length;
      this._buffers[0] = smallerBuf.slice(read.length);
      read.func.call(this, smallerBuf.slice(0, read.length));
    } else {
      this._buffered -= smallerBuf.length;
      this._buffers.shift();
      read.func.call(this, smallerBuf);
    }
  };
  ChunkStream.prototype._processRead = function(read) {
    this._reads.shift();
    let pos = 0;
    let count = 0;
    let data = Buffer.alloc(read.length);
    while (pos < read.length) {
      let buf = this._buffers[count++];
      let len = Math.min(buf.length, read.length - pos);
      buf.copy(data, pos, 0, len);
      pos += len;
      if (len !== buf.length) {
        this._buffers[--count] = buf.slice(len);
      }
    }
    if (count > 0) {
      this._buffers.splice(0, count);
    }
    this._buffered -= read.length;
    read.func.call(this, data);
  };
  ChunkStream.prototype._process = function() {
    try {
      while (this._buffered > 0 && this._reads && this._reads.length > 0) {
        let read = this._reads[0];
        if (read.allowLess) {
          this._processReadAllowingLess(read);
        } else if (this._buffered >= read.length) {
          this._processRead(read);
        } else {
          break;
        }
      }
      if (this._buffers && !this.writable) {
        this._end();
      }
    } catch (ex) {
      this.emit("error", ex);
    }
  };
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS((exports) => {
  var imagePasses = [
    {
      x: [0],
      y: [0]
    },
    {
      x: [4],
      y: [0]
    },
    {
      x: [0, 4],
      y: [4]
    },
    {
      x: [2, 6],
      y: [0, 4]
    },
    {
      x: [0, 2, 4, 6],
      y: [2, 6]
    },
    {
      x: [1, 3, 5, 7],
      y: [0, 2, 4, 6]
    },
    {
      x: [0, 1, 2, 3, 4, 5, 6, 7],
      y: [1, 3, 5, 7]
    }
  ];
  exports.getImagePasses = function(width, height) {
    let images = [];
    let xLeftOver = width % 8;
    let yLeftOver = height % 8;
    let xRepeats = (width - xLeftOver) / 8;
    let yRepeats = (height - yLeftOver) / 8;
    for (let i = 0;i < imagePasses.length; i++) {
      let pass = imagePasses[i];
      let passWidth = xRepeats * pass.x.length;
      let passHeight = yRepeats * pass.y.length;
      for (let j = 0;j < pass.x.length; j++) {
        if (pass.x[j] < xLeftOver) {
          passWidth++;
        } else {
          break;
        }
      }
      for (let j = 0;j < pass.y.length; j++) {
        if (pass.y[j] < yLeftOver) {
          passHeight++;
        } else {
          break;
        }
      }
      if (passWidth > 0 && passHeight > 0) {
        images.push({ width: passWidth, height: passHeight, index: i });
      }
    }
    return images;
  };
  exports.getInterlaceIterator = function(width) {
    return function(x, y, pass) {
      let outerXLeftOver = x % imagePasses[pass].x.length;
      let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
      let outerYLeftOver = y % imagePasses[pass].y.length;
      let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
      return outerX * 4 + outerY * width * 4;
    };
  };
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS((exports, module) => {
  module.exports = function paethPredictor(left, above, upLeft) {
    let paeth = left + above - upLeft;
    let pLeft = Math.abs(paeth - left);
    let pAbove = Math.abs(paeth - above);
    let pUpLeft = Math.abs(paeth - upLeft);
    if (pLeft <= pAbove && pLeft <= pUpLeft) {
      return left;
    }
    if (pAbove <= pUpLeft) {
      return above;
    }
    return upLeft;
  };
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS((exports, module) => {
  var interlaceUtils = require_interlace();
  var paethPredictor = require_paeth_predictor();
  function getByteWidth(width, bpp, depth) {
    let byteWidth = width * bpp;
    if (depth !== 8) {
      byteWidth = Math.ceil(byteWidth / (8 / depth));
    }
    return byteWidth;
  }
  var Filter = module.exports = function(bitmapInfo, dependencies) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let interlace = bitmapInfo.interlace;
    let bpp = bitmapInfo.bpp;
    let depth = bitmapInfo.depth;
    this.read = dependencies.read;
    this.write = dependencies.write;
    this.complete = dependencies.complete;
    this._imageIndex = 0;
    this._images = [];
    if (interlace) {
      let passes = interlaceUtils.getImagePasses(width, height);
      for (let i = 0;i < passes.length; i++) {
        this._images.push({
          byteWidth: getByteWidth(passes[i].width, bpp, depth),
          height: passes[i].height,
          lineIndex: 0
        });
      }
    } else {
      this._images.push({
        byteWidth: getByteWidth(width, bpp, depth),
        height,
        lineIndex: 0
      });
    }
    if (depth === 8) {
      this._xComparison = bpp;
    } else if (depth === 16) {
      this._xComparison = bpp * 2;
    } else {
      this._xComparison = 1;
    }
  };
  Filter.prototype.start = function() {
    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
  };
  Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      unfilteredLine[x] = rawByte + f1Left;
    }
  };
  Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f2Up = lastLine ? lastLine[x] : 0;
      unfilteredLine[x] = rawByte + f2Up;
    }
  };
  Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f3Up = lastLine ? lastLine[x] : 0;
      let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f3Add = Math.floor((f3Left + f3Up) / 2);
      unfilteredLine[x] = rawByte + f3Add;
    }
  };
  Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
    let xComparison = this._xComparison;
    let xBiggerThan = xComparison - 1;
    let lastLine = this._lastLine;
    for (let x = 0;x < byteWidth; x++) {
      let rawByte = rawData[1 + x];
      let f4Up = lastLine ? lastLine[x] : 0;
      let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
      let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
      let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
      unfilteredLine[x] = rawByte + f4Add;
    }
  };
  Filter.prototype._reverseFilterLine = function(rawData) {
    let filter = rawData[0];
    let unfilteredLine;
    let currentImage = this._images[this._imageIndex];
    let byteWidth = currentImage.byteWidth;
    if (filter === 0) {
      unfilteredLine = rawData.slice(1, byteWidth + 1);
    } else {
      unfilteredLine = Buffer.alloc(byteWidth);
      switch (filter) {
        case 1:
          this._unFilterType1(rawData, unfilteredLine, byteWidth);
          break;
        case 2:
          this._unFilterType2(rawData, unfilteredLine, byteWidth);
          break;
        case 3:
          this._unFilterType3(rawData, unfilteredLine, byteWidth);
          break;
        case 4:
          this._unFilterType4(rawData, unfilteredLine, byteWidth);
          break;
        default:
          throw new Error("Unrecognised filter type - " + filter);
      }
    }
    this.write(unfilteredLine);
    currentImage.lineIndex++;
    if (currentImage.lineIndex >= currentImage.height) {
      this._lastLine = null;
      this._imageIndex++;
      currentImage = this._images[this._imageIndex];
    } else {
      this._lastLine = unfilteredLine;
    }
    if (currentImage) {
      this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
    } else {
      this._lastLine = null;
      this.complete();
    }
  };
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS((exports, module) => {
  var util = __require("util");
  var ChunkStream = require_chunkstream();
  var Filter = require_filter_parse();
  var FilterAsync = module.exports = function(bitmapInfo) {
    ChunkStream.call(this);
    let buffers = [];
    let that = this;
    this._filter = new Filter(bitmapInfo, {
      read: this.read.bind(this),
      write: function(buffer) {
        buffers.push(buffer);
      },
      complete: function() {
        that.emit("complete", Buffer.concat(buffers));
      }
    });
    this._filter.start();
  };
  util.inherits(FilterAsync, ChunkStream);
});

// node_modules/pngjs/lib/constants.js
var require_constants2 = __commonJS((exports, module) => {
  module.exports = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    TYPE_gAMA: 1732332865,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: {
      0: 1,
      2: 3,
      3: 1,
      4: 2,
      6: 4
    },
    GAMMA_DIVISION: 1e5
  };
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS((exports, module) => {
  var crcTable = [];
  (function() {
    for (let i = 0;i < 256; i++) {
      let currentCrc = i;
      for (let j = 0;j < 8; j++) {
        if (currentCrc & 1) {
          currentCrc = 3988292384 ^ currentCrc >>> 1;
        } else {
          currentCrc = currentCrc >>> 1;
        }
      }
      crcTable[i] = currentCrc;
    }
  })();
  var CrcCalculator = module.exports = function() {
    this._crc = -1;
  };
  CrcCalculator.prototype.write = function(data) {
    for (let i = 0;i < data.length; i++) {
      this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
    }
    return true;
  };
  CrcCalculator.prototype.crc32 = function() {
    return this._crc ^ -1;
  };
  CrcCalculator.crc32 = function(buf) {
    let crc = -1;
    for (let i = 0;i < buf.length; i++) {
      crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  };
});

// node_modules/pngjs/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var constants = require_constants2();
  var CrcCalculator = require_crc();
  var Parser = module.exports = function(options, dependencies) {
    this._options = options;
    options.checkCRC = options.checkCRC !== false;
    this._hasIHDR = false;
    this._hasIEND = false;
    this._emittedHeadersFinished = false;
    this._palette = [];
    this._colorType = 0;
    this._chunks = {};
    this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
    this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
    this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
    this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
    this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
    this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
    this.read = dependencies.read;
    this.error = dependencies.error;
    this.metadata = dependencies.metadata;
    this.gamma = dependencies.gamma;
    this.transColor = dependencies.transColor;
    this.palette = dependencies.palette;
    this.parsed = dependencies.parsed;
    this.inflateData = dependencies.inflateData;
    this.finished = dependencies.finished;
    this.simpleTransparency = dependencies.simpleTransparency;
    this.headersFinished = dependencies.headersFinished || function() {};
  };
  Parser.prototype.start = function() {
    this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
  };
  Parser.prototype._parseSignature = function(data) {
    let signature = constants.PNG_SIGNATURE;
    for (let i = 0;i < signature.length; i++) {
      if (data[i] !== signature[i]) {
        this.error(new Error("Invalid file signature"));
        return;
      }
    }
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._parseChunkBegin = function(data) {
    let length = data.readUInt32BE(0);
    let type3 = data.readUInt32BE(4);
    let name = "";
    for (let i = 4;i < 8; i++) {
      name += String.fromCharCode(data[i]);
    }
    let ancillary = Boolean(data[4] & 32);
    if (!this._hasIHDR && type3 !== constants.TYPE_IHDR) {
      this.error(new Error("Expected IHDR on beggining"));
      return;
    }
    this._crc = new CrcCalculator;
    this._crc.write(Buffer.from(name));
    if (this._chunks[type3]) {
      return this._chunks[type3](length);
    }
    if (!ancillary) {
      this.error(new Error("Unsupported critical chunk type " + name));
      return;
    }
    this.read(length + 4, this._skipChunk.bind(this));
  };
  Parser.prototype._skipChunk = function() {
    this.read(8, this._parseChunkBegin.bind(this));
  };
  Parser.prototype._handleChunkEnd = function() {
    this.read(4, this._parseChunkEnd.bind(this));
  };
  Parser.prototype._parseChunkEnd = function(data) {
    let fileCrc = data.readInt32BE(0);
    let calcCrc = this._crc.crc32();
    if (this._options.checkCRC && calcCrc !== fileCrc) {
      this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
      return;
    }
    if (!this._hasIEND) {
      this.read(8, this._parseChunkBegin.bind(this));
    }
  };
  Parser.prototype._handleIHDR = function(length) {
    this.read(length, this._parseIHDR.bind(this));
  };
  Parser.prototype._parseIHDR = function(data) {
    this._crc.write(data);
    let width = data.readUInt32BE(0);
    let height = data.readUInt32BE(4);
    let depth = data[8];
    let colorType = data[9];
    let compr = data[10];
    let filter = data[11];
    let interlace = data[12];
    if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
      this.error(new Error("Unsupported bit depth " + depth));
      return;
    }
    if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
      this.error(new Error("Unsupported color type"));
      return;
    }
    if (compr !== 0) {
      this.error(new Error("Unsupported compression method"));
      return;
    }
    if (filter !== 0) {
      this.error(new Error("Unsupported filter method"));
      return;
    }
    if (interlace !== 0 && interlace !== 1) {
      this.error(new Error("Unsupported interlace method"));
      return;
    }
    this._colorType = colorType;
    let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
    this._hasIHDR = true;
    this.metadata({
      width,
      height,
      depth,
      interlace: Boolean(interlace),
      palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
      color: Boolean(colorType & constants.COLORTYPE_COLOR),
      alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
      bpp,
      colorType
    });
    this._handleChunkEnd();
  };
  Parser.prototype._handlePLTE = function(length) {
    this.read(length, this._parsePLTE.bind(this));
  };
  Parser.prototype._parsePLTE = function(data) {
    this._crc.write(data);
    let entries = Math.floor(data.length / 3);
    for (let i = 0;i < entries; i++) {
      this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
    }
    this.palette(this._palette);
    this._handleChunkEnd();
  };
  Parser.prototype._handleTRNS = function(length) {
    this.simpleTransparency();
    this.read(length, this._parseTRNS.bind(this));
  };
  Parser.prototype._parseTRNS = function(data) {
    this._crc.write(data);
    if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
      if (this._palette.length === 0) {
        this.error(new Error("Transparency chunk must be after palette"));
        return;
      }
      if (data.length > this._palette.length) {
        this.error(new Error("More transparent colors than palette size"));
        return;
      }
      for (let i = 0;i < data.length; i++) {
        this._palette[i][3] = data[i];
      }
      this.palette(this._palette);
    }
    if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
      this.transColor([data.readUInt16BE(0)]);
    }
    if (this._colorType === constants.COLORTYPE_COLOR) {
      this.transColor([
        data.readUInt16BE(0),
        data.readUInt16BE(2),
        data.readUInt16BE(4)
      ]);
    }
    this._handleChunkEnd();
  };
  Parser.prototype._handleGAMA = function(length) {
    this.read(length, this._parseGAMA.bind(this));
  };
  Parser.prototype._parseGAMA = function(data) {
    this._crc.write(data);
    this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
    this._handleChunkEnd();
  };
  Parser.prototype._handleIDAT = function(length) {
    if (!this._emittedHeadersFinished) {
      this._emittedHeadersFinished = true;
      this.headersFinished();
    }
    this.read(-length, this._parseIDAT.bind(this, length));
  };
  Parser.prototype._parseIDAT = function(length, data) {
    this._crc.write(data);
    if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
      throw new Error("Expected palette not found");
    }
    this.inflateData(data);
    let leftOverLength = length - data.length;
    if (leftOverLength > 0) {
      this._handleIDAT(leftOverLength);
    } else {
      this._handleChunkEnd();
    }
  };
  Parser.prototype._handleIEND = function(length) {
    this.read(length, this._parseIEND.bind(this));
  };
  Parser.prototype._parseIEND = function(data) {
    this._crc.write(data);
    this._hasIEND = true;
    this._handleChunkEnd();
    if (this.finished) {
      this.finished();
    }
  };
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS((exports) => {
  var interlaceUtils = require_interlace();
  var pixelBppMapper = [
    function() {},
    function(pxData, data, pxPos, rawPos) {
      if (rawPos === data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 1 >= data.length) {
        throw new Error("Ran out of data");
      }
      let pixel = data[rawPos];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = data[rawPos + 1];
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 2 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = 255;
    },
    function(pxData, data, pxPos, rawPos) {
      if (rawPos + 3 >= data.length) {
        throw new Error("Ran out of data");
      }
      pxData[pxPos] = data[rawPos];
      pxData[pxPos + 1] = data[rawPos + 1];
      pxData[pxPos + 2] = data[rawPos + 2];
      pxData[pxPos + 3] = data[rawPos + 3];
    }
  ];
  var pixelBppCustomMapper = [
    function() {},
    function(pxData, pixelData, pxPos, maxBit) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      let pixel = pixelData[0];
      pxData[pxPos] = pixel;
      pxData[pxPos + 1] = pixel;
      pxData[pxPos + 2] = pixel;
      pxData[pxPos + 3] = pixelData[1];
    },
    function(pxData, pixelData, pxPos, maxBit) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = maxBit;
    },
    function(pxData, pixelData, pxPos) {
      pxData[pxPos] = pixelData[0];
      pxData[pxPos + 1] = pixelData[1];
      pxData[pxPos + 2] = pixelData[2];
      pxData[pxPos + 3] = pixelData[3];
    }
  ];
  function bitRetriever(data, depth) {
    let leftOver = [];
    let i = 0;
    function split() {
      if (i === data.length) {
        throw new Error("Ran out of data");
      }
      let byte = data[i];
      i++;
      let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
      switch (depth) {
        default:
          throw new Error("unrecognised depth");
        case 16:
          byte2 = data[i];
          i++;
          leftOver.push((byte << 8) + byte2);
          break;
        case 4:
          byte2 = byte & 15;
          byte1 = byte >> 4;
          leftOver.push(byte1, byte2);
          break;
        case 2:
          byte4 = byte & 3;
          byte3 = byte >> 2 & 3;
          byte2 = byte >> 4 & 3;
          byte1 = byte >> 6 & 3;
          leftOver.push(byte1, byte2, byte3, byte4);
          break;
        case 1:
          byte8 = byte & 1;
          byte7 = byte >> 1 & 1;
          byte6 = byte >> 2 & 1;
          byte5 = byte >> 3 & 1;
          byte4 = byte >> 4 & 1;
          byte3 = byte >> 5 & 1;
          byte2 = byte >> 6 & 1;
          byte1 = byte >> 7 & 1;
          leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
          break;
      }
    }
    return {
      get: function(count) {
        while (leftOver.length < count) {
          split();
        }
        let returner = leftOver.slice(0, count);
        leftOver = leftOver.slice(count);
        return returner;
      },
      resetAfterLine: function() {
        leftOver.length = 0;
      },
      end: function() {
        if (i !== data.length) {
          throw new Error("extra data found");
        }
      }
    };
  }
  function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
        rawPos += bpp;
      }
    }
    return rawPos;
  }
  function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
    let imageWidth = image.width;
    let imageHeight = image.height;
    let imagePass = image.index;
    for (let y = 0;y < imageHeight; y++) {
      for (let x = 0;x < imageWidth; x++) {
        let pixelData = bits.get(bpp);
        let pxPos = getPxPos(x, y, imagePass);
        pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
      }
      bits.resetAfterLine();
    }
  }
  exports.dataToBitMap = function(data, bitmapInfo) {
    let width = bitmapInfo.width;
    let height = bitmapInfo.height;
    let depth = bitmapInfo.depth;
    let bpp = bitmapInfo.bpp;
    let interlace = bitmapInfo.interlace;
    let bits;
    if (depth !== 8) {
      bits = bitRetriever(data, depth);
    }
    let pxData;
    if (depth <= 8) {
      pxData = Buffer.alloc(width * height * 4);
    } else {
      pxData = new Uint16Array(width * height * 4);
    }
    let maxBit = Math.pow(2, depth) - 1;
    let rawPos = 0;
    let images;
    let getPxPos;
    if (interlace) {
      images = interlaceUtils.getImagePasses(width, height);
      getPxPos = interlaceUtils.getInterlaceIterator(width, height);
    } else {
      let nonInterlacedPxPos = 0;
      getPxPos = function() {
        let returner = nonInterlacedPxPos;
        nonInterlacedPxPos += 4;
        return returner;
      };
      images = [{ width, height }];
    }
    for (let imageIndex = 0;imageIndex < images.length; imageIndex++) {
      if (depth === 8) {
        rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
      } else {
        mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
      }
    }
    if (depth === 8) {
      if (rawPos !== data.length) {
        throw new Error("extra data found");
      }
    } else {
      bits.end();
    }
    return pxData;
  };
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS((exports, module) => {
  function dePalette(indata, outdata, width, height, palette) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let color = palette[indata[pxPos]];
        if (!color) {
          throw new Error("index " + indata[pxPos] + " not in palette");
        }
        for (let i = 0;i < 4; i++) {
          outdata[pxPos + i] = color[i];
        }
        pxPos += 4;
      }
    }
  }
  function replaceTransparentColor(indata, outdata, width, height, transColor) {
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let makeTrans = false;
        if (transColor.length === 1) {
          if (transColor[0] === indata[pxPos]) {
            makeTrans = true;
          }
        } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
          makeTrans = true;
        }
        if (makeTrans) {
          for (let i = 0;i < 4; i++) {
            outdata[pxPos + i] = 0;
          }
        }
        pxPos += 4;
      }
    }
  }
  function scaleDepth(indata, outdata, width, height, depth) {
    let maxOutSample = 255;
    let maxInSample = Math.pow(2, depth) - 1;
    let pxPos = 0;
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        for (let i = 0;i < 4; i++) {
          outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
        }
        pxPos += 4;
      }
    }
  }
  module.exports = function(indata, imageData) {
    let depth = imageData.depth;
    let width = imageData.width;
    let height = imageData.height;
    let colorType = imageData.colorType;
    let transColor = imageData.transColor;
    let palette = imageData.palette;
    let outdata = indata;
    if (colorType === 3) {
      dePalette(indata, outdata, width, height, palette);
    } else {
      if (transColor) {
        replaceTransparentColor(indata, outdata, width, height, transColor);
      }
      if (depth !== 8) {
        if (depth === 16) {
          outdata = Buffer.alloc(width * height * 4);
        }
        scaleDepth(indata, outdata, width, height, depth);
      }
    }
    return outdata;
  };
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS((exports, module) => {
  var util = __require("util");
  var zlib = __require("zlib");
  var ChunkStream = require_chunkstream();
  var FilterAsync = require_filter_parse_async();
  var Parser = require_parser2();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  var ParserAsync = module.exports = function(options) {
    ChunkStream.call(this);
    this._parser = new Parser(options, {
      read: this.read.bind(this),
      error: this._handleError.bind(this),
      metadata: this._handleMetaData.bind(this),
      gamma: this.emit.bind(this, "gamma"),
      palette: this._handlePalette.bind(this),
      transColor: this._handleTransColor.bind(this),
      finished: this._finished.bind(this),
      inflateData: this._inflateData.bind(this),
      simpleTransparency: this._simpleTransparency.bind(this),
      headersFinished: this._headersFinished.bind(this)
    });
    this._options = options;
    this.writable = true;
    this._parser.start();
  };
  util.inherits(ParserAsync, ChunkStream);
  ParserAsync.prototype._handleError = function(err) {
    this.emit("error", err);
    this.writable = false;
    this.destroy();
    if (this._inflate && this._inflate.destroy) {
      this._inflate.destroy();
    }
    if (this._filter) {
      this._filter.destroy();
      this._filter.on("error", function() {});
    }
    this.errord = true;
  };
  ParserAsync.prototype._inflateData = function(data) {
    if (!this._inflate) {
      if (this._bitmapInfo.interlace) {
        this._inflate = zlib.createInflate();
        this._inflate.on("error", this.emit.bind(this, "error"));
        this._filter.on("complete", this._complete.bind(this));
        this._inflate.pipe(this._filter);
      } else {
        let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
        let imageSize = rowSize * this._bitmapInfo.height;
        let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
        this._inflate = zlib.createInflate({ chunkSize });
        let leftToInflate = imageSize;
        let emitError = this.emit.bind(this, "error");
        this._inflate.on("error", function(err) {
          if (!leftToInflate) {
            return;
          }
          emitError(err);
        });
        this._filter.on("complete", this._complete.bind(this));
        let filterWrite = this._filter.write.bind(this._filter);
        this._inflate.on("data", function(chunk) {
          if (!leftToInflate) {
            return;
          }
          if (chunk.length > leftToInflate) {
            chunk = chunk.slice(0, leftToInflate);
          }
          leftToInflate -= chunk.length;
          filterWrite(chunk);
        });
        this._inflate.on("end", this._filter.end.bind(this._filter));
      }
    }
    this._inflate.write(data);
  };
  ParserAsync.prototype._handleMetaData = function(metaData) {
    this._metaData = metaData;
    this._bitmapInfo = Object.create(metaData);
    this._filter = new FilterAsync(this._bitmapInfo);
  };
  ParserAsync.prototype._handleTransColor = function(transColor) {
    this._bitmapInfo.transColor = transColor;
  };
  ParserAsync.prototype._handlePalette = function(palette) {
    this._bitmapInfo.palette = palette;
  };
  ParserAsync.prototype._simpleTransparency = function() {
    this._metaData.alpha = true;
  };
  ParserAsync.prototype._headersFinished = function() {
    this.emit("metadata", this._metaData);
  };
  ParserAsync.prototype._finished = function() {
    if (this.errord) {
      return;
    }
    if (!this._inflate) {
      this.emit("error", "No Inflate block");
    } else {
      this._inflate.end();
    }
  };
  ParserAsync.prototype._complete = function(filteredData) {
    if (this.errord) {
      return;
    }
    let normalisedBitmapData;
    try {
      let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
      normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
      bitmapData = null;
    } catch (ex) {
      this._handleError(ex);
      return;
    }
    this.emit("parsed", normalisedBitmapData);
  };
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS((exports, module) => {
  var constants = require_constants2();
  module.exports = function(dataIn, width, height, options) {
    let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
    if (options.colorType === options.inputColorType) {
      let bigEndian = function() {
        let buffer = new ArrayBuffer(2);
        new DataView(buffer).setInt16(0, 256, true);
        return new Int16Array(buffer)[0] !== 256;
      }();
      if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
        return dataIn;
      }
    }
    let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
    let maxValue = 255;
    let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
    if (inBpp === 4 && !options.inputHasAlpha) {
      inBpp = 3;
    }
    let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
    if (options.bitDepth === 16) {
      maxValue = 65535;
      outBpp *= 2;
    }
    let outData = Buffer.alloc(width * height * outBpp);
    let inIndex = 0;
    let outIndex = 0;
    let bgColor = options.bgColor || {};
    if (bgColor.red === undefined) {
      bgColor.red = maxValue;
    }
    if (bgColor.green === undefined) {
      bgColor.green = maxValue;
    }
    if (bgColor.blue === undefined) {
      bgColor.blue = maxValue;
    }
    function getRGBA() {
      let red;
      let green;
      let blue;
      let alpha = maxValue;
      switch (options.inputColorType) {
        case constants.COLORTYPE_COLOR_ALPHA:
          alpha = data[inIndex + 3];
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants.COLORTYPE_COLOR:
          red = data[inIndex];
          green = data[inIndex + 1];
          blue = data[inIndex + 2];
          break;
        case constants.COLORTYPE_ALPHA:
          alpha = data[inIndex + 1];
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        case constants.COLORTYPE_GRAYSCALE:
          red = data[inIndex];
          green = red;
          blue = red;
          break;
        default:
          throw new Error("input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.inputHasAlpha) {
        if (!outHasAlpha) {
          alpha /= maxValue;
          red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
          green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
          blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
        }
      }
      return { red, green, blue, alpha };
    }
    for (let y = 0;y < height; y++) {
      for (let x = 0;x < width; x++) {
        let rgba = getRGBA(data, inIndex);
        switch (options.colorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
          case constants.COLORTYPE_COLOR:
            if (options.bitDepth === 8) {
              outData[outIndex] = rgba.red;
              outData[outIndex + 1] = rgba.green;
              outData[outIndex + 2] = rgba.blue;
              if (outHasAlpha) {
                outData[outIndex + 3] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(rgba.red, outIndex);
              outData.writeUInt16BE(rgba.green, outIndex + 2);
              outData.writeUInt16BE(rgba.blue, outIndex + 4);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 6);
              }
            }
            break;
          case constants.COLORTYPE_ALPHA:
          case constants.COLORTYPE_GRAYSCALE: {
            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
            if (options.bitDepth === 8) {
              outData[outIndex] = grayscale;
              if (outHasAlpha) {
                outData[outIndex + 1] = rgba.alpha;
              }
            } else {
              outData.writeUInt16BE(grayscale, outIndex);
              if (outHasAlpha) {
                outData.writeUInt16BE(rgba.alpha, outIndex + 2);
              }
            }
            break;
          }
          default:
            throw new Error("unrecognised color Type " + options.colorType);
        }
        inIndex += inBpp;
        outIndex += outBpp;
      }
    }
    return outData;
  };
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS((exports, module) => {
  var paethPredictor = require_paeth_predictor();
  function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      rawData[rawPos + x] = pxData[pxPos + x];
    }
  }
  function filterSumNone(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let i = pxPos;i < length; i++) {
      sum += Math.abs(pxData[i]);
    }
    return sum;
  }
  function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumSub(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let val = pxData[pxPos + x] - left;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
    for (let x = 0;x < byteWidth; x++) {
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - up;
      rawData[rawPos + x] = val;
    }
  }
  function filterSumUp(pxData, pxPos, byteWidth) {
    let sum = 0;
    let length = pxPos + byteWidth;
    for (let x = pxPos;x < length; x++) {
      let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
      let val = pxData[x] - up;
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let val = pxData[pxPos + x] - (left + up >> 1);
      sum += Math.abs(val);
    }
    return sum;
  }
  function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      rawData[rawPos + x] = val;
    }
  }
  function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
    let sum = 0;
    for (let x = 0;x < byteWidth; x++) {
      let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
      let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
      let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
      let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
      sum += Math.abs(val);
    }
    return sum;
  }
  var filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth
  };
  var filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth
  };
  module.exports = function(pxData, width, height, options, bpp) {
    let filterTypes;
    if (!("filterType" in options) || options.filterType === -1) {
      filterTypes = [0, 1, 2, 3, 4];
    } else if (typeof options.filterType === "number") {
      filterTypes = [options.filterType];
    } else {
      throw new Error("unrecognised filter types");
    }
    if (options.bitDepth === 16) {
      bpp *= 2;
    }
    let byteWidth = width * bpp;
    let rawPos = 0;
    let pxPos = 0;
    let rawData = Buffer.alloc((byteWidth + 1) * height);
    let sel = filterTypes[0];
    for (let y = 0;y < height; y++) {
      if (filterTypes.length > 1) {
        let min = Infinity;
        for (let i = 0;i < filterTypes.length; i++) {
          let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
          if (sum < min) {
            sel = filterTypes[i];
            min = sum;
          }
        }
      }
      rawData[rawPos] = sel;
      rawPos++;
      filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
      rawPos += byteWidth;
      pxPos += byteWidth;
    }
    return rawData;
  };
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS((exports, module) => {
  var constants = require_constants2();
  var CrcStream = require_crc();
  var bitPacker = require_bitpacker();
  var filter = require_filter_pack();
  var zlib = __require("zlib");
  var Packer = module.exports = function(options) {
    this._options = options;
    options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
    options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
    options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
    options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
    options.deflateFactory = options.deflateFactory || zlib.createDeflate;
    options.bitDepth = options.bitDepth || 8;
    options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
    options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
    if ([
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA
    ].indexOf(options.colorType) === -1) {
      throw new Error("option color type:" + options.colorType + " is not supported at present");
    }
    if ([
      constants.COLORTYPE_GRAYSCALE,
      constants.COLORTYPE_COLOR,
      constants.COLORTYPE_COLOR_ALPHA,
      constants.COLORTYPE_ALPHA
    ].indexOf(options.inputColorType) === -1) {
      throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
    }
    if (options.bitDepth !== 8 && options.bitDepth !== 16) {
      throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
    }
  };
  Packer.prototype.getDeflateOptions = function() {
    return {
      chunkSize: this._options.deflateChunkSize,
      level: this._options.deflateLevel,
      strategy: this._options.deflateStrategy
    };
  };
  Packer.prototype.createDeflate = function() {
    return this._options.deflateFactory(this.getDeflateOptions());
  };
  Packer.prototype.filterData = function(data, width, height) {
    let packedData = bitPacker(data, width, height, this._options);
    let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
    let filteredData = filter(packedData, width, height, this._options, bpp);
    return filteredData;
  };
  Packer.prototype._packChunk = function(type3, data) {
    let len = data ? data.length : 0;
    let buf = Buffer.alloc(len + 12);
    buf.writeUInt32BE(len, 0);
    buf.writeUInt32BE(type3, 4);
    if (data) {
      data.copy(buf, 8);
    }
    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
    return buf;
  };
  Packer.prototype.packGAMA = function(gamma) {
    let buf = Buffer.alloc(4);
    buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
    return this._packChunk(constants.TYPE_gAMA, buf);
  };
  Packer.prototype.packIHDR = function(width, height) {
    let buf = Buffer.alloc(13);
    buf.writeUInt32BE(width, 0);
    buf.writeUInt32BE(height, 4);
    buf[8] = this._options.bitDepth;
    buf[9] = this._options.colorType;
    buf[10] = 0;
    buf[11] = 0;
    buf[12] = 0;
    return this._packChunk(constants.TYPE_IHDR, buf);
  };
  Packer.prototype.packIDAT = function(data) {
    return this._packChunk(constants.TYPE_IDAT, data);
  };
  Packer.prototype.packIEND = function() {
    return this._packChunk(constants.TYPE_IEND, null);
  };
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS((exports, module) => {
  var util = __require("util");
  var Stream = __require("stream");
  var constants = require_constants2();
  var Packer = require_packer();
  var PackerAsync = module.exports = function(opt) {
    Stream.call(this);
    let options = opt || {};
    this._packer = new Packer(options);
    this._deflate = this._packer.createDeflate();
    this.readable = true;
  };
  util.inherits(PackerAsync, Stream);
  PackerAsync.prototype.pack = function(data, width, height, gamma) {
    this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
    this.emit("data", this._packer.packIHDR(width, height));
    if (gamma) {
      this.emit("data", this._packer.packGAMA(gamma));
    }
    let filteredData = this._packer.filterData(data, width, height);
    this._deflate.on("error", this.emit.bind(this, "error"));
    this._deflate.on("data", function(compressedData) {
      this.emit("data", this._packer.packIDAT(compressedData));
    }.bind(this));
    this._deflate.on("end", function() {
      this.emit("data", this._packer.packIEND());
      this.emit("end");
    }.bind(this));
    this._deflate.end(filteredData);
  };
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS((exports, module) => {
  var assert = __require("assert").ok;
  var zlib = __require("zlib");
  var util = __require("util");
  var kMaxLength = __require("buffer").kMaxLength;
  function Inflate(opts) {
    if (!(this instanceof Inflate)) {
      return new Inflate(opts);
    }
    if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
      opts.chunkSize = zlib.Z_MIN_CHUNK;
    }
    zlib.Inflate.call(this, opts);
    this._offset = this._offset === undefined ? this._outOffset : this._offset;
    this._buffer = this._buffer || this._outBuffer;
    if (opts && opts.maxLength != null) {
      this._maxLength = opts.maxLength;
    }
  }
  function createInflate(opts) {
    return new Inflate(opts);
  }
  function _close(engine, callback) {
    if (callback) {
      process.nextTick(callback);
    }
    if (!engine._handle) {
      return;
    }
    engine._handle.close();
    engine._handle = null;
  }
  Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
    if (typeof asyncCb === "function") {
      return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
    }
    let self2 = this;
    let availInBefore = chunk && chunk.length;
    let availOutBefore = this._chunkSize - this._offset;
    let leftToInflate = this._maxLength;
    let inOff = 0;
    let buffers = [];
    let nread = 0;
    let error3;
    this.on("error", function(err) {
      error3 = err;
    });
    function handleChunk(availInAfter, availOutAfter) {
      if (self2._hadError) {
        return;
      }
      let have = availOutBefore - availOutAfter;
      assert(have >= 0, "have should not go down");
      if (have > 0) {
        let out = self2._buffer.slice(self2._offset, self2._offset + have);
        self2._offset += have;
        if (out.length > leftToInflate) {
          out = out.slice(0, leftToInflate);
        }
        buffers.push(out);
        nread += out.length;
        leftToInflate -= out.length;
        if (leftToInflate === 0) {
          return false;
        }
      }
      if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
        availOutBefore = self2._chunkSize;
        self2._offset = 0;
        self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
      }
      if (availOutAfter === 0) {
        inOff += availInBefore - availInAfter;
        availInBefore = availInAfter;
        return true;
      }
      return false;
    }
    assert(this._handle, "zlib binding closed");
    let res;
    do {
      res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
      res = res || this._writeState;
    } while (!this._hadError && handleChunk(res[0], res[1]));
    if (this._hadError) {
      throw error3;
    }
    if (nread >= kMaxLength) {
      _close(this);
      throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
    }
    let buf = Buffer.concat(buffers, nread);
    _close(this);
    return buf;
  };
  util.inherits(Inflate, zlib.Inflate);
  function zlibBufferSync(engine, buffer) {
    if (typeof buffer === "string") {
      buffer = Buffer.from(buffer);
    }
    if (!(buffer instanceof Buffer)) {
      throw new TypeError("Not a string or buffer");
    }
    let flushFlag = engine._finishFlushFlag;
    if (flushFlag == null) {
      flushFlag = zlib.Z_FINISH;
    }
    return engine._processChunk(buffer, flushFlag);
  }
  function inflateSync(buffer, opts) {
    return zlibBufferSync(new Inflate(opts), buffer);
  }
  module.exports = exports = inflateSync;
  exports.Inflate = Inflate;
  exports.createInflate = createInflate;
  exports.inflateSync = inflateSync;
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS((exports, module) => {
  var SyncReader = module.exports = function(buffer) {
    this._buffer = buffer;
    this._reads = [];
  };
  SyncReader.prototype.read = function(length, callback) {
    this._reads.push({
      length: Math.abs(length),
      allowLess: length < 0,
      func: callback
    });
  };
  SyncReader.prototype.process = function() {
    while (this._reads.length > 0 && this._buffer.length) {
      let read = this._reads[0];
      if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
        this._reads.shift();
        let buf = this._buffer;
        this._buffer = buf.slice(read.length);
        read.func.call(this, buf.slice(0, read.length));
      } else {
        break;
      }
    }
    if (this._reads.length > 0) {
      return new Error("There are some read requests waitng on finished stream");
    }
    if (this._buffer.length > 0) {
      return new Error("unrecognised content at end of stream");
    }
  };
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS((exports) => {
  var SyncReader = require_sync_reader();
  var Filter = require_filter_parse();
  exports.process = function(inBuffer, bitmapInfo) {
    let outBuffers = [];
    let reader = new SyncReader(inBuffer);
    let filter = new Filter(bitmapInfo, {
      read: reader.read.bind(reader),
      write: function(bufferPart) {
        outBuffers.push(bufferPart);
      },
      complete: function() {}
    });
    filter.start();
    reader.process();
    return Buffer.concat(outBuffers);
  };
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = __require("zlib");
  var inflateSync = require_sync_inflate();
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var SyncReader = require_sync_reader();
  var FilterSync = require_filter_parse_sync();
  var Parser = require_parser2();
  var bitmapper = require_bitmapper();
  var formatNormaliser = require_format_normaliser();
  module.exports = function(buffer, options) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let err;
    function handleError(_err_) {
      err = _err_;
    }
    let metaData;
    function handleMetaData(_metaData_) {
      metaData = _metaData_;
    }
    function handleTransColor(transColor) {
      metaData.transColor = transColor;
    }
    function handlePalette(palette) {
      metaData.palette = palette;
    }
    function handleSimpleTransparency() {
      metaData.alpha = true;
    }
    let gamma;
    function handleGamma(_gamma_) {
      gamma = _gamma_;
    }
    let inflateDataList = [];
    function handleInflateData(inflatedData2) {
      inflateDataList.push(inflatedData2);
    }
    let reader = new SyncReader(buffer);
    let parser = new Parser(options, {
      read: reader.read.bind(reader),
      error: handleError,
      metadata: handleMetaData,
      gamma: handleGamma,
      palette: handlePalette,
      transColor: handleTransColor,
      inflateData: handleInflateData,
      simpleTransparency: handleSimpleTransparency
    });
    parser.start();
    reader.process();
    if (err) {
      throw err;
    }
    let inflateData = Buffer.concat(inflateDataList);
    inflateDataList.length = 0;
    let inflatedData;
    if (metaData.interlace) {
      inflatedData = zlib.inflateSync(inflateData);
    } else {
      let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
      let imageSize = rowSize * metaData.height;
      inflatedData = inflateSync(inflateData, {
        chunkSize: imageSize,
        maxLength: imageSize
      });
    }
    inflateData = null;
    if (!inflatedData || !inflatedData.length) {
      throw new Error("bad png - invalid inflate data response");
    }
    let unfilteredData = FilterSync.process(inflatedData, metaData);
    inflateData = null;
    let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
    unfilteredData = null;
    let normalisedBitmapData = formatNormaliser(bitmapData, metaData);
    metaData.data = normalisedBitmapData;
    metaData.gamma = gamma || 0;
    return metaData;
  };
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS((exports, module) => {
  var hasSyncZlib = true;
  var zlib = __require("zlib");
  if (!zlib.deflateSync) {
    hasSyncZlib = false;
  }
  var constants = require_constants2();
  var Packer = require_packer();
  module.exports = function(metaData, opt) {
    if (!hasSyncZlib) {
      throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
    }
    let options = opt || {};
    let packer = new Packer(options);
    let chunks = [];
    chunks.push(Buffer.from(constants.PNG_SIGNATURE));
    chunks.push(packer.packIHDR(metaData.width, metaData.height));
    if (metaData.gamma) {
      chunks.push(packer.packGAMA(metaData.gamma));
    }
    let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
    let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
    filteredData = null;
    if (!compressedData || !compressedData.length) {
      throw new Error("bad png - invalid compressed data response");
    }
    chunks.push(packer.packIDAT(compressedData));
    chunks.push(packer.packIEND());
    return Buffer.concat(chunks);
  };
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS((exports) => {
  var parse3 = require_parser_sync();
  var pack = require_packer_sync();
  exports.read = function(buffer, options) {
    return parse3(buffer, options || {});
  };
  exports.write = function(png, options) {
    return pack(png, options);
  };
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS((exports) => {
  var util = __require("util");
  var Stream = __require("stream");
  var Parser = require_parser_async();
  var Packer = require_packer_async();
  var PNGSync = require_png_sync();
  var PNG = exports.PNG = function(options) {
    Stream.call(this);
    options = options || {};
    this.width = options.width | 0;
    this.height = options.height | 0;
    this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
    if (options.fill && this.data) {
      this.data.fill(0);
    }
    this.gamma = 0;
    this.readable = this.writable = true;
    this._parser = new Parser(options);
    this._parser.on("error", this.emit.bind(this, "error"));
    this._parser.on("close", this._handleClose.bind(this));
    this._parser.on("metadata", this._metadata.bind(this));
    this._parser.on("gamma", this._gamma.bind(this));
    this._parser.on("parsed", function(data) {
      this.data = data;
      this.emit("parsed", data);
    }.bind(this));
    this._packer = new Packer(options);
    this._packer.on("data", this.emit.bind(this, "data"));
    this._packer.on("end", this.emit.bind(this, "end"));
    this._parser.on("close", this._handleClose.bind(this));
    this._packer.on("error", this.emit.bind(this, "error"));
  };
  util.inherits(PNG, Stream);
  PNG.sync = PNGSync;
  PNG.prototype.pack = function() {
    if (!this.data || !this.data.length) {
      this.emit("error", "No data provided");
      return this;
    }
    process.nextTick(function() {
      this._packer.pack(this.data, this.width, this.height, this.gamma);
    }.bind(this));
    return this;
  };
  PNG.prototype.parse = function(data, callback) {
    if (callback) {
      let onParsed, onError;
      onParsed = function(parsedData) {
        this.removeListener("error", onError);
        this.data = parsedData;
        callback(null, this);
      }.bind(this);
      onError = function(err) {
        this.removeListener("parsed", onParsed);
        callback(err, null);
      }.bind(this);
      this.once("parsed", onParsed);
      this.once("error", onError);
    }
    this.end(data);
    return this;
  };
  PNG.prototype.write = function(data) {
    this._parser.write(data);
    return true;
  };
  PNG.prototype.end = function(data) {
    this._parser.end(data);
  };
  PNG.prototype._metadata = function(metadata) {
    this.width = metadata.width;
    this.height = metadata.height;
    this.emit("metadata", metadata);
  };
  PNG.prototype._gamma = function(gamma) {
    this.gamma = gamma;
  };
  PNG.prototype._handleClose = function() {
    if (!this._parser.writable && !this._packer.readable) {
      this.emit("close");
    }
  };
  PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
    srcX |= 0;
    srcY |= 0;
    width |= 0;
    height |= 0;
    deltaX |= 0;
    deltaY |= 0;
    if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
      throw new Error("bitblt reading outside image");
    }
    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
      throw new Error("bitblt writing outside image");
    }
    for (let y = 0;y < height; y++) {
      src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
    }
  };
  PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
    PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
    return this;
  };
  PNG.adjustGamma = function(src) {
    if (src.gamma) {
      for (let y = 0;y < src.height; y++) {
        for (let x = 0;x < src.width; x++) {
          let idx = src.width * y + x << 2;
          for (let i = 0;i < 3; i++) {
            let sample = src.data[idx + i] / 255;
            sample = Math.pow(sample, 1 / 2.2 / src.gamma);
            src.data[idx + i] = Math.round(sample * 255);
          }
        }
      }
      src.gamma = 0;
    }
  };
  PNG.prototype.adjustGamma = function() {
    PNG.adjustGamma(this);
  };
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils5 = __commonJS((exports) => {
  function hex2rgba(hex) {
    if (typeof hex === "number") {
      hex = hex.toString();
    }
    if (typeof hex !== "string") {
      throw new Error("Color should be defined as hex string");
    }
    let hexCode = hex.slice().replace("#", "").split("");
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error("Invalid hex color: " + hex);
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
        return [c, c];
      }));
    }
    if (hexCode.length === 6)
      hexCode.push("F", "F");
    const hexValue = parseInt(hexCode.join(""), 16);
    return {
      r: hexValue >> 24 & 255,
      g: hexValue >> 16 & 255,
      b: hexValue >> 8 & 255,
      a: hexValue & 255,
      hex: "#" + hexCode.slice(0, 6).join("")
    };
  }
  exports.getOptions = function getOptions(options) {
    if (!options)
      options = {};
    if (!options.color)
      options.color = {};
    const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
    const width = options.width && options.width >= 21 ? options.width : undefined;
    const scale = options.scale || 4;
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || "#000000ff"),
        light: hex2rgba(options.color.light || "#ffffffff")
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {}
    };
  };
  exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
  };
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts);
    return Math.floor((qrSize + opts.margin * 2) * scale);
  };
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size = qr.modules.size;
    const data = qr.modules.data;
    const scale = exports.getScale(size, opts);
    const symbolSize = Math.floor((size + opts.margin * 2) * scale);
    const scaledMargin = opts.margin * scale;
    const palette = [opts.color.light, opts.color.dark];
    for (let i = 0;i < symbolSize; i++) {
      for (let j = 0;j < symbolSize; j++) {
        let posDst = (i * symbolSize + j) * 4;
        let pxColor = opts.color.light;
        if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
          const iSrc = Math.floor((i - scaledMargin) / scale);
          const jSrc = Math.floor((j - scaledMargin) / scale);
          pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
        }
        imgData[posDst++] = pxColor.r;
        imgData[posDst++] = pxColor.g;
        imgData[posDst++] = pxColor.b;
        imgData[posDst] = pxColor.a;
      }
    }
  };
});

// node_modules/qrcode/lib/renderer/png.js
var require_png2 = __commonJS((exports) => {
  var fs = __require("fs");
  var PNG = require_png().PNG;
  var Utils = require_utils5();
  exports.render = function render(qrData, options) {
    const opts = Utils.getOptions(options);
    const pngOpts = opts.rendererOpts;
    const size = Utils.getImageWidth(qrData.modules.size, opts);
    pngOpts.width = size;
    pngOpts.height = size;
    const pngImage = new PNG(pngOpts);
    Utils.qrToImageData(pngImage.data, qrData, opts);
    return pngImage;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    exports.renderToBuffer(qrData, options, function(err, output) {
      if (err)
        cb(err);
      let url = "data:image/png;base64,";
      url += output.toString("base64");
      cb(null, url);
    });
  };
  exports.renderToBuffer = function renderToBuffer(qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    const png = exports.render(qrData, options);
    const buffer = [];
    png.on("error", cb);
    png.on("data", function(data) {
      buffer.push(data);
    });
    png.on("end", function() {
      cb(null, Buffer.concat(buffer));
    });
    png.pack();
  };
  exports.renderToFile = function renderToFile(path, qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    let called = false;
    const done = (...args) => {
      if (called)
        return;
      called = true;
      cb.apply(null, args);
    };
    const stream = fs.createWriteStream(path);
    stream.on("error", done);
    stream.on("close", done);
    exports.renderToFileStream(stream, qrData, options);
  };
  exports.renderToFileStream = function renderToFileStream(stream, qrData, options) {
    const png = exports.render(qrData, options);
    png.pack().pipe(stream);
  };
});

// node_modules/qrcode/lib/renderer/utf8.js
var require_utf8 = __commonJS((exports) => {
  var Utils = require_utils5();
  var BLOCK_CHAR = {
    WW: " ",
    WB: "▄",
    BB: "█",
    BW: "▀"
  };
  var INVERTED_BLOCK_CHAR = {
    BB: " ",
    BW: "▄",
    WW: "█",
    WB: "▀"
  };
  function getBlockChar(top, bottom, blocks) {
    if (top && bottom)
      return blocks.BB;
    if (top && !bottom)
      return blocks.BW;
    if (!top && bottom)
      return blocks.WB;
    return blocks.WW;
  }
  exports.render = function(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    let blocks = BLOCK_CHAR;
    if (opts.color.dark.hex === "#ffffff" || opts.color.light.hex === "#000000") {
      blocks = INVERTED_BLOCK_CHAR;
    }
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    let output = "";
    let hMargin = Array(size + opts.margin * 2 + 1).join(blocks.WW);
    hMargin = Array(opts.margin / 2 + 1).join(hMargin + `
`);
    const vMargin = Array(opts.margin + 1).join(blocks.WW);
    output += hMargin;
    for (let i = 0;i < size; i += 2) {
      output += vMargin;
      for (let j = 0;j < size; j++) {
        const topModule = data[i * size + j];
        const bottomModule = data[(i + 1) * size + j];
        output += getBlockChar(topModule, bottomModule, blocks);
      }
      output += vMargin + `
`;
    }
    output += hMargin.slice(0, -1);
    if (typeof cb === "function") {
      cb(null, output);
    }
    return output;
  };
  exports.renderToFile = function renderToFile(path, qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    const fs = __require("fs");
    const utf8 = exports.render(qrData, options);
    fs.writeFile(path, utf8, cb);
  };
});

// node_modules/qrcode/lib/renderer/terminal/terminal.js
var require_terminal = __commonJS((exports) => {
  exports.render = function(qrData, options, cb) {
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const black = "\x1B[40m  \x1B[0m";
    const white = "\x1B[47m  \x1B[0m";
    let output = "";
    const hMargin = Array(size + 3).join(white);
    const vMargin = Array(2).join(white);
    output += hMargin + `
`;
    for (let i = 0;i < size; ++i) {
      output += white;
      for (let j = 0;j < size; j++) {
        output += data[i * size + j] ? black : white;
      }
      output += vMargin + `
`;
    }
    output += hMargin + `
`;
    if (typeof cb === "function") {
      cb(null, output);
    }
    return output;
  };
});

// node_modules/qrcode/lib/renderer/terminal/terminal-small.js
var require_terminal_small = __commonJS((exports) => {
  var backgroundWhite = "\x1B[47m";
  var backgroundBlack = "\x1B[40m";
  var foregroundWhite = "\x1B[37m";
  var foregroundBlack = "\x1B[30m";
  var reset = "\x1B[0m";
  var lineSetupNormal = backgroundWhite + foregroundBlack;
  var lineSetupInverse = backgroundBlack + foregroundWhite;
  var createPalette = function(lineSetup, foregroundWhite2, foregroundBlack2) {
    return {
      "00": reset + " " + lineSetup,
      "01": reset + foregroundWhite2 + "▄" + lineSetup,
      "02": reset + foregroundBlack2 + "▄" + lineSetup,
      10: reset + foregroundWhite2 + "▀" + lineSetup,
      11: " ",
      12: "▄",
      20: reset + foregroundBlack2 + "▀" + lineSetup,
      21: "▀",
      22: "█"
    };
  };
  var mkCodePixel = function(modules, size, x, y) {
    const sizePlus = size + 1;
    if (x >= sizePlus || y >= sizePlus || y < -1 || x < -1)
      return "0";
    if (x >= size || y >= size || y < 0 || x < 0)
      return "1";
    const idx = y * size + x;
    return modules[idx] ? "2" : "1";
  };
  var mkCode = function(modules, size, x, y) {
    return mkCodePixel(modules, size, x, y) + mkCodePixel(modules, size, x, y + 1);
  };
  exports.render = function(qrData, options, cb) {
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const inverse = !!(options && options.inverse);
    const lineSetup = options && options.inverse ? lineSetupInverse : lineSetupNormal;
    const white = inverse ? foregroundBlack : foregroundWhite;
    const black = inverse ? foregroundWhite : foregroundBlack;
    const palette = createPalette(lineSetup, white, black);
    const newLine = reset + `
` + lineSetup;
    let output = lineSetup;
    for (let y = -1;y < size + 1; y += 2) {
      for (let x = -1;x < size; x++) {
        output += palette[mkCode(data, size, x, y)];
      }
      output += palette[mkCode(data, size, size, y)] + newLine;
    }
    output += reset;
    if (typeof cb === "function") {
      cb(null, output);
    }
    return output;
  };
});

// node_modules/qrcode/lib/renderer/terminal.js
var require_terminal2 = __commonJS((exports) => {
  var big = require_terminal();
  var small = require_terminal_small();
  exports.render = function(qrData, options, cb) {
    if (options && options.small) {
      return small.render(qrData, options, cb);
    }
    return big.render(qrData, options, cb);
  };
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS((exports) => {
  var Utils = require_utils5();
  function getColorAttrib(color, attrib) {
    const alpha = color.a / 255;
    const str = attrib + '="' + color.hex + '"';
    return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
  }
  function svgCmd(cmd, x, y) {
    let str = cmd + x;
    if (typeof y !== "undefined")
      str += " " + y;
    return str;
  }
  function qrToPath(data, size, margin) {
    let path = "";
    let moveBy = 0;
    let newRow = false;
    let lineLength = 0;
    for (let i = 0;i < data.length; i++) {
      const col = Math.floor(i % size);
      const row = Math.floor(i / size);
      if (!col && !newRow)
        newRow = true;
      if (data[i]) {
        lineLength++;
        if (!(i > 0 && col > 0 && data[i - 1])) {
          path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
          moveBy = 0;
          newRow = false;
        }
        if (!(col + 1 < size && data[i + 1])) {
          path += svgCmd("h", lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }
    return path;
  }
  exports.render = function render(qrData, options, cb) {
    const opts = Utils.getOptions(options);
    const size = qrData.modules.size;
    const data = qrData.modules.data;
    const qrcodesize = size + opts.margin * 2;
    const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
    const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
    const viewBox = 'viewBox="' + "0 0 " + qrcodesize + " " + qrcodesize + '"';
    const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
    const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + `</svg>
`;
    if (typeof cb === "function") {
      cb(null, svgTag);
    }
    return svgTag;
  };
});

// node_modules/qrcode/lib/renderer/svg.js
var require_svg = __commonJS((exports) => {
  var svgTagRenderer = require_svg_tag();
  exports.render = svgTagRenderer.render;
  exports.renderToFile = function renderToFile(path, qrData, options, cb) {
    if (typeof cb === "undefined") {
      cb = options;
      options = undefined;
    }
    const fs = __require("fs");
    const svgTag = exports.render(qrData, options);
    const xmlStr = '<?xml version="1.0" encoding="utf-8"?>' + '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">' + svgTag;
    fs.writeFile(path, xmlStr, cb);
  };
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS((exports) => {
  var Utils = require_utils5();
  function clearCanvas(ctx, canvas, size) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (!canvas.style)
      canvas.style = {};
    canvas.height = size;
    canvas.width = size;
    canvas.style.height = size + "px";
    canvas.style.width = size + "px";
  }
  function getCanvasElement() {
    try {
      return document.createElement("canvas");
    } catch (e) {
      throw new Error("You need to specify a canvas element");
    }
  }
  exports.render = function render(qrData, canvas, options) {
    let opts = options;
    let canvasEl = canvas;
    if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
      opts = canvas;
      canvas = undefined;
    }
    if (!canvas) {
      canvasEl = getCanvasElement();
    }
    opts = Utils.getOptions(opts);
    const size = Utils.getImageWidth(qrData.modules.size, opts);
    const ctx = canvasEl.getContext("2d");
    const image = ctx.createImageData(size, size);
    Utils.qrToImageData(image.data, qrData, opts);
    clearCanvas(ctx, canvasEl, size);
    ctx.putImageData(image, 0, 0);
    return canvasEl;
  };
  exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
    let opts = options;
    if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
      opts = canvas;
      canvas = undefined;
    }
    if (!opts)
      opts = {};
    const canvasEl = exports.render(qrData, canvas, opts);
    const type3 = opts.type || "image/png";
    const rendererOpts = opts.rendererOpts || {};
    return canvasEl.toDataURL(type3, rendererOpts.quality);
  };
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS((exports) => {
  var canPromise = require_can_promise();
  var QRCode = require_qrcode();
  var CanvasRenderer = require_canvas();
  var SvgRenderer = require_svg_tag();
  function renderCanvas(renderFunc, canvas, text, opts, cb) {
    const args = [].slice.call(arguments, 1);
    const argsNum = args.length;
    const isLastArgCb = typeof args[argsNum - 1] === "function";
    if (!isLastArgCb && !canPromise()) {
      throw new Error("Callback required as last argument");
    }
    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 2) {
        cb = text;
        text = canvas;
        canvas = opts = undefined;
      } else if (argsNum === 3) {
        if (canvas.getContext && typeof cb === "undefined") {
          cb = opts;
          opts = undefined;
        } else {
          cb = opts;
          opts = text;
          text = canvas;
          canvas = undefined;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error("Too few arguments provided");
      }
      if (argsNum === 1) {
        text = canvas;
        canvas = opts = undefined;
      } else if (argsNum === 2 && !canvas.getContext) {
        opts = text;
        text = canvas;
        canvas = undefined;
      }
      return new Promise(function(resolve, reject) {
        try {
          const data = QRCode.create(text, opts);
          resolve(renderFunc(data, canvas, opts));
        } catch (e) {
          reject(e);
        }
      });
    }
    try {
      const data = QRCode.create(text, opts);
      cb(null, renderFunc(data, canvas, opts));
    } catch (e) {
      cb(e);
    }
  }
  exports.create = QRCode.create;
  exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
  exports.toString = renderCanvas.bind(null, function(data, _, opts) {
    return SvgRenderer.render(data, opts);
  });
});

// node_modules/qrcode/lib/server.js
var require_server = __commonJS((exports) => {
  var canPromise = require_can_promise();
  var QRCode = require_qrcode();
  var PngRenderer = require_png2();
  var Utf8Renderer = require_utf8();
  var TerminalRenderer = require_terminal2();
  var SvgRenderer = require_svg();
  function checkParams(text, opts, cb) {
    if (typeof text === "undefined") {
      throw new Error("String required as first argument");
    }
    if (typeof cb === "undefined") {
      cb = opts;
      opts = {};
    }
    if (typeof cb !== "function") {
      if (!canPromise()) {
        throw new Error("Callback required as last argument");
      } else {
        opts = cb || {};
        cb = null;
      }
    }
    return {
      opts,
      cb
    };
  }
  function getTypeFromFilename(path) {
    return path.slice((path.lastIndexOf(".") - 1 >>> 0) + 2).toLowerCase();
  }
  function getRendererFromType(type3) {
    switch (type3) {
      case "svg":
        return SvgRenderer;
      case "txt":
      case "utf8":
        return Utf8Renderer;
      case "png":
      case "image/png":
      default:
        return PngRenderer;
    }
  }
  function getStringRendererFromType(type3) {
    switch (type3) {
      case "svg":
        return SvgRenderer;
      case "terminal":
        return TerminalRenderer;
      case "utf8":
      default:
        return Utf8Renderer;
    }
  }
  function render(renderFunc, text, params) {
    if (!params.cb) {
      return new Promise(function(resolve, reject) {
        try {
          const data = QRCode.create(text, params.opts);
          return renderFunc(data, params.opts, function(err, data2) {
            return err ? reject(err) : resolve(data2);
          });
        } catch (e) {
          reject(e);
        }
      });
    }
    try {
      const data = QRCode.create(text, params.opts);
      return renderFunc(data, params.opts, params.cb);
    } catch (e) {
      params.cb(e);
    }
  }
  exports.create = QRCode.create;
  exports.toCanvas = require_browser().toCanvas;
  exports.toString = function toString(text, opts, cb) {
    const params = checkParams(text, opts, cb);
    const type3 = params.opts ? params.opts.type : undefined;
    const renderer = getStringRendererFromType(type3);
    return render(renderer.render, text, params);
  };
  exports.toDataURL = function toDataURL(text, opts, cb) {
    const params = checkParams(text, opts, cb);
    const renderer = getRendererFromType(params.opts.type);
    return render(renderer.renderToDataURL, text, params);
  };
  exports.toBuffer = function toBuffer(text, opts, cb) {
    const params = checkParams(text, opts, cb);
    const renderer = getRendererFromType(params.opts.type);
    return render(renderer.renderToBuffer, text, params);
  };
  exports.toFile = function toFile(path, text, opts, cb) {
    if (typeof path !== "string" || !(typeof text === "string" || typeof text === "object")) {
      throw new Error("Invalid argument");
    }
    if (arguments.length < 3 && !canPromise()) {
      throw new Error("Too few arguments provided");
    }
    const params = checkParams(text, opts, cb);
    const type3 = params.opts.type || getTypeFromFilename(path);
    const renderer = getRendererFromType(type3);
    const renderToFile = renderer.renderToFile.bind(null, path);
    return render(renderToFile, text, params);
  };
  exports.toFileStream = function toFileStream(stream, text, opts) {
    if (arguments.length < 2) {
      throw new Error("Too few arguments provided");
    }
    const params = checkParams(text, opts, stream.emit.bind(stream, "error"));
    const renderer = getRendererFromType("png");
    const renderToFileStream = renderer.renderToFileStream.bind(null, stream);
    render(renderToFileStream, text, params);
  };
});

// node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS((exports, module) => {
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
      default: e
    };
  }
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS((exports, module) => {
  function _typeof(o) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && typeof Symbol == "function" && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/date-fns/_lib/toInteger/index.js
var require_toInteger = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toInteger;
  function toInteger(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number3 = Number(dirtyNumber);
    if (isNaN(number3)) {
      return number3;
    }
    return number3 < 0 ? Math.ceil(number3) : Math.floor(number3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/requiredArgs/index.js
var require_requiredArgs = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = requiredArgs;
  function requiredArgs(required3, args) {
    if (args.length < required3) {
      throw new TypeError(required3 + " argument" + (required3 > 1 ? "s" : "") + " required, but only " + args.length + " present");
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/toDate/index.js
var require_toDate = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = toDate;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_requiredArgs());
  function toDate(argument) {
    (0, _index.default)(1, arguments);
    var argStr = Object.prototype.toString.call(argument);
    if (argument instanceof Date || (0, _typeof2.default)(argument) === "object" && argStr === "[object Date]") {
      return new Date(argument.getTime());
    } else if (typeof argument === "number" || argStr === "[object Number]") {
      return new Date(argument);
    } else {
      if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addDays/index.js
var require_addDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addDays;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addDays(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var amount = (0, _index.default)(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      return date3;
    }
    date3.setDate(date3.getDate() + amount);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addMonths/index.js
var require_addMonths = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addMonths;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addMonths(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var amount = (0, _index.default)(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      return date3;
    }
    var dayOfMonth = date3.getDate();
    var endOfDesiredMonth = new Date(date3.getTime());
    endOfDesiredMonth.setMonth(date3.getMonth() + amount + 1, 0);
    var daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      date3.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
      return date3;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/add/index.js
var require_add = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = add;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_toInteger());
  function add(dirtyDate, duration) {
    (0, _index4.default)(2, arguments);
    if (!duration || (0, _typeof2.default)(duration) !== "object")
      return new Date(NaN);
    var years = duration.years ? (0, _index5.default)(duration.years) : 0;
    var months = duration.months ? (0, _index5.default)(duration.months) : 0;
    var weeks = duration.weeks ? (0, _index5.default)(duration.weeks) : 0;
    var days = duration.days ? (0, _index5.default)(duration.days) : 0;
    var hours = duration.hours ? (0, _index5.default)(duration.hours) : 0;
    var minutes = duration.minutes ? (0, _index5.default)(duration.minutes) : 0;
    var seconds = duration.seconds ? (0, _index5.default)(duration.seconds) : 0;
    var date3 = (0, _index3.default)(dirtyDate);
    var dateWithMonths = months || years ? (0, _index2.default)(date3, months + years * 12) : date3;
    var dateWithDays = days || weeks ? (0, _index.default)(dateWithMonths, days + weeks * 7) : dateWithMonths;
    var minutesToAdd = minutes + hours * 60;
    var secondsToAdd = seconds + minutesToAdd * 60;
    var msToAdd = secondsToAdd * 1000;
    var finalDate = new Date(dateWithDays.getTime() + msToAdd);
    return finalDate;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isWeekend/index.js
var require_isWeekend = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isWeekend;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isWeekend(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getDay();
    return day === 0 || day === 6;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSunday/index.js
var require_isSunday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSunday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSunday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 0;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSaturday/index.js
var require_isSaturday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSaturday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSaturday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 6;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addBusinessDays/index.js
var require_addBusinessDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addBusinessDays;
  var _index = _interopRequireDefault(require_isWeekend());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_isSunday());
  var _index6 = _interopRequireDefault(require_isSaturday());
  function addBusinessDays(dirtyDate, dirtyAmount) {
    (0, _index4.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var startedOnWeekend = (0, _index.default)(date3);
    var amount = (0, _index3.default)(dirtyAmount);
    if (isNaN(amount))
      return new Date(NaN);
    var hours = date3.getHours();
    var sign = amount < 0 ? -1 : 1;
    var fullWeeks = (0, _index3.default)(amount / 5);
    date3.setDate(date3.getDate() + fullWeeks * 7);
    var restDays = Math.abs(amount % 5);
    while (restDays > 0) {
      date3.setDate(date3.getDate() + sign);
      if (!(0, _index.default)(date3))
        restDays -= 1;
    }
    if (startedOnWeekend && (0, _index.default)(date3) && amount !== 0) {
      if ((0, _index6.default)(date3))
        date3.setDate(date3.getDate() + (sign < 0 ? 2 : -1));
      if ((0, _index5.default)(date3))
        date3.setDate(date3.getDate() + (sign < 0 ? 1 : -2));
    }
    date3.setHours(hours);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addMilliseconds/index.js
var require_addMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addMilliseconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addMilliseconds(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var timestamp = (0, _index2.default)(dirtyDate).getTime();
    var amount = (0, _index.default)(dirtyAmount);
    return new Date(timestamp + amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addHours/index.js
var require_addHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addHours;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_HOUR = 3600000;
  function addHours(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * MILLISECONDS_IN_HOUR);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/defaultOptions/index.js
var require_defaultOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getDefaultOptions = getDefaultOptions;
  exports.setDefaultOptions = setDefaultOptions;
  var defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }
  function setDefaultOptions(newOptions) {
    defaultOptions = newOptions;
  }
});

// node_modules/date-fns/startOfWeek/index.js
var require_startOfWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_toInteger());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_defaultOptions();
  function startOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index3.default)(1, arguments);
    var defaultOptions = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date3.setDate(date3.getDate() - diff);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfISOWeek/index.js
var require_startOfISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfISOWeek;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, {
      weekStartsOn: 1
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getISOWeekYear/index.js
var require_getISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getISOWeekYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function getISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index2.default)(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index2.default)(fourthOfJanuaryOfThisYear);
    if (date3.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date3.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfISOWeekYear/index.js
var require_startOfISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfISOWeekYear;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function startOfISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    var date3 = (0, _index2.default)(fourthOfJanuary);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/getTimezoneOffsetInMilliseconds/index.js
var require_getTimezoneOffsetInMilliseconds = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getTimezoneOffsetInMilliseconds;
  function getTimezoneOffsetInMilliseconds(date3) {
    var utcDate = new Date(Date.UTC(date3.getFullYear(), date3.getMonth(), date3.getDate(), date3.getHours(), date3.getMinutes(), date3.getSeconds(), date3.getMilliseconds()));
    utcDate.setUTCFullYear(date3.getFullYear());
    return date3.getTime() - utcDate.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfDay/index.js
var require_startOfDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarDays/index.js
var require_differenceInCalendarDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarDays;
  var _index = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index2 = _interopRequireDefault(require_startOfDay());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_DAY = 86400000;
  function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var startOfDayLeft = (0, _index2.default)(dirtyDateLeft);
    var startOfDayRight = (0, _index2.default)(dirtyDateRight);
    var timestampLeft = startOfDayLeft.getTime() - (0, _index.default)(startOfDayLeft);
    var timestampRight = startOfDayRight.getTime() - (0, _index.default)(startOfDayRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setISOWeekYear/index.js
var require_setISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setISOWeekYear;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_startOfISOWeekYear());
  var _index4 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  function setISOWeekYear(dirtyDate, dirtyISOWeekYear) {
    (0, _index5.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var isoWeekYear = (0, _index.default)(dirtyISOWeekYear);
    var diff = (0, _index4.default)(date3, (0, _index3.default)(date3));
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(isoWeekYear, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    date3 = (0, _index3.default)(fourthOfJanuary);
    date3.setDate(date3.getDate() + diff);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addISOWeekYears/index.js
var require_addISOWeekYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addISOWeekYears;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_getISOWeekYear());
  var _index3 = _interopRequireDefault(require_setISOWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function addISOWeekYears(dirtyDate, dirtyAmount) {
    (0, _index4.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index3.default)(dirtyDate, (0, _index2.default)(dirtyDate) + amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addMinutes/index.js
var require_addMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addMinutes;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_MINUTE = 60000;
  function addMinutes(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * MILLISECONDS_IN_MINUTE);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addQuarters/index.js
var require_addQuarters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addQuarters;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addQuarters(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    var months = amount * 3;
    return (0, _index2.default)(dirtyDate, months);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addSeconds/index.js
var require_addSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addSeconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addSeconds(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * 1000);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addWeeks/index.js
var require_addWeeks = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addWeeks;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addDays());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addWeeks(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    var days = amount * 7;
    return (0, _index2.default)(dirtyDate, days);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/addYears/index.js
var require_addYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addYears;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function addYears(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, amount * 12);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/areIntervalsOverlapping/index.js
var require_areIntervalsOverlapping = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = areIntervalsOverlapping;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function areIntervalsOverlapping(intervalLeft, intervalRight, options) {
    (0, _index2.default)(2, arguments);
    var leftStartTime = (0, _index.default)(intervalLeft === null || intervalLeft === undefined ? undefined : intervalLeft.start).getTime();
    var leftEndTime = (0, _index.default)(intervalLeft === null || intervalLeft === undefined ? undefined : intervalLeft.end).getTime();
    var rightStartTime = (0, _index.default)(intervalRight === null || intervalRight === undefined ? undefined : intervalRight.start).getTime();
    var rightEndTime = (0, _index.default)(intervalRight === null || intervalRight === undefined ? undefined : intervalRight.end).getTime();
    if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
      throw new RangeError("Invalid interval");
    }
    if (options !== null && options !== undefined && options.inclusive) {
      return leftStartTime <= rightEndTime && rightStartTime <= leftEndTime;
    }
    return leftStartTime < rightEndTime && rightStartTime < leftEndTime;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/max/index.js
var require_max = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = max;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function max(dirtyDatesArray) {
    (0, _index2.default)(1, arguments);
    var datesArray;
    if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else if ((0, _typeof2.default)(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    } else {
      return new Date(NaN);
    }
    var result;
    datesArray.forEach(function(dirtyDate) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (result === undefined || result < currentDate || isNaN(Number(currentDate))) {
        result = currentDate;
      }
    });
    return result || new Date(NaN);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/min/index.js
var require_min = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = min;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function min(dirtyDatesArray) {
    (0, _index2.default)(1, arguments);
    var datesArray;
    if (dirtyDatesArray && typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else if ((0, _typeof2.default)(dirtyDatesArray) === "object" && dirtyDatesArray !== null) {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    } else {
      return new Date(NaN);
    }
    var result;
    datesArray.forEach(function(dirtyDate) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (result === undefined || result > currentDate || isNaN(currentDate.getDate())) {
        result = currentDate;
      }
    });
    return result || new Date(NaN);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/clamp/index.js
var require_clamp = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = clamp;
  var _index = _interopRequireDefault(require_max());
  var _index2 = _interopRequireDefault(require_min());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function clamp(date3, _ref) {
    var { start, end } = _ref;
    (0, _index3.default)(2, arguments);
    return (0, _index2.default)([(0, _index.default)([date3, start]), end]);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/closestIndexTo/index.js
var require_closestIndexTo = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = closestIndexTo;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function closestIndexTo(dirtyDateToCompare, dirtyDatesArray) {
    (0, _index2.default)(2, arguments);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    if (isNaN(Number(dateToCompare)))
      return NaN;
    var timeToCompare = dateToCompare.getTime();
    var datesArray;
    if (dirtyDatesArray == null) {
      datesArray = [];
    } else if (typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    }
    var result;
    var minDistance;
    datesArray.forEach(function(dirtyDate, index) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (isNaN(Number(currentDate))) {
        result = NaN;
        minDistance = NaN;
        return;
      }
      var distance = Math.abs(timeToCompare - currentDate.getTime());
      if (result == null || distance < Number(minDistance)) {
        result = index;
        minDistance = distance;
      }
    });
    return result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/closestTo/index.js
var require_closestTo = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = closestTo;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function closestTo(dirtyDateToCompare, dirtyDatesArray) {
    (0, _index2.default)(2, arguments);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    if (isNaN(Number(dateToCompare)))
      return new Date(NaN);
    var timeToCompare = dateToCompare.getTime();
    var datesArray;
    if (dirtyDatesArray == null) {
      datesArray = [];
    } else if (typeof dirtyDatesArray.forEach === "function") {
      datesArray = dirtyDatesArray;
    } else {
      datesArray = Array.prototype.slice.call(dirtyDatesArray);
    }
    var result;
    var minDistance;
    datesArray.forEach(function(dirtyDate) {
      var currentDate = (0, _index.default)(dirtyDate);
      if (isNaN(Number(currentDate))) {
        result = new Date(NaN);
        minDistance = NaN;
        return;
      }
      var distance = Math.abs(timeToCompare - currentDate.getTime());
      if (result == null || distance < Number(minDistance)) {
        result = currentDate;
        minDistance = distance;
      }
    });
    return result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/compareAsc/index.js
var require_compareAsc = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = compareAsc;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function compareAsc(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/compareDesc/index.js
var require_compareDesc = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = compareDesc;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function compareDesc(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff > 0) {
      return -1;
    } else if (diff < 0) {
      return 1;
    } else {
      return diff;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/constants/index.js
var require_constants3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.secondsInYear = exports.secondsInWeek = exports.secondsInQuarter = exports.secondsInMonth = exports.secondsInMinute = exports.secondsInHour = exports.secondsInDay = exports.quartersInYear = exports.monthsInYear = exports.monthsInQuarter = exports.minutesInHour = exports.minTime = exports.millisecondsInSecond = exports.millisecondsInMinute = exports.millisecondsInHour = exports.maxTime = exports.daysInYear = exports.daysInWeek = undefined;
  var daysInWeek = 7;
  exports.daysInWeek = daysInWeek;
  var daysInYear = 365.2425;
  exports.daysInYear = daysInYear;
  var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
  exports.maxTime = maxTime;
  var millisecondsInMinute = 60000;
  exports.millisecondsInMinute = millisecondsInMinute;
  var millisecondsInHour = 3600000;
  exports.millisecondsInHour = millisecondsInHour;
  var millisecondsInSecond = 1000;
  exports.millisecondsInSecond = millisecondsInSecond;
  var minTime = -maxTime;
  exports.minTime = minTime;
  var minutesInHour = 60;
  exports.minutesInHour = minutesInHour;
  var monthsInQuarter = 3;
  exports.monthsInQuarter = monthsInQuarter;
  var monthsInYear = 12;
  exports.monthsInYear = monthsInYear;
  var quartersInYear = 4;
  exports.quartersInYear = quartersInYear;
  var secondsInHour = 3600;
  exports.secondsInHour = secondsInHour;
  var secondsInMinute = 60;
  exports.secondsInMinute = secondsInMinute;
  var secondsInDay = secondsInHour * 24;
  exports.secondsInDay = secondsInDay;
  var secondsInWeek = secondsInDay * 7;
  exports.secondsInWeek = secondsInWeek;
  var secondsInYear = secondsInDay * daysInYear;
  exports.secondsInYear = secondsInYear;
  var secondsInMonth = secondsInYear / 12;
  exports.secondsInMonth = secondsInMonth;
  var secondsInQuarter = secondsInMonth * 3;
  exports.secondsInQuarter = secondsInQuarter;
});

// node_modules/date-fns/daysToWeeks/index.js
var require_daysToWeeks = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = daysToWeeks;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function daysToWeeks(days) {
    (0, _index.default)(1, arguments);
    var weeks = days / _index2.daysInWeek;
    return Math.floor(weeks);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameDay/index.js
var require_isSameDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameDay;
  var _index = _interopRequireDefault(require_startOfDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameDay(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfDay = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfDay = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isDate/index.js
var require_isDate = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isDate;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_requiredArgs());
  function isDate(value2) {
    (0, _index.default)(1, arguments);
    return value2 instanceof Date || (0, _typeof2.default)(value2) === "object" && Object.prototype.toString.call(value2) === "[object Date]";
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isValid/index.js
var require_isValid = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isValid;
  var _index = _interopRequireDefault(require_isDate());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isValid(dirtyDate) {
    (0, _index3.default)(1, arguments);
    if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== "number") {
      return false;
    }
    var date3 = (0, _index2.default)(dirtyDate);
    return !isNaN(Number(date3));
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInBusinessDays/index.js
var require_differenceInBusinessDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInBusinessDays;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_isSameDay());
  var _index4 = _interopRequireDefault(require_isValid());
  var _index5 = _interopRequireDefault(require_isWeekend());
  var _index6 = _interopRequireDefault(require_toDate());
  var _index7 = _interopRequireDefault(require_requiredArgs());
  var _index8 = _interopRequireDefault(require_toInteger());
  function differenceInBusinessDays(dirtyDateLeft, dirtyDateRight) {
    (0, _index7.default)(2, arguments);
    var dateLeft = (0, _index6.default)(dirtyDateLeft);
    var dateRight = (0, _index6.default)(dirtyDateRight);
    if (!(0, _index4.default)(dateLeft) || !(0, _index4.default)(dateRight))
      return NaN;
    var calendarDifference = (0, _index2.default)(dateLeft, dateRight);
    var sign = calendarDifference < 0 ? -1 : 1;
    var weeks = (0, _index8.default)(calendarDifference / 7);
    var result = weeks * 5;
    dateRight = (0, _index.default)(dateRight, weeks * 7);
    while (!(0, _index3.default)(dateLeft, dateRight)) {
      result += (0, _index5.default)(dateRight) ? 0 : sign;
      dateRight = (0, _index.default)(dateRight, sign);
    }
    return result === 0 ? 0 : result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarISOWeekYears/index.js
var require_differenceInCalendarISOWeekYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarISOWeekYears;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarISOWeekYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    return (0, _index.default)(dirtyDateLeft) - (0, _index.default)(dirtyDateRight);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarISOWeeks/index.js
var require_differenceInCalendarISOWeeks = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarISOWeeks;
  var _index = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function differenceInCalendarISOWeeks(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var startOfISOWeekLeft = (0, _index2.default)(dirtyDateLeft);
    var startOfISOWeekRight = (0, _index2.default)(dirtyDateRight);
    var timestampLeft = startOfISOWeekLeft.getTime() - (0, _index.default)(startOfISOWeekLeft);
    var timestampRight = startOfISOWeekRight.getTime() - (0, _index.default)(startOfISOWeekRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarMonths/index.js
var require_differenceInCalendarMonths = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarMonths;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
    return yearDiff * 12 + monthDiff;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getQuarter/index.js
var require_getQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var quarter = Math.floor(date3.getMonth() / 3) + 1;
    return quarter;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarQuarters/index.js
var require_differenceInCalendarQuarters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarQuarters;
  var _index = _interopRequireDefault(require_getQuarter());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarQuarters(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var dateLeft = (0, _index2.default)(dirtyDateLeft);
    var dateRight = (0, _index2.default)(dirtyDateRight);
    var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
    var quarterDiff = (0, _index.default)(dateLeft) - (0, _index.default)(dateRight);
    return yearDiff * 4 + quarterDiff;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarWeeks/index.js
var require_differenceInCalendarWeeks = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarWeeks;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function differenceInCalendarWeeks(dirtyDateLeft, dirtyDateRight, options) {
    (0, _index3.default)(2, arguments);
    var startOfWeekLeft = (0, _index.default)(dirtyDateLeft, options);
    var startOfWeekRight = (0, _index.default)(dirtyDateRight, options);
    var timestampLeft = startOfWeekLeft.getTime() - (0, _index2.default)(startOfWeekLeft);
    var timestampRight = startOfWeekRight.getTime() - (0, _index2.default)(startOfWeekRight);
    return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_WEEK);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInCalendarYears/index.js
var require_differenceInCalendarYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInCalendarYears;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInCalendarYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getFullYear() - dateRight.getFullYear();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInDays/index.js
var require_differenceInDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInDays;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function compareLocalAsc(dateLeft, dateRight) {
    var diff = dateLeft.getFullYear() - dateRight.getFullYear() || dateLeft.getMonth() - dateRight.getMonth() || dateLeft.getDate() - dateRight.getDate() || dateLeft.getHours() - dateRight.getHours() || dateLeft.getMinutes() - dateRight.getMinutes() || dateLeft.getSeconds() - dateRight.getSeconds() || dateLeft.getMilliseconds() - dateRight.getMilliseconds();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
    } else {
      return diff;
    }
  }
  function differenceInDays(dirtyDateLeft, dirtyDateRight) {
    (0, _index3.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = compareLocalAsc(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    dateLeft.setDate(dateLeft.getDate() - sign * difference);
    var isLastDayNotFull = Number(compareLocalAsc(dateLeft, dateRight) === -sign);
    var result = sign * (difference - isLastDayNotFull);
    return result === 0 ? 0 : result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInMilliseconds/index.js
var require_differenceInMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInMilliseconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function differenceInMilliseconds(dateLeft, dateRight) {
    (0, _index2.default)(2, arguments);
    return (0, _index.default)(dateLeft).getTime() - (0, _index.default)(dateRight).getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/roundingMethods/index.js
var require_roundingMethods = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getRoundingMethod = getRoundingMethod;
  var roundingMap = {
    ceil: Math.ceil,
    round: Math.round,
    floor: Math.floor,
    trunc: function trunc(value2) {
      return value2 < 0 ? Math.ceil(value2) : Math.floor(value2);
    }
  };
  var defaultRoundingMethod = "trunc";
  function getRoundingMethod(method) {
    return method ? roundingMap[method] : roundingMap[defaultRoundingMethod];
  }
});

// node_modules/date-fns/differenceInHours/index.js
var require_differenceInHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInHours;
  var _index = require_constants3();
  var _index2 = _interopRequireDefault(require_differenceInMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_roundingMethods();
  function differenceInHours(dateLeft, dateRight, options) {
    (0, _index3.default)(2, arguments);
    var diff = (0, _index2.default)(dateLeft, dateRight) / _index.millisecondsInHour;
    return (0, _index4.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subISOWeekYears/index.js
var require_subISOWeekYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subISOWeekYears;
  var _index = _interopRequireDefault(require_addISOWeekYears());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subISOWeekYears(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInISOWeekYears/index.js
var require_differenceInISOWeekYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInISOWeekYears;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarISOWeekYears());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_subISOWeekYears());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  function differenceInISOWeekYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index5.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    dateLeft = (0, _index4.default)(dateLeft, sign * difference);
    var isLastISOWeekYearNotFull = Number((0, _index3.default)(dateLeft, dateRight) === -sign);
    var result = sign * (difference - isLastISOWeekYearNotFull);
    return result === 0 ? 0 : result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInMinutes/index.js
var require_differenceInMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInMinutes;
  var _index = require_constants3();
  var _index2 = _interopRequireDefault(require_differenceInMilliseconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_roundingMethods();
  function differenceInMinutes(dateLeft, dateRight, options) {
    (0, _index3.default)(2, arguments);
    var diff = (0, _index2.default)(dateLeft, dateRight) / _index.millisecondsInMinute;
    return (0, _index4.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfDay/index.js
var require_endOfDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfMonth/index.js
var require_endOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var month = date3.getMonth();
    date3.setFullYear(date3.getFullYear(), month + 1, 0);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isLastDayOfMonth/index.js
var require_isLastDayOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLastDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_endOfDay());
  var _index3 = _interopRequireDefault(require_endOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function isLastDayOfMonth(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    return (0, _index2.default)(date3).getTime() === (0, _index3.default)(date3).getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInMonths/index.js
var require_differenceInMonths = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInMonths;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = _interopRequireDefault(require_isLastDayOfMonth());
  function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
    (0, _index4.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    var result;
    if (difference < 1) {
      result = 0;
    } else {
      if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
        dateLeft.setDate(30);
      }
      dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
      var isLastMonthNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;
      if ((0, _index5.default)((0, _index.default)(dirtyDateLeft)) && difference === 1 && (0, _index3.default)(dirtyDateLeft, dateRight) === 1) {
        isLastMonthNotFull = false;
      }
      result = sign * (difference - Number(isLastMonthNotFull));
    }
    return result === 0 ? 0 : result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInQuarters/index.js
var require_differenceInQuarters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInQuarters;
  var _index = _interopRequireDefault(require_differenceInMonths());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = require_roundingMethods();
  function differenceInQuarters(dateLeft, dateRight, options) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dateLeft, dateRight) / 3;
    return (0, _index3.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInSeconds/index.js
var require_differenceInSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInSeconds;
  var _index = _interopRequireDefault(require_differenceInMilliseconds());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = require_roundingMethods();
  function differenceInSeconds(dateLeft, dateRight, options) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dateLeft, dateRight) / 1000;
    return (0, _index3.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInWeeks/index.js
var require_differenceInWeeks = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInWeeks;
  var _index = _interopRequireDefault(require_differenceInDays());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = require_roundingMethods();
  function differenceInWeeks(dateLeft, dateRight, options) {
    (0, _index2.default)(2, arguments);
    var diff = (0, _index.default)(dateLeft, dateRight) / 7;
    return (0, _index3.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod)(diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/differenceInYears/index.js
var require_differenceInYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = differenceInYears;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_differenceInCalendarYears());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function differenceInYears(dirtyDateLeft, dirtyDateRight) {
    (0, _index4.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    var sign = (0, _index3.default)(dateLeft, dateRight);
    var difference = Math.abs((0, _index2.default)(dateLeft, dateRight));
    dateLeft.setFullYear(1584);
    dateRight.setFullYear(1584);
    var isLastYearNotFull = (0, _index3.default)(dateLeft, dateRight) === -sign;
    var result = sign * (difference - Number(isLastYearNotFull));
    return result === 0 ? 0 : result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachDayOfInterval/index.js
var require_eachDayOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachDayOfInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function eachDayOfInterval(dirtyInterval, options) {
    var _options$step;
    (0, _index2.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _index.default)(interval.start);
    var endDate = (0, _index.default)(interval.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    var step = Number((_options$step = options === null || options === undefined ? undefined : options.step) !== null && _options$step !== undefined ? _options$step : 1);
    if (step < 1 || isNaN(step))
      throw new RangeError("`options.step` must be a number greater than 1");
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index.default)(currentDate));
      currentDate.setDate(currentDate.getDate() + step);
      currentDate.setHours(0, 0, 0, 0);
    }
    return dates;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachHourOfInterval/index.js
var require_eachHourOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachHourOfInterval;
  var _index = _interopRequireDefault(require_addHours());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function eachHourOfInterval(dirtyInterval, options) {
    var _options$step;
    (0, _index3.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _index2.default)(interval.start);
    var endDate = (0, _index2.default)(interval.end);
    var startTime = startDate.getTime();
    var endTime = endDate.getTime();
    if (!(startTime <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    currentDate.setMinutes(0, 0, 0);
    var step = Number((_options$step = options === null || options === undefined ? undefined : options.step) !== null && _options$step !== undefined ? _options$step : 1);
    if (step < 1 || isNaN(step))
      throw new RangeError("`options.step` must be a number greater than 1");
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index2.default)(currentDate));
      currentDate = (0, _index.default)(currentDate, step);
    }
    return dates;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfMinute/index.js
var require_startOfMinute = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfMinute;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfMinute(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setSeconds(0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachMinuteOfInterval/index.js
var require_eachMinuteOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachMinuteOfInterval;
  var _index = _interopRequireDefault(require_addMinutes());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_startOfMinute());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachMinuteOfInterval(interval, options) {
    var _options$step;
    (0, _index4.default)(1, arguments);
    var startDate = (0, _index3.default)((0, _index2.default)(interval.start));
    var endDate = (0, _index2.default)(interval.end);
    var startTime = startDate.getTime();
    var endTime = endDate.getTime();
    if (startTime >= endTime) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    var step = Number((_options$step = options === null || options === undefined ? undefined : options.step) !== null && _options$step !== undefined ? _options$step : 1);
    if (step < 1 || isNaN(step))
      throw new RangeError("`options.step` must be a number equal to or greater than 1");
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index2.default)(currentDate));
      currentDate = (0, _index.default)(currentDate, step);
    }
    return dates;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachMonthOfInterval/index.js
var require_eachMonthOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachMonthOfInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function eachMonthOfInterval(dirtyInterval) {
    (0, _index2.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _index.default)(interval.start);
    var endDate = (0, _index.default)(interval.end);
    var endTime = endDate.getTime();
    var dates = [];
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setDate(1);
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index.default)(currentDate));
      currentDate.setMonth(currentDate.getMonth() + 1);
    }
    return dates;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfQuarter/index.js
var require_startOfQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var currentMonth = date3.getMonth();
    var month = currentMonth - currentMonth % 3;
    date3.setMonth(month, 1);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachQuarterOfInterval/index.js
var require_eachQuarterOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachQuarterOfInterval;
  var _index = _interopRequireDefault(require_addQuarters());
  var _index2 = _interopRequireDefault(require_startOfQuarter());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachQuarterOfInterval(dirtyInterval) {
    (0, _index4.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _index3.default)(interval.start);
    var endDate = (0, _index3.default)(interval.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var startDateQuarter = (0, _index2.default)(startDate);
    var endDateQuarter = (0, _index2.default)(endDate);
    endTime = endDateQuarter.getTime();
    var quarters = [];
    var currentQuarter = startDateQuarter;
    while (currentQuarter.getTime() <= endTime) {
      quarters.push((0, _index3.default)(currentQuarter));
      currentQuarter = (0, _index.default)(currentQuarter, 1);
    }
    return quarters;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachWeekOfInterval/index.js
var require_eachWeekOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachWeekOfInterval;
  var _index = _interopRequireDefault(require_addWeeks());
  var _index2 = _interopRequireDefault(require_startOfWeek());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekOfInterval(dirtyInterval, options) {
    (0, _index4.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _index3.default)(interval.start);
    var endDate = (0, _index3.default)(interval.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var startDateWeek = (0, _index2.default)(startDate, options);
    var endDateWeek = (0, _index2.default)(endDate, options);
    startDateWeek.setHours(15);
    endDateWeek.setHours(15);
    endTime = endDateWeek.getTime();
    var weeks = [];
    var currentWeek = startDateWeek;
    while (currentWeek.getTime() <= endTime) {
      currentWeek.setHours(0);
      weeks.push((0, _index3.default)(currentWeek));
      currentWeek = (0, _index.default)(currentWeek, 1);
      currentWeek.setHours(15);
    }
    return weeks;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachWeekendOfInterval/index.js
var require_eachWeekendOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachWeekendOfInterval;
  var _index = _interopRequireDefault(require_eachDayOfInterval());
  var _index2 = _interopRequireDefault(require_isSunday());
  var _index3 = _interopRequireDefault(require_isWeekend());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekendOfInterval(interval) {
    (0, _index4.default)(1, arguments);
    var dateInterval = (0, _index.default)(interval);
    var weekends = [];
    var index = 0;
    while (index < dateInterval.length) {
      var date3 = dateInterval[index++];
      if ((0, _index3.default)(date3)) {
        weekends.push(date3);
        if ((0, _index2.default)(date3))
          index = index + 5;
      }
    }
    return weekends;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfMonth/index.js
var require_startOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setDate(1);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachWeekendOfMonth/index.js
var require_eachWeekendOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachWeekendOfMonth;
  var _index = _interopRequireDefault(require_eachWeekendOfInterval());
  var _index2 = _interopRequireDefault(require_startOfMonth());
  var _index3 = _interopRequireDefault(require_endOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekendOfMonth(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var startDate = (0, _index2.default)(dirtyDate);
    if (isNaN(startDate.getTime()))
      throw new RangeError("The passed date is invalid");
    var endDate = (0, _index3.default)(dirtyDate);
    return (0, _index.default)({
      start: startDate,
      end: endDate
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfYear/index.js
var require_endOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    date3.setFullYear(year + 1, 0, 0);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfYear/index.js
var require_startOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var cleanDate = (0, _index.default)(dirtyDate);
    var date3 = new Date(0);
    date3.setFullYear(cleanDate.getFullYear(), 0, 1);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachWeekendOfYear/index.js
var require_eachWeekendOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachWeekendOfYear;
  var _index = _interopRequireDefault(require_eachWeekendOfInterval());
  var _index2 = _interopRequireDefault(require_endOfYear());
  var _index3 = _interopRequireDefault(require_startOfYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function eachWeekendOfYear(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var startDate = (0, _index3.default)(dirtyDate);
    var endDate = (0, _index2.default)(dirtyDate);
    return (0, _index.default)({
      start: startDate,
      end: endDate
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/eachYearOfInterval/index.js
var require_eachYearOfInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = eachYearOfInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function eachYearOfInterval(dirtyInterval) {
    (0, _index2.default)(1, arguments);
    var interval = dirtyInterval || {};
    var startDate = (0, _index.default)(interval.start);
    var endDate = (0, _index.default)(interval.end);
    var endTime = endDate.getTime();
    if (!(startDate.getTime() <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    var dates = [];
    var currentDate = startDate;
    currentDate.setHours(0, 0, 0, 0);
    currentDate.setMonth(0, 1);
    while (currentDate.getTime() <= endTime) {
      dates.push((0, _index.default)(currentDate));
      currentDate.setFullYear(currentDate.getFullYear() + 1);
    }
    return dates;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfDecade/index.js
var require_endOfDecade = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    var decade = 9 + Math.floor(year / 10) * 10;
    date3.setFullYear(decade, 11, 31);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfHour/index.js
var require_endOfHour = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfHour;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfHour(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setMinutes(59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfWeek/index.js
var require_endOfWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfWeek;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function endOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(1, arguments);
    var defaultOptions = (0, _index.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date3 = (0, _index2.default)(dirtyDate);
    var day = date3.getDay();
    var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    date3.setDate(date3.getDate() + diff);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfISOWeek/index.js
var require_endOfISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfISOWeek;
  var _index = _interopRequireDefault(require_endOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, {
      weekStartsOn: 1
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfISOWeekYear/index.js
var require_endOfISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfISOWeekYear;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function endOfISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    var date3 = (0, _index2.default)(fourthOfJanuaryOfNextYear);
    date3.setMilliseconds(date3.getMilliseconds() - 1);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfMinute/index.js
var require_endOfMinute = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfMinute;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfMinute(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setSeconds(59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfQuarter/index.js
var require_endOfQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var currentMonth = date3.getMonth();
    var month = currentMonth - currentMonth % 3 + 3;
    date3.setMonth(month, 0);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfSecond/index.js
var require_endOfSecond = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfSecond;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function endOfSecond(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setMilliseconds(999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfToday/index.js
var require_endOfToday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfToday;
  var _index = _interopRequireDefault(require_endOfDay());
  function endOfToday() {
    return (0, _index.default)(Date.now());
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfTomorrow/index.js
var require_endOfTomorrow = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfTomorrow;
  function endOfTomorrow() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date3 = new Date(0);
    date3.setFullYear(year, month, day + 1);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/endOfYesterday/index.js
var require_endOfYesterday = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = endOfYesterday;
  function endOfYesterday() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date3 = new Date(0);
    date3.setFullYear(year, month, day - 1);
    date3.setHours(23, 59, 59, 999);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subMilliseconds/index.js
var require_subMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subMilliseconds;
  var _index = _interopRequireDefault(require_addMilliseconds());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subMilliseconds(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/getUTCDayOfYear/index.js
var require_getUTCDayOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUTCDayOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_DAY = 86400000;
  function getUTCDayOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var timestamp = date3.getTime();
    date3.setUTCMonth(0, 1);
    date3.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date3.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/startOfUTCISOWeek/index.js
var require_startOfUTCISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfUTCISOWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfUTCISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var weekStartsOn = 1;
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date3.setUTCDate(date3.getUTCDate() - diff);
    date3.setUTCHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/getUTCISOWeekYear/index.js
var require_getUTCISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUTCISOWeekYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_startOfUTCISOWeek());
  function getUTCISOWeekYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
    if (date3.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date3.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/startOfUTCISOWeekYear/index.js
var require_startOfUTCISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfUTCISOWeekYear;
  var _index = _interopRequireDefault(require_getUTCISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function startOfUTCISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date3 = (0, _index2.default)(fourthOfJanuary);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/getUTCISOWeek/index.js
var require_getUTCISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUTCISOWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
  var _index3 = _interopRequireDefault(require_startOfUTCISOWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getUTCISOWeek(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var diff = (0, _index2.default)(date3).getTime() - (0, _index3.default)(date3).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/startOfUTCWeek/index.js
var require_startOfUTCWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfUTCWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = require_defaultOptions();
  function startOfUTCWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(1, arguments);
    var defaultOptions = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date3.setUTCDate(date3.getUTCDate() - diff);
    date3.setUTCHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/getUTCWeekYear/index.js
var require_getUTCWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUTCWeekYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_startOfUTCWeek());
  var _index4 = _interopRequireDefault(require_toInteger());
  var _index5 = require_defaultOptions();
  function getUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getUTCFullYear();
    var defaultOptions = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
    if (date3.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date3.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/startOfUTCWeekYear/index.js
var require_startOfUTCWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfUTCWeekYear;
  var _index = _interopRequireDefault(require_getUTCWeekYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_startOfUTCWeek());
  var _index4 = _interopRequireDefault(require_toInteger());
  var _index5 = require_defaultOptions();
  function startOfUTCWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(1, arguments);
    var defaultOptions = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    var year = (0, _index.default)(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date3 = (0, _index3.default)(firstWeek, options);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/getUTCWeek/index.js
var require_getUTCWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUTCWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfUTCWeek());
  var _index3 = _interopRequireDefault(require_startOfUTCWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getUTCWeek(dirtyDate, options) {
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var diff = (0, _index2.default)(date3, options).getTime() - (0, _index3.default)(date3, options).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/addLeadingZeros/index.js
var require_addLeadingZeros = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = addLeadingZeros;
  function addLeadingZeros(number3, targetLength) {
    var sign = number3 < 0 ? "-" : "";
    var output = Math.abs(number3).toString();
    while (output.length < targetLength) {
      output = "0" + output;
    }
    return sign + output;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/format/lightFormatters/index.js
var require_lightFormatters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_addLeadingZeros());
  var formatters = {
    y: function y(date3, token) {
      var signedYear = date3.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return (0, _index.default)(token === "yy" ? year % 100 : year, token.length);
    },
    M: function M(date3, token) {
      var month = date3.getUTCMonth();
      return token === "M" ? String(month + 1) : (0, _index.default)(month + 1, 2);
    },
    d: function d(date3, token) {
      return (0, _index.default)(date3.getUTCDate(), token.length);
    },
    a: function a(date3, token) {
      var dayPeriodEnumValue = date3.getUTCHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    h: function h(date3, token) {
      return (0, _index.default)(date3.getUTCHours() % 12 || 12, token.length);
    },
    H: function H(date3, token) {
      return (0, _index.default)(date3.getUTCHours(), token.length);
    },
    m: function m(date3, token) {
      return (0, _index.default)(date3.getUTCMinutes(), token.length);
    },
    s: function s(date3, token) {
      return (0, _index.default)(date3.getUTCSeconds(), token.length);
    },
    S: function S(date3, token) {
      var numberOfDigits = token.length;
      var milliseconds = date3.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return (0, _index.default)(fractionalSeconds, token.length);
    }
  };
  var _default = formatters;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/format/formatters/index.js
var require_formatters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_getUTCDayOfYear());
  var _index2 = _interopRequireDefault(require_getUTCISOWeek());
  var _index3 = _interopRequireDefault(require_getUTCISOWeekYear());
  var _index4 = _interopRequireDefault(require_getUTCWeek());
  var _index5 = _interopRequireDefault(require_getUTCWeekYear());
  var _index6 = _interopRequireDefault(require_addLeadingZeros());
  var _index7 = _interopRequireDefault(require_lightFormatters());
  var dayPeriodEnum = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  var formatters = {
    G: function G(date3, token, localize) {
      var era = date3.getUTCFullYear() > 0 ? 1 : 0;
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return localize.era(era, {
            width: "abbreviated"
          });
        case "GGGGG":
          return localize.era(era, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return localize.era(era, {
            width: "wide"
          });
      }
    },
    y: function y(date3, token, localize) {
      if (token === "yo") {
        var signedYear = date3.getUTCFullYear();
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, {
          unit: "year"
        });
      }
      return _index7.default.y(date3, token);
    },
    Y: function Y(date3, token, localize, options) {
      var signedWeekYear = (0, _index5.default)(date3, options);
      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        var twoDigitYear = weekYear % 100;
        return (0, _index6.default)(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize.ordinalNumber(weekYear, {
          unit: "year"
        });
      }
      return (0, _index6.default)(weekYear, token.length);
    },
    R: function R(date3, token) {
      var isoWeekYear = (0, _index3.default)(date3);
      return (0, _index6.default)(isoWeekYear, token.length);
    },
    u: function u(date3, token) {
      var year = date3.getUTCFullYear();
      return (0, _index6.default)(year, token.length);
    },
    Q: function Q(date3, token, localize) {
      var quarter = Math.ceil((date3.getUTCMonth() + 1) / 3);
      switch (token) {
        case "Q":
          return String(quarter);
        case "QQ":
          return (0, _index6.default)(quarter, 2);
        case "Qo":
          return localize.ordinalNumber(quarter, {
            unit: "quarter"
          });
        case "QQQ":
          return localize.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return localize.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return localize.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    q: function q(date3, token, localize) {
      var quarter = Math.ceil((date3.getUTCMonth() + 1) / 3);
      switch (token) {
        case "q":
          return String(quarter);
        case "qq":
          return (0, _index6.default)(quarter, 2);
        case "qo":
          return localize.ordinalNumber(quarter, {
            unit: "quarter"
          });
        case "qqq":
          return localize.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return localize.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return localize.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    M: function M(date3, token, localize) {
      var month = date3.getUTCMonth();
      switch (token) {
        case "M":
        case "MM":
          return _index7.default.M(date3, token);
        case "Mo":
          return localize.ordinalNumber(month + 1, {
            unit: "month"
          });
        case "MMM":
          return localize.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return localize.month(month, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return localize.month(month, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    L: function L(date3, token, localize) {
      var month = date3.getUTCMonth();
      switch (token) {
        case "L":
          return String(month + 1);
        case "LL":
          return (0, _index6.default)(month + 1, 2);
        case "Lo":
          return localize.ordinalNumber(month + 1, {
            unit: "month"
          });
        case "LLL":
          return localize.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return localize.month(month, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return localize.month(month, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    w: function w(date3, token, localize, options) {
      var week = (0, _index4.default)(date3, options);
      if (token === "wo") {
        return localize.ordinalNumber(week, {
          unit: "week"
        });
      }
      return (0, _index6.default)(week, token.length);
    },
    I: function I(date3, token, localize) {
      var isoWeek = (0, _index2.default)(date3);
      if (token === "Io") {
        return localize.ordinalNumber(isoWeek, {
          unit: "week"
        });
      }
      return (0, _index6.default)(isoWeek, token.length);
    },
    d: function d(date3, token, localize) {
      if (token === "do") {
        return localize.ordinalNumber(date3.getUTCDate(), {
          unit: "date"
        });
      }
      return _index7.default.d(date3, token);
    },
    D: function D(date3, token, localize) {
      var dayOfYear = (0, _index.default)(date3);
      if (token === "Do") {
        return localize.ordinalNumber(dayOfYear, {
          unit: "dayOfYear"
        });
      }
      return (0, _index6.default)(dayOfYear, token.length);
    },
    E: function E(date3, token, localize) {
      var dayOfWeek = date3.getUTCDay();
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    e: function e(date3, token, localize, options) {
      var dayOfWeek = date3.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "e":
          return String(localDayOfWeek);
        case "ee":
          return (0, _index6.default)(localDayOfWeek, 2);
        case "eo":
          return localize.ordinalNumber(localDayOfWeek, {
            unit: "day"
          });
        case "eee":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    c: function c(date3, token, localize, options) {
      var dayOfWeek = date3.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        case "c":
          return String(localDayOfWeek);
        case "cc":
          return (0, _index6.default)(localDayOfWeek, token.length);
        case "co":
          return localize.ordinalNumber(localDayOfWeek, {
            unit: "day"
          });
        case "ccc":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    i: function i(date3, token, localize) {
      var dayOfWeek = date3.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        case "i":
          return String(isoDayOfWeek);
        case "ii":
          return (0, _index6.default)(isoDayOfWeek, token.length);
        case "io":
          return localize.ordinalNumber(isoDayOfWeek, {
            unit: "day"
          });
        case "iii":
          return localize.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return localize.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return localize.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return localize.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    a: function a(date3, token, localize) {
      var hours = date3.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    b: function b(date3, token, localize) {
      var hours = date3.getUTCHours();
      var dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    B: function B(date3, token, localize) {
      var hours = date3.getUTCHours();
      var dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    h: function h(date3, token, localize) {
      if (token === "ho") {
        var hours = date3.getUTCHours() % 12;
        if (hours === 0)
          hours = 12;
        return localize.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return _index7.default.h(date3, token);
    },
    H: function H(date3, token, localize) {
      if (token === "Ho") {
        return localize.ordinalNumber(date3.getUTCHours(), {
          unit: "hour"
        });
      }
      return _index7.default.H(date3, token);
    },
    K: function K(date3, token, localize) {
      var hours = date3.getUTCHours() % 12;
      if (token === "Ko") {
        return localize.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return (0, _index6.default)(hours, token.length);
    },
    k: function k(date3, token, localize) {
      var hours = date3.getUTCHours();
      if (hours === 0)
        hours = 24;
      if (token === "ko") {
        return localize.ordinalNumber(hours, {
          unit: "hour"
        });
      }
      return (0, _index6.default)(hours, token.length);
    },
    m: function m(date3, token, localize) {
      if (token === "mo") {
        return localize.ordinalNumber(date3.getUTCMinutes(), {
          unit: "minute"
        });
      }
      return _index7.default.m(date3, token);
    },
    s: function s(date3, token, localize) {
      if (token === "so") {
        return localize.ordinalNumber(date3.getUTCSeconds(), {
          unit: "second"
        });
      }
      return _index7.default.s(date3, token);
    },
    S: function S(date3, token) {
      return _index7.default.S(date3, token);
    },
    X: function X(date3, token, _localize, options) {
      var originalDate = options._originalDate || date3;
      var timezoneOffset = originalDate.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        case "XXXXX":
        case "XXX":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    x: function x(date3, token, _localize, options) {
      var originalDate = options._originalDate || date3;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        case "xxxxx":
        case "xxx":
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    O: function O(date3, token, _localize, options) {
      var originalDate = options._originalDate || date3;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    z: function z(date3, token, _localize, options) {
      var originalDate = options._originalDate || date3;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    t: function t(date3, token, _localize, options) {
      var originalDate = options._originalDate || date3;
      var timestamp = Math.floor(originalDate.getTime() / 1000);
      return (0, _index6.default)(timestamp, token.length);
    },
    T: function T(date3, token, _localize, options) {
      var originalDate = options._originalDate || date3;
      var timestamp = originalDate.getTime();
      return (0, _index6.default)(timestamp, token.length);
    }
  };
  function formatTimezoneShort(offset, dirtyDelimiter) {
    var sign = offset > 0 ? "-" : "+";
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    var delimiter = dirtyDelimiter || "";
    return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? "-" : "+";
      return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, dirtyDelimiter);
  }
  function formatTimezone(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || "";
    var sign = offset > 0 ? "-" : "+";
    var absOffset = Math.abs(offset);
    var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
    var minutes = (0, _index6.default)(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  var _default = formatters;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/format/longFormatters/index.js
var require_longFormatters = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var dateLongFormatter = function dateLongFormatter(pattern2, formatLong) {
    switch (pattern2) {
      case "P":
        return formatLong.date({
          width: "short"
        });
      case "PP":
        return formatLong.date({
          width: "medium"
        });
      case "PPP":
        return formatLong.date({
          width: "long"
        });
      case "PPPP":
      default:
        return formatLong.date({
          width: "full"
        });
    }
  };
  var timeLongFormatter = function timeLongFormatter(pattern2, formatLong) {
    switch (pattern2) {
      case "p":
        return formatLong.time({
          width: "short"
        });
      case "pp":
        return formatLong.time({
          width: "medium"
        });
      case "ppp":
        return formatLong.time({
          width: "long"
        });
      case "pppp":
      default:
        return formatLong.time({
          width: "full"
        });
    }
  };
  var dateTimeLongFormatter = function dateTimeLongFormatter(pattern2, formatLong) {
    var matchResult = pattern2.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern2, formatLong);
    }
    var dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong.dateTime({
          width: "short"
        });
        break;
      case "PP":
        dateTimeFormat = formatLong.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        dateTimeFormat = formatLong.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong.dateTime({
          width: "full"
        });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong)).replace("{{time}}", timeLongFormatter(timePattern, formatLong));
  };
  var longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var _default = longFormatters;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/protectedTokens/index.js
var require_protectedTokens = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
  exports.isProtectedWeekYearToken = isProtectedWeekYearToken;
  exports.throwProtectedError = throwProtectedError;
  var protectedDayOfYearTokens = ["D", "DD"];
  var protectedWeekYearTokens = ["YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }
  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }
  function throwProtectedError(token, format, input) {
    if (token === "YYYY") {
      throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "YY") {
      throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "D") {
      throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === "DD") {
      throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    }
  }
});

// node_modules/date-fns/locale/en-US/_lib/formatDistance/index.js
var require_formatDistance = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  var formatDistance = function formatDistance(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options !== null && options !== undefined && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result;
      } else {
        return result + " ago";
      }
    }
    return result;
  };
  var _default = formatDistance;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/locale/_lib/buildFormatLongFn/index.js
var require_buildFormatLongFn = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildFormatLongFn;
  function buildFormatLongFn(args) {
    return function() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }
  module.exports = exports.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatLong/index.js
var require_formatLong = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_buildFormatLongFn());
  var dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  var timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  var formatLong = {
    date: (0, _index.default)({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: (0, _index.default)({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: (0, _index.default)({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  var _default = formatLong;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/locale/en-US/_lib/formatRelative/index.js
var require_formatRelative = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  };
  var _default = formatRelative;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/locale/_lib/buildLocalizeFn/index.js
var require_buildLocalizeFn = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildLocalizeFn;
  function buildLocalizeFn(args) {
    return function(dirtyIndex, options) {
      var context = options !== null && options !== undefined && options.context ? String(options.context) : "standalone";
      var valuesArray;
      if (context === "formatting" && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options !== null && options !== undefined && options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options !== null && options !== undefined && options.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      return valuesArray[index];
    };
  }
  module.exports = exports.default;
});

// node_modules/date-fns/locale/en-US/_lib/localize/index.js
var require_localize = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_buildLocalizeFn());
  var eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  var quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  var monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  };
  var dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  };
  var dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
    var number3 = Number(dirtyNumber);
    var rem100 = number3 % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number3 + "st";
        case 2:
          return number3 + "nd";
        case 3:
          return number3 + "rd";
      }
    }
    return number3 + "th";
  };
  var localize = {
    ordinalNumber,
    era: (0, _index.default)({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: (0, _index.default)({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: function argumentCallback(quarter) {
        return quarter - 1;
      }
    }),
    month: (0, _index.default)({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: (0, _index.default)({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: (0, _index.default)({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  var _default = localize;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/locale/_lib/buildMatchFn/index.js
var require_buildMatchFn = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildMatchFn;
  function buildMatchFn(args) {
    return function(string3) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string3.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern2) {
        return pattern2.test(matchedString);
      }) : findKey(parsePatterns, function(pattern2) {
        return pattern2.test(matchedString);
      });
      var value2;
      value2 = args.valueCallback ? args.valueCallback(key) : key;
      value2 = options.valueCallback ? options.valueCallback(value2) : value2;
      var rest3 = string3.slice(matchedString.length);
      return {
        value: value2,
        rest: rest3
      };
    };
  }
  function findKey(object3, predicate) {
    for (var key in object3) {
      if (object3.hasOwnProperty(key) && predicate(object3[key])) {
        return key;
      }
    }
    return;
  }
  function findIndex(array3, predicate) {
    for (var key = 0;key < array3.length; key++) {
      if (predicate(array3[key])) {
        return key;
      }
    }
    return;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/locale/_lib/buildMatchPatternFn/index.js
var require_buildMatchPatternFn = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = buildMatchPatternFn;
  function buildMatchPatternFn(args) {
    return function(string3) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var matchResult = string3.match(args.matchPattern);
      if (!matchResult)
        return null;
      var matchedString = matchResult[0];
      var parseResult = string3.match(args.parsePattern);
      if (!parseResult)
        return null;
      var value2 = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value2 = options.valueCallback ? options.valueCallback(value2) : value2;
      var rest3 = string3.slice(matchedString.length);
      return {
        value: value2,
        rest: rest3
      };
    };
  }
  module.exports = exports.default;
});

// node_modules/date-fns/locale/en-US/_lib/match/index.js
var require_match = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_buildMatchFn());
  var _index2 = _interopRequireDefault(require_buildMatchPatternFn());
  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match = {
    ordinalNumber: (0, _index2.default)({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value2) {
        return parseInt(value2, 10);
      }
    }),
    era: (0, _index.default)({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: (0, _index.default)({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: function valueCallback(index) {
        return index + 1;
      }
    }),
    month: (0, _index.default)({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: (0, _index.default)({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: (0, _index.default)({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  var _default = match;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/locale/en-US/index.js
var require_en_US = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_formatDistance());
  var _index2 = _interopRequireDefault(require_formatLong());
  var _index3 = _interopRequireDefault(require_formatRelative());
  var _index4 = _interopRequireDefault(require_localize());
  var _index5 = _interopRequireDefault(require_match());
  var locale = {
    code: "en-US",
    formatDistance: _index.default,
    formatLong: _index2.default,
    formatRelative: _index3.default,
    localize: _index4.default,
    match: _index5.default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  var _default = locale;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/defaultLocale/index.js
var require_defaultLocale = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _index = _interopRequireDefault(require_en_US());
  var _default = _index.default;
  exports.default = _default;
  module.exports = exports.default;
});

// node_modules/date-fns/format/index.js
var require_format2 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = format;
  var _index = _interopRequireDefault(require_isValid());
  var _index2 = _interopRequireDefault(require_subMilliseconds());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_formatters());
  var _index5 = _interopRequireDefault(require_longFormatters());
  var _index6 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index7 = require_protectedTokens();
  var _index8 = _interopRequireDefault(require_toInteger());
  var _index9 = _interopRequireDefault(require_requiredArgs());
  var _index10 = require_defaultOptions();
  var _index11 = _interopRequireDefault(require_defaultLocale());
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(dirtyDate, dirtyFormatStr, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    (0, _index9.default)(2, arguments);
    var formatStr = String(dirtyFormatStr);
    var defaultOptions = (0, _index10.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions.locale) !== null && _ref !== undefined ? _ref : _index11.default;
    var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale2 = options.locale) === null || _options$locale2 === undefined ? undefined : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === undefined ? undefined : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== undefined ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale3 = options.locale) === null || _options$locale3 === undefined ? undefined : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === undefined ? undefined : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== undefined ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== undefined ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === undefined ? undefined : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === undefined ? undefined : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== undefined ? _ref5 : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (!locale.localize) {
      throw new RangeError("locale must contain localize property");
    }
    if (!locale.formatLong) {
      throw new RangeError("locale must contain formatLong property");
    }
    var originalDate = (0, _index3.default)(dirtyDate);
    if (!(0, _index.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var timezoneOffset = (0, _index6.default)(originalDate);
    var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        var longFormatter = _index5.default[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map(function(substring) {
      if (substring === "''") {
        return "'";
      }
      var firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }
      var formatter = _index4.default[firstCharacter];
      if (formatter) {
        if (!(options !== null && options !== undefined && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
          (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
        }
        if (!(options !== null && options !== undefined && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
          (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
        }
        return formatter(utcDate, substring, locale.localize, formatterOptions);
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      return substring;
    }).join("");
    return result;
  }
  function cleanEscapedString(input) {
    var matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/assign/index.js
var require_assign = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = assign;
  function assign(target, object3) {
    if (target == null) {
      throw new TypeError("assign requires that input parameter not be null or undefined");
    }
    for (var property in object3) {
      if (Object.prototype.hasOwnProperty.call(object3, property)) {
        target[property] = object3[property];
      }
    }
    return target;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/_lib/cloneObject/index.js
var require_cloneObject = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = cloneObject;
  var _index = _interopRequireDefault(require_assign());
  function cloneObject(object3) {
    return (0, _index.default)({}, object3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatDistance/index.js
var require_formatDistance2 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatDistance;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_compareAsc());
  var _index3 = _interopRequireDefault(require_differenceInMonths());
  var _index4 = _interopRequireDefault(require_differenceInSeconds());
  var _index5 = _interopRequireDefault(require_defaultLocale());
  var _index6 = _interopRequireDefault(require_toDate());
  var _index7 = _interopRequireDefault(require_cloneObject());
  var _index8 = _interopRequireDefault(require_assign());
  var _index9 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index10 = _interopRequireDefault(require_requiredArgs());
  var MINUTES_IN_DAY = 1440;
  var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
  var MINUTES_IN_MONTH = 43200;
  var MINUTES_IN_TWO_MONTHS = 86400;
  function formatDistance(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale;
    (0, _index10.default)(2, arguments);
    var defaultOptions = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions.locale) !== null && _ref !== undefined ? _ref : _index5.default;
    if (!locale.formatDistance) {
      throw new RangeError("locale must contain formatDistance property");
    }
    var comparison = (0, _index2.default)(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    var localizeOptions = (0, _index8.default)((0, _index7.default)(options), {
      addSuffix: Boolean(options === null || options === undefined ? undefined : options.addSuffix),
      comparison
    });
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = (0, _index6.default)(dirtyBaseDate);
      dateRight = (0, _index6.default)(dirtyDate);
    } else {
      dateLeft = (0, _index6.default)(dirtyDate);
      dateRight = (0, _index6.default)(dirtyBaseDate);
    }
    var seconds = (0, _index4.default)(dateRight, dateLeft);
    var offsetInSeconds = ((0, _index9.default)(dateRight) - (0, _index9.default)(dateLeft)) / 1000;
    var minutes = Math.round((seconds - offsetInSeconds) / 60);
    var months;
    if (minutes < 2) {
      if (options !== null && options !== undefined && options.includeSeconds) {
        if (seconds < 5) {
          return locale.formatDistance("lessThanXSeconds", 5, localizeOptions);
        } else if (seconds < 10) {
          return locale.formatDistance("lessThanXSeconds", 10, localizeOptions);
        } else if (seconds < 20) {
          return locale.formatDistance("lessThanXSeconds", 20, localizeOptions);
        } else if (seconds < 40) {
          return locale.formatDistance("halfAMinute", 0, localizeOptions);
        } else if (seconds < 60) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", 1, localizeOptions);
        }
      } else {
        if (minutes === 0) {
          return locale.formatDistance("lessThanXMinutes", 1, localizeOptions);
        } else {
          return locale.formatDistance("xMinutes", minutes, localizeOptions);
        }
      }
    } else if (minutes < 45) {
      return locale.formatDistance("xMinutes", minutes, localizeOptions);
    } else if (minutes < 90) {
      return locale.formatDistance("aboutXHours", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_DAY) {
      var hours = Math.round(minutes / 60);
      return locale.formatDistance("aboutXHours", hours, localizeOptions);
    } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
      return locale.formatDistance("xDays", 1, localizeOptions);
    } else if (minutes < MINUTES_IN_MONTH) {
      var days = Math.round(minutes / MINUTES_IN_DAY);
      return locale.formatDistance("xDays", days, localizeOptions);
    } else if (minutes < MINUTES_IN_TWO_MONTHS) {
      months = Math.round(minutes / MINUTES_IN_MONTH);
      return locale.formatDistance("aboutXMonths", months, localizeOptions);
    }
    months = (0, _index3.default)(dateRight, dateLeft);
    if (months < 12) {
      var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
      return locale.formatDistance("xMonths", nearestMonth, localizeOptions);
    } else {
      var monthsSinceStartOfYear = months % 12;
      var years = Math.floor(months / 12);
      if (monthsSinceStartOfYear < 3) {
        return locale.formatDistance("aboutXYears", years, localizeOptions);
      } else if (monthsSinceStartOfYear < 9) {
        return locale.formatDistance("overXYears", years, localizeOptions);
      } else {
        return locale.formatDistance("almostXYears", years + 1, localizeOptions);
      }
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatDistanceStrict/index.js
var require_formatDistanceStrict = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatDistanceStrict;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index3 = _interopRequireDefault(require_compareAsc());
  var _index4 = _interopRequireDefault(require_toDate());
  var _index5 = _interopRequireDefault(require_cloneObject());
  var _index6 = _interopRequireDefault(require_assign());
  var _index7 = _interopRequireDefault(require_defaultLocale());
  var _index8 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_MINUTE = 1000 * 60;
  var MINUTES_IN_DAY = 60 * 24;
  var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
  var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;
  function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale, _options$roundingMeth;
    (0, _index8.default)(2, arguments);
    var defaultOptions = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions.locale) !== null && _ref !== undefined ? _ref : _index7.default;
    if (!locale.formatDistance) {
      throw new RangeError("locale must contain localize.formatDistance property");
    }
    var comparison = (0, _index3.default)(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError("Invalid time value");
    }
    var localizeOptions = (0, _index6.default)((0, _index5.default)(options), {
      addSuffix: Boolean(options === null || options === undefined ? undefined : options.addSuffix),
      comparison
    });
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = (0, _index4.default)(dirtyBaseDate);
      dateRight = (0, _index4.default)(dirtyDate);
    } else {
      dateLeft = (0, _index4.default)(dirtyDate);
      dateRight = (0, _index4.default)(dirtyBaseDate);
    }
    var roundingMethod = String((_options$roundingMeth = options === null || options === undefined ? undefined : options.roundingMethod) !== null && _options$roundingMeth !== undefined ? _options$roundingMeth : "round");
    var roundingMethodFn;
    if (roundingMethod === "floor") {
      roundingMethodFn = Math.floor;
    } else if (roundingMethod === "ceil") {
      roundingMethodFn = Math.ceil;
    } else if (roundingMethod === "round") {
      roundingMethodFn = Math.round;
    } else {
      throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
    }
    var milliseconds = dateRight.getTime() - dateLeft.getTime();
    var minutes = milliseconds / MILLISECONDS_IN_MINUTE;
    var timezoneOffset = (0, _index2.default)(dateRight) - (0, _index2.default)(dateLeft);
    var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE;
    var defaultUnit = options === null || options === undefined ? undefined : options.unit;
    var unit;
    if (!defaultUnit) {
      if (minutes < 1) {
        unit = "second";
      } else if (minutes < 60) {
        unit = "minute";
      } else if (minutes < MINUTES_IN_DAY) {
        unit = "hour";
      } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
        unit = "day";
      } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
        unit = "month";
      } else {
        unit = "year";
      }
    } else {
      unit = String(defaultUnit);
    }
    if (unit === "second") {
      var seconds = roundingMethodFn(milliseconds / 1000);
      return locale.formatDistance("xSeconds", seconds, localizeOptions);
    } else if (unit === "minute") {
      var roundedMinutes = roundingMethodFn(minutes);
      return locale.formatDistance("xMinutes", roundedMinutes, localizeOptions);
    } else if (unit === "hour") {
      var hours = roundingMethodFn(minutes / 60);
      return locale.formatDistance("xHours", hours, localizeOptions);
    } else if (unit === "day") {
      var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
      return locale.formatDistance("xDays", days, localizeOptions);
    } else if (unit === "month") {
      var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
      return months === 12 && defaultUnit !== "month" ? locale.formatDistance("xYears", 1, localizeOptions) : locale.formatDistance("xMonths", months, localizeOptions);
    } else if (unit === "year") {
      var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
      return locale.formatDistance("xYears", years, localizeOptions);
    }
    throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatDistanceToNow/index.js
var require_formatDistanceToNow = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatDistanceToNow;
  var _index = _interopRequireDefault(require_formatDistance2());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function formatDistanceToNow(dirtyDate, options) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now(), options);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatDistanceToNowStrict/index.js
var require_formatDistanceToNowStrict = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatDistanceToNowStrict;
  var _index = _interopRequireDefault(require_formatDistanceStrict());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function formatDistanceToNowStrict(dirtyDate, options) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now(), options);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatDuration/index.js
var require_formatDuration = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatDuration;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_defaultLocale());
  var defaultFormat = ["years", "months", "weeks", "days", "hours", "minutes", "seconds"];
  function formatDuration(duration, options) {
    var _ref, _options$locale, _options$format, _options$zero, _options$delimiter;
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
    }
    var defaultOptions = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions.locale) !== null && _ref !== undefined ? _ref : _index2.default;
    var format = (_options$format = options === null || options === undefined ? undefined : options.format) !== null && _options$format !== undefined ? _options$format : defaultFormat;
    var zero = (_options$zero = options === null || options === undefined ? undefined : options.zero) !== null && _options$zero !== undefined ? _options$zero : false;
    var delimiter = (_options$delimiter = options === null || options === undefined ? undefined : options.delimiter) !== null && _options$delimiter !== undefined ? _options$delimiter : " ";
    if (!locale.formatDistance) {
      return "";
    }
    var result = format.reduce(function(acc, unit) {
      var token = "x".concat(unit.replace(/(^.)/, function(m) {
        return m.toUpperCase();
      }));
      var value2 = duration[unit];
      if (typeof value2 === "number" && (zero || duration[unit])) {
        return acc.concat(locale.formatDistance(token, value2));
      }
      return acc;
    }, []).join(delimiter);
    return result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatISO/index.js
var require_formatISO = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatISO;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_addLeadingZeros());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function formatISO(date3, options) {
    var _options$format, _options$representati;
    (0, _index3.default)(1, arguments);
    var originalDate = (0, _index.default)(date3);
    if (isNaN(originalDate.getTime())) {
      throw new RangeError("Invalid time value");
    }
    var format = String((_options$format = options === null || options === undefined ? undefined : options.format) !== null && _options$format !== undefined ? _options$format : "extended");
    var representation = String((_options$representati = options === null || options === undefined ? undefined : options.representation) !== null && _options$representati !== undefined ? _options$representati : "complete");
    if (format !== "extended" && format !== "basic") {
      throw new RangeError("format must be 'extended' or 'basic'");
    }
    if (representation !== "date" && representation !== "time" && representation !== "complete") {
      throw new RangeError("representation must be 'date', 'time', or 'complete'");
    }
    var result = "";
    var tzOffset = "";
    var dateDelimiter = format === "extended" ? "-" : "";
    var timeDelimiter = format === "extended" ? ":" : "";
    if (representation !== "time") {
      var day = (0, _index2.default)(originalDate.getDate(), 2);
      var month = (0, _index2.default)(originalDate.getMonth() + 1, 2);
      var year = (0, _index2.default)(originalDate.getFullYear(), 4);
      result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
    }
    if (representation !== "date") {
      var offset = originalDate.getTimezoneOffset();
      if (offset !== 0) {
        var absoluteOffset = Math.abs(offset);
        var hourOffset = (0, _index2.default)(Math.floor(absoluteOffset / 60), 2);
        var minuteOffset = (0, _index2.default)(absoluteOffset % 60, 2);
        var sign = offset < 0 ? "+" : "-";
        tzOffset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
      } else {
        tzOffset = "Z";
      }
      var hour = (0, _index2.default)(originalDate.getHours(), 2);
      var minute = (0, _index2.default)(originalDate.getMinutes(), 2);
      var second = (0, _index2.default)(originalDate.getSeconds(), 2);
      var separator = result === "" ? "" : "T";
      var time = [hour, minute, second].join(timeDelimiter);
      result = "".concat(result).concat(separator).concat(time).concat(tzOffset);
    }
    return result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatISO9075/index.js
var require_formatISO9075 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatISO9075;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_addLeadingZeros());
  function formatISO9075(dirtyDate, options) {
    var _options$format, _options$representati;
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only ".concat(arguments.length, " present"));
    }
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index2.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var format = String((_options$format = options === null || options === undefined ? undefined : options.format) !== null && _options$format !== undefined ? _options$format : "extended");
    var representation = String((_options$representati = options === null || options === undefined ? undefined : options.representation) !== null && _options$representati !== undefined ? _options$representati : "complete");
    if (format !== "extended" && format !== "basic") {
      throw new RangeError("format must be 'extended' or 'basic'");
    }
    if (representation !== "date" && representation !== "time" && representation !== "complete") {
      throw new RangeError("representation must be 'date', 'time', or 'complete'");
    }
    var result = "";
    var dateDelimiter = format === "extended" ? "-" : "";
    var timeDelimiter = format === "extended" ? ":" : "";
    if (representation !== "time") {
      var day = (0, _index3.default)(originalDate.getDate(), 2);
      var month = (0, _index3.default)(originalDate.getMonth() + 1, 2);
      var year = (0, _index3.default)(originalDate.getFullYear(), 4);
      result = "".concat(year).concat(dateDelimiter).concat(month).concat(dateDelimiter).concat(day);
    }
    if (representation !== "date") {
      var hour = (0, _index3.default)(originalDate.getHours(), 2);
      var minute = (0, _index3.default)(originalDate.getMinutes(), 2);
      var second = (0, _index3.default)(originalDate.getSeconds(), 2);
      var separator = result === "" ? "" : " ";
      result = "".concat(result).concat(separator).concat(hour).concat(timeDelimiter).concat(minute).concat(timeDelimiter).concat(second);
    }
    return result;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatISODuration/index.js
var require_formatISODuration = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatISODuration;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_requiredArgs());
  function formatISODuration(duration) {
    (0, _index.default)(1, arguments);
    if ((0, _typeof2.default)(duration) !== "object")
      throw new Error("Duration must be an object");
    var _duration$years = duration.years, years = _duration$years === undefined ? 0 : _duration$years, _duration$months = duration.months, months = _duration$months === undefined ? 0 : _duration$months, _duration$days = duration.days, days = _duration$days === undefined ? 0 : _duration$days, _duration$hours = duration.hours, hours = _duration$hours === undefined ? 0 : _duration$hours, _duration$minutes = duration.minutes, minutes = _duration$minutes === undefined ? 0 : _duration$minutes, _duration$seconds = duration.seconds, seconds = _duration$seconds === undefined ? 0 : _duration$seconds;
    return "P".concat(years, "Y").concat(months, "M").concat(days, "DT").concat(hours, "H").concat(minutes, "M").concat(seconds, "S");
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatRFC3339/index.js
var require_formatRFC3339 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatRFC3339;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_addLeadingZeros());
  var _index4 = _interopRequireDefault(require_toInteger());
  function formatRFC3339(dirtyDate, options) {
    var _options$fractionDigi;
    if (arguments.length < 1) {
      throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
    }
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index2.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var fractionDigits = Number((_options$fractionDigi = options === null || options === undefined ? undefined : options.fractionDigits) !== null && _options$fractionDigi !== undefined ? _options$fractionDigi : 0);
    if (!(fractionDigits >= 0 && fractionDigits <= 3)) {
      throw new RangeError("fractionDigits must be between 0 and 3 inclusively");
    }
    var day = (0, _index3.default)(originalDate.getDate(), 2);
    var month = (0, _index3.default)(originalDate.getMonth() + 1, 2);
    var year = originalDate.getFullYear();
    var hour = (0, _index3.default)(originalDate.getHours(), 2);
    var minute = (0, _index3.default)(originalDate.getMinutes(), 2);
    var second = (0, _index3.default)(originalDate.getSeconds(), 2);
    var fractionalSecond = "";
    if (fractionDigits > 0) {
      var milliseconds = originalDate.getMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, fractionDigits - 3));
      fractionalSecond = "." + (0, _index3.default)(fractionalSeconds, fractionDigits);
    }
    var offset = "";
    var tzOffset = originalDate.getTimezoneOffset();
    if (tzOffset !== 0) {
      var absoluteOffset = Math.abs(tzOffset);
      var hourOffset = (0, _index3.default)((0, _index4.default)(absoluteOffset / 60), 2);
      var minuteOffset = (0, _index3.default)(absoluteOffset % 60, 2);
      var sign = tzOffset < 0 ? "+" : "-";
      offset = "".concat(sign).concat(hourOffset, ":").concat(minuteOffset);
    } else {
      offset = "Z";
    }
    return "".concat(year, "-").concat(month, "-").concat(day, "T").concat(hour, ":").concat(minute, ":").concat(second).concat(fractionalSecond).concat(offset);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatRFC7231/index.js
var require_formatRFC7231 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatRFC7231;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_addLeadingZeros());
  var days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  var months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  function formatRFC7231(dirtyDate) {
    if (arguments.length < 1) {
      throw new TypeError("1 arguments required, but only ".concat(arguments.length, " present"));
    }
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index2.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var dayName = days[originalDate.getUTCDay()];
    var dayOfMonth = (0, _index3.default)(originalDate.getUTCDate(), 2);
    var monthName = months[originalDate.getUTCMonth()];
    var year = originalDate.getUTCFullYear();
    var hour = (0, _index3.default)(originalDate.getUTCHours(), 2);
    var minute = (0, _index3.default)(originalDate.getUTCMinutes(), 2);
    var second = (0, _index3.default)(originalDate.getUTCSeconds(), 2);
    return "".concat(dayName, ", ").concat(dayOfMonth, " ").concat(monthName, " ").concat(year, " ").concat(hour, ":").concat(minute, ":").concat(second, " GMT");
  }
  module.exports = exports.default;
});

// node_modules/date-fns/formatRelative/index.js
var require_formatRelative2 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = formatRelative;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_format2());
  var _index4 = _interopRequireDefault(require_defaultLocale());
  var _index5 = _interopRequireDefault(require_subMilliseconds());
  var _index6 = _interopRequireDefault(require_toDate());
  var _index7 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index8 = _interopRequireDefault(require_requiredArgs());
  var _index9 = _interopRequireDefault(require_toInteger());
  function formatRelative(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$weekStartsOn, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2;
    (0, _index8.default)(2, arguments);
    var date3 = (0, _index6.default)(dirtyDate);
    var baseDate = (0, _index6.default)(dirtyBaseDate);
    var defaultOptions = (0, _index.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions.locale) !== null && _ref !== undefined ? _ref : _index4.default;
    var weekStartsOn = (0, _index9.default)((_ref2 = (_ref3 = (_ref4 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale2 = options.locale) === null || _options$locale2 === undefined ? undefined : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === undefined ? undefined : _options$locale2$opti.weekStartsOn) !== null && _ref4 !== undefined ? _ref4 : defaultOptions.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : 0);
    if (!locale.localize) {
      throw new RangeError("locale must contain localize property");
    }
    if (!locale.formatLong) {
      throw new RangeError("locale must contain formatLong property");
    }
    if (!locale.formatRelative) {
      throw new RangeError("locale must contain formatRelative property");
    }
    var diff = (0, _index2.default)(date3, baseDate);
    if (isNaN(diff)) {
      throw new RangeError("Invalid time value");
    }
    var token;
    if (diff < -6) {
      token = "other";
    } else if (diff < -1) {
      token = "lastWeek";
    } else if (diff < 0) {
      token = "yesterday";
    } else if (diff < 1) {
      token = "today";
    } else if (diff < 2) {
      token = "tomorrow";
    } else if (diff < 7) {
      token = "nextWeek";
    } else {
      token = "other";
    }
    var utcDate = (0, _index5.default)(date3, (0, _index7.default)(date3));
    var utcBaseDate = (0, _index5.default)(baseDate, (0, _index7.default)(baseDate));
    var formatStr = locale.formatRelative(token, utcDate, utcBaseDate, {
      locale,
      weekStartsOn
    });
    return (0, _index3.default)(date3, formatStr, {
      locale,
      weekStartsOn
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/fromUnixTime/index.js
var require_fromUnixTime = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = fromUnixTime;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_toInteger());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function fromUnixTime(dirtyUnixTime) {
    (0, _index3.default)(1, arguments);
    var unixTime = (0, _index2.default)(dirtyUnixTime);
    return (0, _index.default)(unixTime * 1000);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDate/index.js
var require_getDate = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDate;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDate(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var dayOfMonth = date3.getDate();
    return dayOfMonth;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDay/index.js
var require_getDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getDay();
    return day;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDayOfYear/index.js
var require_getDayOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDayOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfYear());
  var _index3 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function getDayOfYear(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var diff = (0, _index3.default)(date3, (0, _index2.default)(date3));
    var dayOfYear = diff + 1;
    return dayOfYear;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDaysInMonth/index.js
var require_getDaysInMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDaysInMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDaysInMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    var monthIndex = date3.getMonth();
    var lastDayOfMonth = new Date(0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isLeapYear/index.js
var require_isLeapYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isLeapYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isLeapYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDaysInYear/index.js
var require_getDaysInYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDaysInYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_isLeapYear());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function getDaysInYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    if (String(new Date(date3)) === "Invalid Date") {
      return NaN;
    }
    return (0, _index2.default)(date3) ? 366 : 365;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDecade/index.js
var require_getDecade = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    var decade = Math.floor(year / 10) * 10;
    return decade;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getDefaultOptions/index.js
var require_getDefaultOptions = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getDefaultOptions;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_assign());
  function getDefaultOptions() {
    return (0, _index2.default)({}, (0, _index.getDefaultOptions)());
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getHours/index.js
var require_getHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getHours;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getHours(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var hours = date3.getHours();
    return hours;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getISODay/index.js
var require_getISODay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getISODay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getISODay(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getDay();
    if (day === 0) {
      day = 7;
    }
    return day;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getISOWeek/index.js
var require_getISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getISOWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_startOfISOWeekYear());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getISOWeek(dirtyDate) {
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var diff = (0, _index2.default)(date3).getTime() - (0, _index3.default)(date3).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getISOWeeksInYear/index.js
var require_getISOWeeksInYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getISOWeeksInYear;
  var _index = _interopRequireDefault(require_startOfISOWeekYear());
  var _index2 = _interopRequireDefault(require_addWeeks());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getISOWeeksInYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var thisYear = (0, _index.default)(dirtyDate);
    var nextYear = (0, _index.default)((0, _index2.default)(thisYear, 60));
    var diff = nextYear.valueOf() - thisYear.valueOf();
    return Math.round(diff / MILLISECONDS_IN_WEEK);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getMilliseconds/index.js
var require_getMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getMilliseconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getMilliseconds(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var milliseconds = date3.getMilliseconds();
    return milliseconds;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getMinutes/index.js
var require_getMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getMinutes;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getMinutes(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var minutes = date3.getMinutes();
    return minutes;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getMonth/index.js
var require_getMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var month = date3.getMonth();
    return month;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getOverlappingDaysInIntervals/index.js
var require_getOverlappingDaysInIntervals = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getOverlappingDaysInIntervals;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_DAY = 24 * 60 * 60 * 1000;
  function getOverlappingDaysInIntervals(dirtyIntervalLeft, dirtyIntervalRight) {
    (0, _index2.default)(2, arguments);
    var intervalLeft = dirtyIntervalLeft || {};
    var intervalRight = dirtyIntervalRight || {};
    var leftStartTime = (0, _index.default)(intervalLeft.start).getTime();
    var leftEndTime = (0, _index.default)(intervalLeft.end).getTime();
    var rightStartTime = (0, _index.default)(intervalRight.start).getTime();
    var rightEndTime = (0, _index.default)(intervalRight.end).getTime();
    if (!(leftStartTime <= leftEndTime && rightStartTime <= rightEndTime)) {
      throw new RangeError("Invalid interval");
    }
    var isOverlapping = leftStartTime < rightEndTime && rightStartTime < leftEndTime;
    if (!isOverlapping) {
      return 0;
    }
    var overlapStartDate = rightStartTime < leftStartTime ? leftStartTime : rightStartTime;
    var overlapEndDate = rightEndTime > leftEndTime ? leftEndTime : rightEndTime;
    var differenceInMs = overlapEndDate - overlapStartDate;
    return Math.ceil(differenceInMs / MILLISECONDS_IN_DAY);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getSeconds/index.js
var require_getSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getSeconds;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getSeconds(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var seconds = date3.getSeconds();
    return seconds;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getTime/index.js
var require_getTime = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getTime;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getTime(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var timestamp = date3.getTime();
    return timestamp;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getUnixTime/index.js
var require_getUnixTime = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getUnixTime;
  var _index = _interopRequireDefault(require_getTime());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getUnixTime(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return Math.floor((0, _index.default)(dirtyDate) / 1000);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getWeekYear/index.js
var require_getWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getWeekYear;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = require_defaultOptions();
  function getWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var year = date3.getFullYear();
    var defaultOptions = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    var startOfNextYear = (0, _index.default)(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    var startOfThisYear = (0, _index.default)(firstWeekOfThisYear, options);
    if (date3.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date3.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfWeekYear/index.js
var require_startOfWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfWeekYear;
  var _index = _interopRequireDefault(require_getWeekYear());
  var _index2 = _interopRequireDefault(require_startOfWeek());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = require_defaultOptions();
  function startOfWeekYear(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(1, arguments);
    var defaultOptions = (0, _index5.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    var year = (0, _index.default)(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    var date3 = (0, _index2.default)(firstWeek, options);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getWeek/index.js
var require_getWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getWeek;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_startOfWeekYear());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var MILLISECONDS_IN_WEEK = 604800000;
  function getWeek(dirtyDate, options) {
    (0, _index4.default)(1, arguments);
    var date3 = (0, _index3.default)(dirtyDate);
    var diff = (0, _index.default)(date3, options).getTime() - (0, _index2.default)(date3, options).getTime();
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getWeekOfMonth/index.js
var require_getWeekOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getWeekOfMonth;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_getDate());
  var _index3 = _interopRequireDefault(require_getDay());
  var _index4 = _interopRequireDefault(require_startOfMonth());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  var _index6 = _interopRequireDefault(require_toInteger());
  function getWeekOfMonth(date3, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index5.default)(1, arguments);
    var defaultOptions = (0, _index.getDefaultOptions)();
    var weekStartsOn = (0, _index6.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var currentDayOfMonth = (0, _index2.default)(date3);
    if (isNaN(currentDayOfMonth))
      return NaN;
    var startWeekDay = (0, _index3.default)((0, _index4.default)(date3));
    var lastDayOfFirstWeek = weekStartsOn - startWeekDay;
    if (lastDayOfFirstWeek <= 0)
      lastDayOfFirstWeek += 7;
    var remainingDaysAfterFirstWeek = currentDayOfMonth - lastDayOfFirstWeek;
    return Math.ceil(remainingDaysAfterFirstWeek / 7) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfMonth/index.js
var require_lastDayOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var month = date3.getMonth();
    date3.setFullYear(date3.getFullYear(), month + 1, 0);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getWeeksInMonth/index.js
var require_getWeeksInMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getWeeksInMonth;
  var _index = _interopRequireDefault(require_differenceInCalendarWeeks());
  var _index2 = _interopRequireDefault(require_lastDayOfMonth());
  var _index3 = _interopRequireDefault(require_startOfMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function getWeeksInMonth(date3, options) {
    (0, _index4.default)(1, arguments);
    return (0, _index.default)((0, _index2.default)(date3), (0, _index3.default)(date3), options) + 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/getYear/index.js
var require_getYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = getYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function getYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getFullYear();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/hoursToMilliseconds/index.js
var require_hoursToMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hoursToMilliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function hoursToMilliseconds(hours) {
    (0, _index.default)(1, arguments);
    return Math.floor(hours * _index2.millisecondsInHour);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/hoursToMinutes/index.js
var require_hoursToMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hoursToMinutes;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function hoursToMinutes(hours) {
    (0, _index.default)(1, arguments);
    return Math.floor(hours * _index2.minutesInHour);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/hoursToSeconds/index.js
var require_hoursToSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = hoursToSeconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function hoursToSeconds(hours) {
    (0, _index.default)(1, arguments);
    return Math.floor(hours * _index2.secondsInHour);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/intervalToDuration/index.js
var require_intervalToDuration = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = intervalToDuration;
  var _index = _interopRequireDefault(require_compareAsc());
  var _index2 = _interopRequireDefault(require_add());
  var _index3 = _interopRequireDefault(require_differenceInDays());
  var _index4 = _interopRequireDefault(require_differenceInHours());
  var _index5 = _interopRequireDefault(require_differenceInMinutes());
  var _index6 = _interopRequireDefault(require_differenceInMonths());
  var _index7 = _interopRequireDefault(require_differenceInSeconds());
  var _index8 = _interopRequireDefault(require_differenceInYears());
  var _index9 = _interopRequireDefault(require_toDate());
  var _index10 = _interopRequireDefault(require_requiredArgs());
  function intervalToDuration(interval) {
    (0, _index10.default)(1, arguments);
    var start = (0, _index9.default)(interval.start);
    var end = (0, _index9.default)(interval.end);
    if (isNaN(start.getTime()))
      throw new RangeError("Start Date is invalid");
    if (isNaN(end.getTime()))
      throw new RangeError("End Date is invalid");
    var duration = {};
    duration.years = Math.abs((0, _index8.default)(end, start));
    var sign = (0, _index.default)(end, start);
    var remainingMonths = (0, _index2.default)(start, {
      years: sign * duration.years
    });
    duration.months = Math.abs((0, _index6.default)(end, remainingMonths));
    var remainingDays = (0, _index2.default)(remainingMonths, {
      months: sign * duration.months
    });
    duration.days = Math.abs((0, _index3.default)(end, remainingDays));
    var remainingHours = (0, _index2.default)(remainingDays, {
      days: sign * duration.days
    });
    duration.hours = Math.abs((0, _index4.default)(end, remainingHours));
    var remainingMinutes = (0, _index2.default)(remainingHours, {
      hours: sign * duration.hours
    });
    duration.minutes = Math.abs((0, _index5.default)(end, remainingMinutes));
    var remainingSeconds = (0, _index2.default)(remainingMinutes, {
      minutes: sign * duration.minutes
    });
    duration.seconds = Math.abs((0, _index7.default)(end, remainingSeconds));
    return duration;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/intlFormat/index.js
var require_intlFormat = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = intlFormat;
  var _index = _interopRequireDefault(require_requiredArgs());
  function intlFormat(date3, formatOrLocale, localeOptions) {
    var _localeOptions;
    (0, _index.default)(1, arguments);
    var formatOptions;
    if (isFormatOptions(formatOrLocale)) {
      formatOptions = formatOrLocale;
    } else {
      localeOptions = formatOrLocale;
    }
    return new Intl.DateTimeFormat((_localeOptions = localeOptions) === null || _localeOptions === undefined ? undefined : _localeOptions.locale, formatOptions).format(date3);
  }
  function isFormatOptions(opts) {
    return opts !== undefined && !("locale" in opts);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/intlFormatDistance/index.js
var require_intlFormatDistance = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = intlFormatDistance;
  var _index = require_constants3();
  var _index2 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index3 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index4 = _interopRequireDefault(require_differenceInCalendarQuarters());
  var _index5 = _interopRequireDefault(require_differenceInCalendarWeeks());
  var _index6 = _interopRequireDefault(require_differenceInCalendarYears());
  var _index7 = _interopRequireDefault(require_differenceInHours());
  var _index8 = _interopRequireDefault(require_differenceInMinutes());
  var _index9 = _interopRequireDefault(require_differenceInSeconds());
  var _index10 = _interopRequireDefault(require_toDate());
  var _index11 = _interopRequireDefault(require_requiredArgs());
  function intlFormatDistance(date3, baseDate, options) {
    (0, _index11.default)(2, arguments);
    var value2 = 0;
    var unit;
    var dateLeft = (0, _index10.default)(date3);
    var dateRight = (0, _index10.default)(baseDate);
    if (!(options !== null && options !== undefined && options.unit)) {
      var diffInSeconds = (0, _index9.default)(dateLeft, dateRight);
      if (Math.abs(diffInSeconds) < _index.secondsInMinute) {
        value2 = (0, _index9.default)(dateLeft, dateRight);
        unit = "second";
      } else if (Math.abs(diffInSeconds) < _index.secondsInHour) {
        value2 = (0, _index8.default)(dateLeft, dateRight);
        unit = "minute";
      } else if (Math.abs(diffInSeconds) < _index.secondsInDay && Math.abs((0, _index2.default)(dateLeft, dateRight)) < 1) {
        value2 = (0, _index7.default)(dateLeft, dateRight);
        unit = "hour";
      } else if (Math.abs(diffInSeconds) < _index.secondsInWeek && (value2 = (0, _index2.default)(dateLeft, dateRight)) && Math.abs(value2) < 7) {
        unit = "day";
      } else if (Math.abs(diffInSeconds) < _index.secondsInMonth) {
        value2 = (0, _index5.default)(dateLeft, dateRight);
        unit = "week";
      } else if (Math.abs(diffInSeconds) < _index.secondsInQuarter) {
        value2 = (0, _index3.default)(dateLeft, dateRight);
        unit = "month";
      } else if (Math.abs(diffInSeconds) < _index.secondsInYear) {
        if ((0, _index4.default)(dateLeft, dateRight) < 4) {
          value2 = (0, _index4.default)(dateLeft, dateRight);
          unit = "quarter";
        } else {
          value2 = (0, _index6.default)(dateLeft, dateRight);
          unit = "year";
        }
      } else {
        value2 = (0, _index6.default)(dateLeft, dateRight);
        unit = "year";
      }
    } else {
      unit = options === null || options === undefined ? undefined : options.unit;
      if (unit === "second") {
        value2 = (0, _index9.default)(dateLeft, dateRight);
      } else if (unit === "minute") {
        value2 = (0, _index8.default)(dateLeft, dateRight);
      } else if (unit === "hour") {
        value2 = (0, _index7.default)(dateLeft, dateRight);
      } else if (unit === "day") {
        value2 = (0, _index2.default)(dateLeft, dateRight);
      } else if (unit === "week") {
        value2 = (0, _index5.default)(dateLeft, dateRight);
      } else if (unit === "month") {
        value2 = (0, _index3.default)(dateLeft, dateRight);
      } else if (unit === "quarter") {
        value2 = (0, _index4.default)(dateLeft, dateRight);
      } else if (unit === "year") {
        value2 = (0, _index6.default)(dateLeft, dateRight);
      }
    }
    var rtf = new Intl.RelativeTimeFormat(options === null || options === undefined ? undefined : options.locale, {
      localeMatcher: options === null || options === undefined ? undefined : options.localeMatcher,
      numeric: (options === null || options === undefined ? undefined : options.numeric) || "auto",
      style: options === null || options === undefined ? undefined : options.style
    });
    return rtf.format(value2, unit);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isAfter/index.js
var require_isAfter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isAfter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isAfter(dirtyDate, dirtyDateToCompare) {
    (0, _index2.default)(2, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    return date3.getTime() > dateToCompare.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isBefore/index.js
var require_isBefore = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isBefore;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isBefore(dirtyDate, dirtyDateToCompare) {
    (0, _index2.default)(2, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var dateToCompare = (0, _index.default)(dirtyDateToCompare);
    return date3.getTime() < dateToCompare.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isEqual/index.js
var require_isEqual = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isEqual;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isEqual(dirtyLeftDate, dirtyRightDate) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyLeftDate);
    var dateRight = (0, _index.default)(dirtyRightDate);
    return dateLeft.getTime() === dateRight.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isExists/index.js
var require_isExists = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isExists;
  function isExists(year, month, day) {
    if (arguments.length < 3) {
      throw new TypeError("3 argument required, but only " + arguments.length + " present");
    }
    var date3 = new Date(year, month, day);
    return date3.getFullYear() === year && date3.getMonth() === month && date3.getDate() === day;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isFirstDayOfMonth/index.js
var require_isFirstDayOfMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFirstDayOfMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isFirstDayOfMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDate() === 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isFriday/index.js
var require_isFriday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFriday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isFriday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 5;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isFuture/index.js
var require_isFuture = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isFuture;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isFuture(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getTime() > Date.now();
  }
  module.exports = exports.default;
});

// node_modules/@babel/runtime/helpers/arrayLikeToArray.js
var require_arrayLikeToArray = __commonJS((exports, module) => {
  function _arrayLikeToArray(r, a) {
    (a == null || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a);e < a; e++)
      n[e] = r[e];
    return n;
  }
  module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js
var require_unsupportedIterableToArray = __commonJS((exports, module) => {
  var arrayLikeToArray = require_arrayLikeToArray();
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if (typeof r == "string")
        return arrayLikeToArray(r, a);
      var t2 = {}.toString.call(r).slice(8, -1);
      return t2 === "Object" && r.constructor && (t2 = r.constructor.name), t2 === "Map" || t2 === "Set" ? Array.from(r) : t2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? arrayLikeToArray(r, a) : undefined;
    }
  }
  module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js
var require_createForOfIteratorHelper = __commonJS((exports, module) => {
  var unsupportedIterableToArray = require_unsupportedIterableToArray();
  function _createForOfIteratorHelper(r, e) {
    var t2 = typeof Symbol != "undefined" && r[Symbol.iterator] || r["@@iterator"];
    if (!t2) {
      if (Array.isArray(r) || (t2 = unsupportedIterableToArray(r)) || e && r && typeof r.length == "number") {
        t2 && (r = t2);
        var _n = 0, F = function F() {};
        return {
          s: F,
          n: function n() {
            return _n >= r.length ? {
              done: true
            } : {
              done: false,
              value: r[_n++]
            };
          },
          e: function e(r2) {
            throw r2;
          },
          f: F
        };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var o, a = true, u = false;
    return {
      s: function s() {
        t2 = t2.call(r);
      },
      n: function n() {
        var r2 = t2.next();
        return a = r2.done, r2;
      },
      e: function e(r2) {
        u = true, o = r2;
      },
      f: function f() {
        try {
          a || t2["return"] == null || t2["return"]();
        } finally {
          if (u)
            throw o;
        }
      }
    };
  }
  module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/assertThisInitialized.js
var require_assertThisInitialized = __commonJS((exports, module) => {
  function _assertThisInitialized(e) {
    if (e === undefined)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/setPrototypeOf.js
var require_setPrototypeOf = __commonJS((exports, module) => {
  function _setPrototypeOf(t2, e) {
    return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e2) {
      return t3.__proto__ = e2, t3;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t2, e);
  }
  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/inherits.js
var require_inherits = __commonJS((exports, module) => {
  var setPrototypeOf = require_setPrototypeOf();
  function _inherits(t2, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError("Super expression must either be null or a function");
    t2.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t2,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t2, "prototype", {
      writable: false
    }), e && setPrototypeOf(t2, e);
  }
  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/getPrototypeOf.js
var require_getPrototypeOf = __commonJS((exports, module) => {
  function _getPrototypeOf(t2) {
    return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
      return t3.__proto__ || Object.getPrototypeOf(t3);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t2);
  }
  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js
var require_isNativeReflectConstruct = __commonJS((exports, module) => {
  function _isNativeReflectConstruct() {
    try {
      var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
    } catch (t3) {}
    return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t2;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
  }
  module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/possibleConstructorReturn.js
var require_possibleConstructorReturn = __commonJS((exports, module) => {
  var _typeof = require_typeof()["default"];
  var assertThisInitialized = require_assertThisInitialized();
  function _possibleConstructorReturn(t2, e) {
    if (e && (_typeof(e) == "object" || typeof e == "function"))
      return e;
    if (e !== undefined)
      throw new TypeError("Derived constructors may only return object or undefined");
    return assertThisInitialized(t2);
  }
  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/createSuper.js
var require_createSuper = __commonJS((exports, module) => {
  var getPrototypeOf = require_getPrototypeOf();
  var isNativeReflectConstruct = require_isNativeReflectConstruct();
  var possibleConstructorReturn = require_possibleConstructorReturn();
  function _createSuper(t2) {
    var r = isNativeReflectConstruct();
    return function() {
      var e, o = getPrototypeOf(t2);
      if (r) {
        var s = getPrototypeOf(this).constructor;
        e = Reflect.construct(o, arguments, s);
      } else
        e = o.apply(this, arguments);
      return possibleConstructorReturn(this, e);
    };
  }
  module.exports = _createSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/classCallCheck.js
var require_classCallCheck = __commonJS((exports, module) => {
  function _classCallCheck(a, n) {
    if (!(a instanceof n))
      throw new TypeError("Cannot call a class as a function");
  }
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/toPrimitive.js
var require_toPrimitive = __commonJS((exports, module) => {
  var _typeof = require_typeof()["default"];
  function toPrimitive(t2, r) {
    if (_typeof(t2) != "object" || !t2)
      return t2;
    var e = t2[Symbol.toPrimitive];
    if (e !== undefined) {
      var i = e.call(t2, r || "default");
      if (_typeof(i) != "object")
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (r === "string" ? String : Number)(t2);
  }
  module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/toPropertyKey.js
var require_toPropertyKey = __commonJS((exports, module) => {
  var _typeof = require_typeof()["default"];
  var toPrimitive = require_toPrimitive();
  function toPropertyKey(t2) {
    var i = toPrimitive(t2, "string");
    return _typeof(i) == "symbol" ? i : i + "";
  }
  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/createClass.js
var require_createClass = __commonJS((exports, module) => {
  var toPropertyKey = require_toPropertyKey();
  function _defineProperties(e, r) {
    for (var t2 = 0;t2 < r.length; t2++) {
      var o = r[t2];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
    }
  }
  function _createClass(e, r, t2) {
    return r && _defineProperties(e.prototype, r), t2 && _defineProperties(e, t2), Object.defineProperty(e, "prototype", {
      writable: false
    }), e;
  }
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS((exports, module) => {
  var toPropertyKey = require_toPropertyKey();
  function _defineProperty(e, r, t2) {
    return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e[r] = t2, e;
  }
  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
});

// node_modules/date-fns/parse/_lib/Setter.js
var require_Setter = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ValueSetter = exports.Setter = exports.DateToSystemTimezoneSetter = undefined;
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var TIMEZONE_UNIT_PRIORITY = 10;
  var Setter = /* @__PURE__ */ function() {
    function Setter2() {
      (0, _classCallCheck2.default)(this, Setter2);
      (0, _defineProperty2.default)(this, "priority", undefined);
      (0, _defineProperty2.default)(this, "subPriority", 0);
    }
    (0, _createClass2.default)(Setter2, [{
      key: "validate",
      value: function validate(_utcDate, _options) {
        return true;
      }
    }]);
    return Setter2;
  }();
  exports.Setter = Setter;
  var ValueSetter = /* @__PURE__ */ function(_Setter) {
    (0, _inherits2.default)(ValueSetter2, _Setter);
    var _super = (0, _createSuper2.default)(ValueSetter2);
    function ValueSetter2(value2, validateValue, setValue, priority, subPriority) {
      var _this;
      (0, _classCallCheck2.default)(this, ValueSetter2);
      _this = _super.call(this);
      _this.value = value2;
      _this.validateValue = validateValue;
      _this.setValue = setValue;
      _this.priority = priority;
      if (subPriority) {
        _this.subPriority = subPriority;
      }
      return _this;
    }
    (0, _createClass2.default)(ValueSetter2, [{
      key: "validate",
      value: function validate(utcDate, options) {
        return this.validateValue(utcDate, this.value, options);
      }
    }, {
      key: "set",
      value: function set(utcDate, flags, options) {
        return this.setValue(utcDate, flags, this.value, options);
      }
    }]);
    return ValueSetter2;
  }(Setter);
  exports.ValueSetter = ValueSetter;
  var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
    (0, _inherits2.default)(DateToSystemTimezoneSetter2, _Setter2);
    var _super2 = (0, _createSuper2.default)(DateToSystemTimezoneSetter2);
    function DateToSystemTimezoneSetter2() {
      var _this2;
      (0, _classCallCheck2.default)(this, DateToSystemTimezoneSetter2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _super2.call.apply(_super2, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "subPriority", -1);
      return _this2;
    }
    (0, _createClass2.default)(DateToSystemTimezoneSetter2, [{
      key: "set",
      value: function set(date3, flags) {
        if (flags.timestampIsSet) {
          return date3;
        }
        var convertedDate = new Date(0);
        convertedDate.setFullYear(date3.getUTCFullYear(), date3.getUTCMonth(), date3.getUTCDate());
        convertedDate.setHours(date3.getUTCHours(), date3.getUTCMinutes(), date3.getUTCSeconds(), date3.getUTCMilliseconds());
        return convertedDate;
      }
    }]);
    return DateToSystemTimezoneSetter2;
  }(Setter);
  exports.DateToSystemTimezoneSetter = DateToSystemTimezoneSetter;
});

// node_modules/date-fns/parse/_lib/Parser.js
var require_Parser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Setter = require_Setter();
  var Parser = /* @__PURE__ */ function() {
    function Parser2() {
      (0, _classCallCheck2.default)(this, Parser2);
      (0, _defineProperty2.default)(this, "incompatibleTokens", undefined);
      (0, _defineProperty2.default)(this, "priority", undefined);
      (0, _defineProperty2.default)(this, "subPriority", undefined);
    }
    (0, _createClass2.default)(Parser2, [{
      key: "run",
      value: function run(dateString, token, match, options) {
        var result = this.parse(dateString, token, match, options);
        if (!result) {
          return null;
        }
        return {
          setter: new _Setter.ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
          rest: result.rest
        };
      }
    }, {
      key: "validate",
      value: function validate(_utcDate, _value, _options) {
        return true;
      }
    }]);
    return Parser2;
  }();
  exports.Parser = Parser;
});

// node_modules/date-fns/parse/_lib/parsers/EraParser.js
var require_EraParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.EraParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var EraParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(EraParser2, _Parser);
    var _super = (0, _createSuper2.default)(EraParser2);
    function EraParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, EraParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 140);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(EraParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "G":
          case "GG":
          case "GGG":
            return match.era(dateString, {
              width: "abbreviated"
            }) || match.era(dateString, {
              width: "narrow"
            });
          case "GGGGG":
            return match.era(dateString, {
              width: "narrow"
            });
          case "GGGG":
          default:
            return match.era(dateString, {
              width: "wide"
            }) || match.era(dateString, {
              width: "abbreviated"
            }) || match.era(dateString, {
              width: "narrow"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date3, flags, value2) {
        flags.era = value2;
        date3.setUTCFullYear(value2, 0, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return EraParser2;
  }(_Parser2.Parser);
  exports.EraParser = EraParser;
});

// node_modules/date-fns/parse/_lib/constants.js
var require_constants4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.timezonePatterns = exports.numericPatterns = undefined;
  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    date: /^(3[0-1]|[0-2]?\d)/,
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    week: /^(5[0-3]|[0-4]?\d)/,
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    hour11h: /^(1[0-1]|0?\d)/,
    hour12h: /^(1[0-2]|0?\d)/,
    minute: /^[0-5]?\d/,
    second: /^[0-5]?\d/,
    singleDigit: /^\d/,
    twoDigits: /^\d{1,2}/,
    threeDigits: /^\d{1,3}/,
    fourDigits: /^\d{1,4}/,
    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    twoDigitsSigned: /^-?\d{1,2}/,
    threeDigitsSigned: /^-?\d{1,3}/,
    fourDigitsSigned: /^-?\d{1,4}/
  };
  exports.numericPatterns = numericPatterns;
  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };
  exports.timezonePatterns = timezonePatterns;
});

// node_modules/date-fns/parse/_lib/utils.js
var require_utils6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.dayPeriodEnumToHours = dayPeriodEnumToHours;
  exports.isLeapYearIndex = isLeapYearIndex;
  exports.mapValue = mapValue;
  exports.normalizeTwoDigitYear = normalizeTwoDigitYear;
  exports.parseAnyDigitsSigned = parseAnyDigitsSigned;
  exports.parseNDigits = parseNDigits;
  exports.parseNDigitsSigned = parseNDigitsSigned;
  exports.parseNumericPattern = parseNumericPattern;
  exports.parseTimezonePattern = parseTimezonePattern;
  var _index = require_constants3();
  var _constants = require_constants4();
  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }
    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest
    };
  }
  function parseNumericPattern(pattern2, dateString) {
    var matchResult = dateString.match(pattern2);
    if (!matchResult) {
      return null;
    }
    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern2, dateString) {
    var matchResult = dateString.match(pattern2);
    if (!matchResult) {
      return null;
    }
    if (matchResult[0] === "Z") {
      return {
        value: 0,
        rest: dateString.slice(1)
      };
    }
    var sign = matchResult[1] === "+" ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * _index.millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(_constants.numericPatterns.anyDigitsSigned, dateString);
  }
  function parseNDigits(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(_constants.numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(_constants.numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(_constants.numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(_constants.numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
    }
  }
  function parseNDigitsSigned(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(_constants.numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(_constants.numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(_constants.numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(_constants.numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
    }
  }
  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case "morning":
        return 4;
      case "evening":
        return 17;
      case "pm":
      case "noon":
      case "afternoon":
        return 12;
      case "am":
      case "midnight":
      case "night":
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0;
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
});

// node_modules/date-fns/parse/_lib/parsers/YearParser.js
var require_YearParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.YearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var YearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(YearParser2, _Parser);
    var _super = (0, _createSuper2.default)(YearParser2);
    function YearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, YearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(YearParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(year) {
          return {
            year,
            isTwoDigitYear: token === "yy"
          };
        };
        switch (token) {
          case "y":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
          case "yo":
            return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
              unit: "year"
            }), valueCallback);
          default:
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2.isTwoDigitYear || value2.year > 0;
      }
    }, {
      key: "set",
      value: function set(date3, flags, value2) {
        var currentYear = date3.getUTCFullYear();
        if (value2.isTwoDigitYear) {
          var normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value2.year, currentYear);
          date3.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date3.setUTCHours(0, 0, 0, 0);
          return date3;
        }
        var year = !("era" in flags) || flags.era === 1 ? value2.year : 1 - value2.year;
        date3.setUTCFullYear(year, 0, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return YearParser2;
  }(_Parser2.Parser);
  exports.YearParser = YearParser;
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekYearParser.js
var require_LocalWeekYearParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LocalWeekYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_getUTCWeekYear());
  var _index2 = _interopRequireDefault(require_startOfUTCWeek());
  var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(LocalWeekYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(LocalWeekYearParser2);
    function LocalWeekYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, LocalWeekYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(LocalWeekYearParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(year) {
          return {
            year,
            isTwoDigitYear: token === "YY"
          };
        };
        switch (token) {
          case "Y":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(4, dateString), valueCallback);
          case "Yo":
            return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
              unit: "year"
            }), valueCallback);
          default:
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2.isTwoDigitYear || value2.year > 0;
      }
    }, {
      key: "set",
      value: function set(date3, flags, value2, options) {
        var currentYear = (0, _index.default)(date3, options);
        if (value2.isTwoDigitYear) {
          var normalizedTwoDigitYear = (0, _utils.normalizeTwoDigitYear)(value2.year, currentYear);
          date3.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date3.setUTCHours(0, 0, 0, 0);
          return (0, _index2.default)(date3, options);
        }
        var year = !("era" in flags) || flags.era === 1 ? value2.year : 1 - value2.year;
        date3.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date3.setUTCHours(0, 0, 0, 0);
        return (0, _index2.default)(date3, options);
      }
    }]);
    return LocalWeekYearParser2;
  }(_Parser2.Parser);
  exports.LocalWeekYearParser = LocalWeekYearParser;
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekYearParser.js
var require_ISOWeekYearParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ISOWeekYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_startOfUTCISOWeek());
  var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOWeekYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOWeekYearParser2);
    function ISOWeekYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOWeekYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ISOWeekYearParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        if (token === "R") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value2) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value2, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return (0, _index.default)(firstWeekOfYear);
      }
    }]);
    return ISOWeekYearParser2;
  }(_Parser2.Parser);
  exports.ISOWeekYearParser = ISOWeekYearParser;
});

// node_modules/date-fns/parse/_lib/parsers/ExtendedYearParser.js
var require_ExtendedYearParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ExtendedYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ExtendedYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(ExtendedYearParser2);
    function ExtendedYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ExtendedYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 130);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ExtendedYearParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        if (token === "u") {
          return (0, _utils.parseNDigitsSigned)(4, dateString);
        }
        return (0, _utils.parseNDigitsSigned)(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCFullYear(value2, 0, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return ExtendedYearParser2;
  }(_Parser2.Parser);
  exports.ExtendedYearParser = ExtendedYearParser;
});

// node_modules/date-fns/parse/_lib/parsers/QuarterParser.js
var require_QuarterParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.QuarterParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var QuarterParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(QuarterParser2, _Parser);
    var _super = (0, _createSuper2.default)(QuarterParser2);
    function QuarterParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, QuarterParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 120);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(QuarterParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "Q":
          case "QQ":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "Qo":
            return match.ordinalNumber(dateString, {
              unit: "quarter"
            });
          case "QQQ":
            return match.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQQ":
            return match.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "QQQQ":
          default:
            return match.quarter(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.quarter(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 4;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMonth((value2 - 1) * 3, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return QuarterParser2;
  }(_Parser2.Parser);
  exports.QuarterParser = QuarterParser;
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneQuarterParser.js
var require_StandAloneQuarterParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StandAloneQuarterParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(StandAloneQuarterParser2, _Parser);
    var _super = (0, _createSuper2.default)(StandAloneQuarterParser2);
    function StandAloneQuarterParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, StandAloneQuarterParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 120);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(StandAloneQuarterParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "q":
          case "qq":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "qo":
            return match.ordinalNumber(dateString, {
              unit: "quarter"
            });
          case "qqq":
            return match.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqqq":
            return match.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "qqqq":
          default:
            return match.quarter(dateString, {
              width: "wide",
              context: "standalone"
            }) || match.quarter(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.quarter(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 4;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMonth((value2 - 1) * 3, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return StandAloneQuarterParser2;
  }(_Parser2.Parser);
  exports.StandAloneQuarterParser = StandAloneQuarterParser;
});

// node_modules/date-fns/parse/_lib/parsers/MonthParser.js
var require_MonthParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MonthParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _utils = require_utils6();
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var MonthParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(MonthParser2, _Parser);
    var _super = (0, _createSuper2.default)(MonthParser2);
    function MonthParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, MonthParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 110);
      return _this;
    }
    (0, _createClass2.default)(MonthParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(value2) {
          return value2 - 1;
        };
        switch (token) {
          case "M":
            return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
          case "MM":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
          case "Mo":
            return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
              unit: "month"
            }), valueCallback);
          case "MMM":
            return match.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMMM":
            return match.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "MMMM":
          default:
            return match.month(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.month(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.month(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 11;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMonth(value2, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return MonthParser2;
  }(_Parser2.Parser);
  exports.MonthParser = MonthParser;
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneMonthParser.js
var require_StandAloneMonthParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StandAloneMonthParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(StandAloneMonthParser2, _Parser);
    var _super = (0, _createSuper2.default)(StandAloneMonthParser2);
    function StandAloneMonthParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, StandAloneMonthParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 110);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(StandAloneMonthParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(value2) {
          return value2 - 1;
        };
        switch (token) {
          case "L":
            return (0, _utils.mapValue)((0, _utils.parseNumericPattern)(_constants.numericPatterns.month, dateString), valueCallback);
          case "LL":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(2, dateString), valueCallback);
          case "Lo":
            return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
              unit: "month"
            }), valueCallback);
          case "LLL":
            return match.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLLL":
            return match.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "LLLL":
          default:
            return match.month(dateString, {
              width: "wide",
              context: "standalone"
            }) || match.month(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.month(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 11;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMonth(value2, 1);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return StandAloneMonthParser2;
  }(_Parser2.Parser);
  exports.StandAloneMonthParser = StandAloneMonthParser;
});

// node_modules/date-fns/_lib/setUTCWeek/index.js
var require_setUTCWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setUTCWeek;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getUTCWeek());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    (0, _index4.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var week = (0, _index.default)(dirtyWeek);
    var diff = (0, _index3.default)(date3, options) - week;
    date3.setUTCDate(date3.getUTCDate() - diff * 7);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/parse/_lib/parsers/LocalWeekParser.js
var require_LocalWeekParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LocalWeekParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_setUTCWeek());
  var _index2 = _interopRequireDefault(require_startOfUTCWeek());
  var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(LocalWeekParser2, _Parser);
    var _super = (0, _createSuper2.default)(LocalWeekParser2);
    function LocalWeekParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, LocalWeekParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 100);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(LocalWeekParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "w":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
          case "wo":
            return match.ordinalNumber(dateString, {
              unit: "week"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 53;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2, options) {
        return (0, _index2.default)((0, _index.default)(date3, value2, options), options);
      }
    }]);
    return LocalWeekParser2;
  }(_Parser2.Parser);
  exports.LocalWeekParser = LocalWeekParser;
});

// node_modules/date-fns/_lib/setUTCISOWeek/index.js
var require_setUTCISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setUTCISOWeek;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getUTCISOWeek());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    (0, _index4.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var isoWeek = (0, _index.default)(dirtyISOWeek);
    var diff = (0, _index3.default)(date3) - isoWeek;
    date3.setUTCDate(date3.getUTCDate() - diff * 7);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/parse/_lib/parsers/ISOWeekParser.js
var require_ISOWeekParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ISOWeekParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_setUTCISOWeek());
  var _index2 = _interopRequireDefault(require_startOfUTCISOWeek());
  var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOWeekParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOWeekParser2);
    function ISOWeekParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOWeekParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 100);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ISOWeekParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "I":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.week, dateString);
          case "Io":
            return match.ordinalNumber(dateString, {
              unit: "week"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 53;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        return (0, _index2.default)((0, _index.default)(date3, value2));
      }
    }]);
    return ISOWeekParser2;
  }(_Parser2.Parser);
  exports.ISOWeekParser = ISOWeekParser;
});

// node_modules/date-fns/parse/_lib/parsers/DateParser.js
var require_DateParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DateParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _utils = require_utils6();
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DateParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DateParser2, _Parser);
    var _super = (0, _createSuper2.default)(DateParser2);
    function DateParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DateParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subPriority", 1);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DateParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "d":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.date, dateString);
          case "do":
            return match.ordinalNumber(dateString, {
              unit: "date"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date3, value2) {
        var year = date3.getUTCFullYear();
        var isLeapYear = (0, _utils.isLeapYearIndex)(year);
        var month = date3.getUTCMonth();
        if (isLeapYear) {
          return value2 >= 1 && value2 <= DAYS_IN_MONTH_LEAP_YEAR[month];
        } else {
          return value2 >= 1 && value2 <= DAYS_IN_MONTH[month];
        }
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCDate(value2);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return DateParser2;
  }(_Parser2.Parser);
  exports.DateParser = DateParser;
});

// node_modules/date-fns/parse/_lib/parsers/DayOfYearParser.js
var require_DayOfYearParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DayOfYearParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DayOfYearParser2, _Parser);
    var _super = (0, _createSuper2.default)(DayOfYearParser2);
    function DayOfYearParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DayOfYearParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "subpriority", 1);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DayOfYearParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "D":
          case "DD":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.dayOfYear, dateString);
          case "Do":
            return match.ordinalNumber(dateString, {
              unit: "date"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date3, value2) {
        var year = date3.getUTCFullYear();
        var isLeapYear = (0, _utils.isLeapYearIndex)(year);
        if (isLeapYear) {
          return value2 >= 1 && value2 <= 366;
        } else {
          return value2 >= 1 && value2 <= 365;
        }
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMonth(0, value2);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return DayOfYearParser2;
  }(_Parser2.Parser);
  exports.DayOfYearParser = DayOfYearParser;
});

// node_modules/date-fns/_lib/setUTCDay/index.js
var require_setUTCDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setUTCDay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = require_defaultOptions();
  function setUTCDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index2.default)(2, arguments);
    var defaultOptions = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date3 = (0, _index.default)(dirtyDate);
    var day = (0, _index3.default)(dirtyDay);
    var currentDay = date3.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date3.setUTCDate(date3.getUTCDate() + diff);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/parse/_lib/parsers/DayParser.js
var require_DayParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _index = _interopRequireDefault(require_setUTCDay());
  var DayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DayParser2, _Parser);
    var _super = (0, _createSuper2.default)(DayParser2);
    function DayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "E":
          case "EE":
          case "EEE":
            return match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEE":
            return match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEEEE":
            return match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "EEEE":
          default:
            return match.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 6;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2, options) {
        date3 = (0, _index.default)(date3, value2, options);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return DayParser2;
  }(_Parser2.Parser);
  exports.DayParser = DayParser;
});

// node_modules/date-fns/parse/_lib/parsers/LocalDayParser.js
var require_LocalDayParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LocalDayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_setUTCDay());
  var LocalDayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(LocalDayParser2, _Parser);
    var _super = (0, _createSuper2.default)(LocalDayParser2);
    function LocalDayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, LocalDayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(LocalDayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match, options) {
        var valueCallback = function valueCallback(value2) {
          var wholeWeekDays = Math.floor((value2 - 1) / 7) * 7;
          return (value2 + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "e":
          case "ee":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
          case "eo":
            return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
              unit: "day"
            }), valueCallback);
          case "eee":
            return match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeee":
            return match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeeeee":
            return match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "eeee":
          default:
            return match.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 6;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2, options) {
        date3 = (0, _index.default)(date3, value2, options);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return LocalDayParser2;
  }(_Parser2.Parser);
  exports.LocalDayParser = LocalDayParser;
});

// node_modules/date-fns/parse/_lib/parsers/StandAloneLocalDayParser.js
var require_StandAloneLocalDayParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.StandAloneLocalDayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_setUTCDay());
  var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(StandAloneLocalDayParser2, _Parser);
    var _super = (0, _createSuper2.default)(StandAloneLocalDayParser2);
    function StandAloneLocalDayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, StandAloneLocalDayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(StandAloneLocalDayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match, options) {
        var valueCallback = function valueCallback(value2) {
          var wholeWeekDays = Math.floor((value2 - 1) / 7) * 7;
          return (value2 + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          case "c":
          case "cc":
            return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
          case "co":
            return (0, _utils.mapValue)(match.ordinalNumber(dateString, {
              unit: "day"
            }), valueCallback);
          case "ccc":
            return match.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "ccccc":
            return match.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccccc":
            return match.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
          case "cccc":
          default:
            return match.day(dateString, {
              width: "wide",
              context: "standalone"
            }) || match.day(dateString, {
              width: "abbreviated",
              context: "standalone"
            }) || match.day(dateString, {
              width: "short",
              context: "standalone"
            }) || match.day(dateString, {
              width: "narrow",
              context: "standalone"
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 6;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2, options) {
        date3 = (0, _index.default)(date3, value2, options);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return StandAloneLocalDayParser2;
  }(_Parser2.Parser);
  exports.StandAloneLocalDayParser = StandAloneLocalDayParser;
});

// node_modules/date-fns/_lib/setUTCISODay/index.js
var require_setUTCISODay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setUTCISODay;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function setUTCISODay(dirtyDate, dirtyDay) {
    (0, _index2.default)(2, arguments);
    var day = (0, _index3.default)(dirtyDay);
    if (day % 7 === 0) {
      day = day - 7;
    }
    var weekStartsOn = 1;
    var date3 = (0, _index.default)(dirtyDate);
    var currentDay = date3.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date3.setUTCDate(date3.getUTCDate() + diff);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/parse/_lib/parsers/ISODayParser.js
var require_ISODayParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ISODayParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var _index = _interopRequireDefault(require_setUTCISODay());
  var ISODayParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISODayParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISODayParser2);
    function ISODayParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISODayParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 90);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(ISODayParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(value2) {
          if (value2 === 0) {
            return 7;
          }
          return value2;
        };
        switch (token) {
          case "i":
          case "ii":
            return (0, _utils.parseNDigits)(token.length, dateString);
          case "io":
            return match.ordinalNumber(dateString, {
              unit: "day"
            });
          case "iii":
            return (0, _utils.mapValue)(match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
          case "iiiii":
            return (0, _utils.mapValue)(match.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
          case "iiiiii":
            return (0, _utils.mapValue)(match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
          case "iiii":
          default:
            return (0, _utils.mapValue)(match.day(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.day(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.day(dateString, {
              width: "short",
              context: "formatting"
            }) || match.day(dateString, {
              width: "narrow",
              context: "formatting"
            }), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 7;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3 = (0, _index.default)(date3, value2);
        date3.setUTCHours(0, 0, 0, 0);
        return date3;
      }
    }]);
    return ISODayParser2;
  }(_Parser2.Parser);
  exports.ISODayParser = ISODayParser;
});

// node_modules/date-fns/parse/_lib/parsers/AMPMParser.js
var require_AMPMParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AMPMParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var AMPMParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(AMPMParser2, _Parser);
    var _super = (0, _createSuper2.default)(AMPMParser2);
    function AMPMParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, AMPMParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(AMPMParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "a":
          case "aa":
          case "aaa":
            return match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaaa":
            return match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "aaaa":
          default:
            return match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCHours((0, _utils.dayPeriodEnumToHours)(value2), 0, 0, 0);
        return date3;
      }
    }]);
    return AMPMParser2;
  }(_Parser2.Parser);
  exports.AMPMParser = AMPMParser;
});

// node_modules/date-fns/parse/_lib/parsers/AMPMMidnightParser.js
var require_AMPMMidnightParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.AMPMMidnightParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(AMPMMidnightParser2, _Parser);
    var _super = (0, _createSuper2.default)(AMPMMidnightParser2);
    function AMPMMidnightParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, AMPMMidnightParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(AMPMMidnightParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "b":
          case "bb":
          case "bbb":
            return match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbbb":
            return match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "bbbb":
          default:
            return match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCHours((0, _utils.dayPeriodEnumToHours)(value2), 0, 0, 0);
        return date3;
      }
    }]);
    return AMPMMidnightParser2;
  }(_Parser2.Parser);
  exports.AMPMMidnightParser = AMPMMidnightParser;
});

// node_modules/date-fns/parse/_lib/parsers/DayPeriodParser.js
var require_DayPeriodParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DayPeriodParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(DayPeriodParser2, _Parser);
    var _super = (0, _createSuper2.default)(DayPeriodParser2);
    function DayPeriodParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, DayPeriodParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 80);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(DayPeriodParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "B":
          case "BB":
          case "BBB":
            return match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBBB":
            return match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
          case "BBBB":
          default:
            return match.dayPeriod(dateString, {
              width: "wide",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "abbreviated",
              context: "formatting"
            }) || match.dayPeriod(dateString, {
              width: "narrow",
              context: "formatting"
            });
        }
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCHours((0, _utils.dayPeriodEnumToHours)(value2), 0, 0, 0);
        return date3;
      }
    }]);
    return DayPeriodParser2;
  }(_Parser2.Parser);
  exports.DayPeriodParser = DayPeriodParser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour1to12Parser.js
var require_Hour1to12Parser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Hour1to12Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour1to12Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour1to12Parser2);
    function Hour1to12Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour1to12Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour1to12Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "h":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour12h, dateString);
          case "ho":
            return match.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 12;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        var isPM = date3.getUTCHours() >= 12;
        if (isPM && value2 < 12) {
          date3.setUTCHours(value2 + 12, 0, 0, 0);
        } else if (!isPM && value2 === 12) {
          date3.setUTCHours(0, 0, 0, 0);
        } else {
          date3.setUTCHours(value2, 0, 0, 0);
        }
        return date3;
      }
    }]);
    return Hour1to12Parser2;
  }(_Parser2.Parser);
  exports.Hour1to12Parser = Hour1to12Parser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour0to23Parser.js
var require_Hour0to23Parser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Hour0to23Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour0to23Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour0to23Parser2);
    function Hour0to23Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour0to23Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour0to23Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "H":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour23h, dateString);
          case "Ho":
            return match.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 23;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCHours(value2, 0, 0, 0);
        return date3;
      }
    }]);
    return Hour0to23Parser2;
  }(_Parser2.Parser);
  exports.Hour0to23Parser = Hour0to23Parser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour0To11Parser.js
var require_Hour0To11Parser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Hour0To11Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour0To11Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour0To11Parser2);
    function Hour0To11Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour0To11Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour0To11Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "K":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour11h, dateString);
          case "Ko":
            return match.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 11;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        var isPM = date3.getUTCHours() >= 12;
        if (isPM && value2 < 12) {
          date3.setUTCHours(value2 + 12, 0, 0, 0);
        } else {
          date3.setUTCHours(value2, 0, 0, 0);
        }
        return date3;
      }
    }]);
    return Hour0To11Parser2;
  }(_Parser2.Parser);
  exports.Hour0To11Parser = Hour0To11Parser;
});

// node_modules/date-fns/parse/_lib/parsers/Hour1To24Parser.js
var require_Hour1To24Parser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Hour1To24Parser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(Hour1To24Parser2, _Parser);
    var _super = (0, _createSuper2.default)(Hour1To24Parser2);
    function Hour1To24Parser2() {
      var _this;
      (0, _classCallCheck2.default)(this, Hour1To24Parser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 70);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(Hour1To24Parser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "k":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.hour24h, dateString);
          case "ko":
            return match.ordinalNumber(dateString, {
              unit: "hour"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 1 && value2 <= 24;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        var hours = value2 <= 24 ? value2 % 24 : value2;
        date3.setUTCHours(hours, 0, 0, 0);
        return date3;
      }
    }]);
    return Hour1To24Parser2;
  }(_Parser2.Parser);
  exports.Hour1To24Parser = Hour1To24Parser;
});

// node_modules/date-fns/parse/_lib/parsers/MinuteParser.js
var require_MinuteParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.MinuteParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var MinuteParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(MinuteParser2, _Parser);
    var _super = (0, _createSuper2.default)(MinuteParser2);
    function MinuteParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, MinuteParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 60);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(MinuteParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "m":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.minute, dateString);
          case "mo":
            return match.ordinalNumber(dateString, {
              unit: "minute"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 59;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMinutes(value2, 0, 0);
        return date3;
      }
    }]);
    return MinuteParser2;
  }(_Parser2.Parser);
  exports.MinuteParser = MinuteParser;
});

// node_modules/date-fns/parse/_lib/parsers/SecondParser.js
var require_SecondParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.SecondParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var SecondParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(SecondParser2, _Parser);
    var _super = (0, _createSuper2.default)(SecondParser2);
    function SecondParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, SecondParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 50);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(SecondParser2, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case "s":
            return (0, _utils.parseNumericPattern)(_constants.numericPatterns.second, dateString);
          case "so":
            return match.ordinalNumber(dateString, {
              unit: "second"
            });
          default:
            return (0, _utils.parseNDigits)(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value2) {
        return value2 >= 0 && value2 <= 59;
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCSeconds(value2, 0);
        return date3;
      }
    }]);
    return SecondParser2;
  }(_Parser2.Parser);
  exports.SecondParser = SecondParser;
});

// node_modules/date-fns/parse/_lib/parsers/FractionOfSecondParser.js
var require_FractionOfSecondParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.FractionOfSecondParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(FractionOfSecondParser2, _Parser);
    var _super = (0, _createSuper2.default)(FractionOfSecondParser2);
    function FractionOfSecondParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, FractionOfSecondParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 30);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T"]);
      return _this;
    }
    (0, _createClass2.default)(FractionOfSecondParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        var valueCallback = function valueCallback(value2) {
          return Math.floor(value2 * Math.pow(10, -token.length + 3));
        };
        return (0, _utils.mapValue)((0, _utils.parseNDigits)(token.length, dateString), valueCallback);
      }
    }, {
      key: "set",
      value: function set(date3, _flags, value2) {
        date3.setUTCMilliseconds(value2);
        return date3;
      }
    }]);
    return FractionOfSecondParser2;
  }(_Parser2.Parser);
  exports.FractionOfSecondParser = FractionOfSecondParser;
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneWithZParser.js
var require_ISOTimezoneWithZParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ISOTimezoneWithZParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOTimezoneWithZParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOTimezoneWithZParser2);
    function ISOTimezoneWithZParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOTimezoneWithZParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 10);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T", "x"]);
      return _this;
    }
    (0, _createClass2.default)(ISOTimezoneWithZParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        switch (token) {
          case "X":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
          case "XX":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
          case "XXXX":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
          case "XXXXX":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
          case "XXX":
          default:
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set(date3, flags, value2) {
        if (flags.timestampIsSet) {
          return date3;
        }
        return new Date(date3.getTime() - value2);
      }
    }]);
    return ISOTimezoneWithZParser2;
  }(_Parser2.Parser);
  exports.ISOTimezoneWithZParser = ISOTimezoneWithZParser;
});

// node_modules/date-fns/parse/_lib/parsers/ISOTimezoneParser.js
var require_ISOTimezoneParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ISOTimezoneParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _constants = require_constants4();
  var _utils = require_utils6();
  var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(ISOTimezoneParser2, _Parser);
    var _super = (0, _createSuper2.default)(ISOTimezoneParser2);
    function ISOTimezoneParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, ISOTimezoneParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 10);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", ["t", "T", "X"]);
      return _this;
    }
    (0, _createClass2.default)(ISOTimezoneParser2, [{
      key: "parse",
      value: function parse(dateString, token) {
        switch (token) {
          case "x":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalMinutes, dateString);
          case "xx":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basic, dateString);
          case "xxxx":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.basicOptionalSeconds, dateString);
          case "xxxxx":
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extendedOptionalSeconds, dateString);
          case "xxx":
          default:
            return (0, _utils.parseTimezonePattern)(_constants.timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set(date3, flags, value2) {
        if (flags.timestampIsSet) {
          return date3;
        }
        return new Date(date3.getTime() - value2);
      }
    }]);
    return ISOTimezoneParser2;
  }(_Parser2.Parser);
  exports.ISOTimezoneParser = ISOTimezoneParser;
});

// node_modules/date-fns/parse/_lib/parsers/TimestampSecondsParser.js
var require_TimestampSecondsParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TimestampSecondsParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(TimestampSecondsParser2, _Parser);
    var _super = (0, _createSuper2.default)(TimestampSecondsParser2);
    function TimestampSecondsParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, TimestampSecondsParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 40);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", "*");
      return _this;
    }
    (0, _createClass2.default)(TimestampSecondsParser2, [{
      key: "parse",
      value: function parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value2) {
        return [new Date(value2 * 1000), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampSecondsParser2;
  }(_Parser2.Parser);
  exports.TimestampSecondsParser = TimestampSecondsParser;
});

// node_modules/date-fns/parse/_lib/parsers/TimestampMillisecondsParser.js
var require_TimestampMillisecondsParser = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.TimestampMillisecondsParser = undefined;
  var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
  var _createClass2 = _interopRequireDefault(require_createClass());
  var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
  var _inherits2 = _interopRequireDefault(require_inherits());
  var _createSuper2 = _interopRequireDefault(require_createSuper());
  var _defineProperty2 = _interopRequireDefault(require_defineProperty());
  var _Parser2 = require_Parser();
  var _utils = require_utils6();
  var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
    (0, _inherits2.default)(TimestampMillisecondsParser2, _Parser);
    var _super = (0, _createSuper2.default)(TimestampMillisecondsParser2);
    function TimestampMillisecondsParser2() {
      var _this;
      (0, _classCallCheck2.default)(this, TimestampMillisecondsParser2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0;_key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "priority", 20);
      (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "incompatibleTokens", "*");
      return _this;
    }
    (0, _createClass2.default)(TimestampMillisecondsParser2, [{
      key: "parse",
      value: function parse(dateString) {
        return (0, _utils.parseAnyDigitsSigned)(dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value2) {
        return [new Date(value2), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampMillisecondsParser2;
  }(_Parser2.Parser);
  exports.TimestampMillisecondsParser = TimestampMillisecondsParser;
});

// node_modules/date-fns/parse/_lib/parsers/index.js
var require_parsers = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.parsers = undefined;
  var _EraParser = require_EraParser();
  var _YearParser = require_YearParser();
  var _LocalWeekYearParser = require_LocalWeekYearParser();
  var _ISOWeekYearParser = require_ISOWeekYearParser();
  var _ExtendedYearParser = require_ExtendedYearParser();
  var _QuarterParser = require_QuarterParser();
  var _StandAloneQuarterParser = require_StandAloneQuarterParser();
  var _MonthParser = require_MonthParser();
  var _StandAloneMonthParser = require_StandAloneMonthParser();
  var _LocalWeekParser = require_LocalWeekParser();
  var _ISOWeekParser = require_ISOWeekParser();
  var _DateParser = require_DateParser();
  var _DayOfYearParser = require_DayOfYearParser();
  var _DayParser = require_DayParser();
  var _LocalDayParser = require_LocalDayParser();
  var _StandAloneLocalDayParser = require_StandAloneLocalDayParser();
  var _ISODayParser = require_ISODayParser();
  var _AMPMParser = require_AMPMParser();
  var _AMPMMidnightParser = require_AMPMMidnightParser();
  var _DayPeriodParser = require_DayPeriodParser();
  var _Hour1to12Parser = require_Hour1to12Parser();
  var _Hour0to23Parser = require_Hour0to23Parser();
  var _Hour0To11Parser = require_Hour0To11Parser();
  var _Hour1To24Parser = require_Hour1To24Parser();
  var _MinuteParser = require_MinuteParser();
  var _SecondParser = require_SecondParser();
  var _FractionOfSecondParser = require_FractionOfSecondParser();
  var _ISOTimezoneWithZParser = require_ISOTimezoneWithZParser();
  var _ISOTimezoneParser = require_ISOTimezoneParser();
  var _TimestampSecondsParser = require_TimestampSecondsParser();
  var _TimestampMillisecondsParser = require_TimestampMillisecondsParser();
  var parsers = {
    G: new _EraParser.EraParser,
    y: new _YearParser.YearParser,
    Y: new _LocalWeekYearParser.LocalWeekYearParser,
    R: new _ISOWeekYearParser.ISOWeekYearParser,
    u: new _ExtendedYearParser.ExtendedYearParser,
    Q: new _QuarterParser.QuarterParser,
    q: new _StandAloneQuarterParser.StandAloneQuarterParser,
    M: new _MonthParser.MonthParser,
    L: new _StandAloneMonthParser.StandAloneMonthParser,
    w: new _LocalWeekParser.LocalWeekParser,
    I: new _ISOWeekParser.ISOWeekParser,
    d: new _DateParser.DateParser,
    D: new _DayOfYearParser.DayOfYearParser,
    E: new _DayParser.DayParser,
    e: new _LocalDayParser.LocalDayParser,
    c: new _StandAloneLocalDayParser.StandAloneLocalDayParser,
    i: new _ISODayParser.ISODayParser,
    a: new _AMPMParser.AMPMParser,
    b: new _AMPMMidnightParser.AMPMMidnightParser,
    B: new _DayPeriodParser.DayPeriodParser,
    h: new _Hour1to12Parser.Hour1to12Parser,
    H: new _Hour0to23Parser.Hour0to23Parser,
    K: new _Hour0To11Parser.Hour0To11Parser,
    k: new _Hour1To24Parser.Hour1To24Parser,
    m: new _MinuteParser.MinuteParser,
    s: new _SecondParser.SecondParser,
    S: new _FractionOfSecondParser.FractionOfSecondParser,
    X: new _ISOTimezoneWithZParser.ISOTimezoneWithZParser,
    x: new _ISOTimezoneParser.ISOTimezoneParser,
    t: new _TimestampSecondsParser.TimestampSecondsParser,
    T: new _TimestampMillisecondsParser.TimestampMillisecondsParser
  };
  exports.parsers = parsers;
});

// node_modules/date-fns/parse/index.js
var require_parse3 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parse3;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _createForOfIteratorHelper2 = _interopRequireDefault(require_createForOfIteratorHelper());
  var _index = _interopRequireDefault(require_defaultLocale());
  var _index2 = _interopRequireDefault(require_subMilliseconds());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_assign());
  var _index5 = _interopRequireDefault(require_longFormatters());
  var _index6 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index7 = require_protectedTokens();
  var _index8 = _interopRequireDefault(require_toInteger());
  var _index9 = _interopRequireDefault(require_requiredArgs());
  var _Setter = require_Setter();
  var _index10 = require_parsers();
  var _index11 = require_defaultOptions();
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function parse3(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    (0, _index9.default)(3, arguments);
    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var defaultOptions = (0, _index11.getDefaultOptions)();
    var locale = (_ref = (_options$locale = options === null || options === undefined ? undefined : options.locale) !== null && _options$locale !== undefined ? _options$locale : defaultOptions.locale) !== null && _ref !== undefined ? _ref : _index.default;
    if (!locale.match) {
      throw new RangeError("locale must contain match property");
    }
    var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale2 = options.locale) === null || _options$locale2 === undefined ? undefined : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === undefined ? undefined : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== undefined ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : 1);
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    }
    var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale3 = options.locale) === null || _options$locale3 === undefined ? undefined : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === undefined ? undefined : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== undefined ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== undefined ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === undefined ? undefined : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === undefined ? undefined : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== undefined ? _ref5 : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    if (formatString === "") {
      if (dateString === "") {
        return (0, _index3.default)(dirtyReferenceDate);
      } else {
        return new Date(NaN);
      }
    }
    var subFnOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    var setters = [new _Setter.DateToSystemTimezoneSetter];
    var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
      var firstCharacter = substring[0];
      if (firstCharacter in _index5.default) {
        var longFormatter = _index5.default[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp);
    var usedTokens = [];
    var _iterator = (0, _createForOfIteratorHelper2.default)(tokens), _step;
    try {
      var _loop = function _loop() {
        var token = _step.value;
        if (!(options !== null && options !== undefined && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(token)) {
          (0, _index7.throwProtectedError)(token, formatString, dirtyDateString);
        }
        if (!(options !== null && options !== undefined && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(token)) {
          (0, _index7.throwProtectedError)(token, formatString, dirtyDateString);
        }
        var firstCharacter = token[0];
        var parser = _index10.parsers[firstCharacter];
        if (parser) {
          var incompatibleTokens = parser.incompatibleTokens;
          if (Array.isArray(incompatibleTokens)) {
            var incompatibleToken = usedTokens.find(function(usedToken) {
              return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
            });
            if (incompatibleToken) {
              throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
            }
          } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
            throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
          }
          usedTokens.push({
            token: firstCharacter,
            fullToken: token
          });
          var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
          if (!parseResult) {
            return {
              v: new Date(NaN)
            };
          }
          setters.push(parseResult.setter);
          dateString = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
          }
          if (token === "''") {
            token = "'";
          } else if (firstCharacter === "'") {
            token = cleanEscapedString(token);
          }
          if (dateString.indexOf(token) === 0) {
            dateString = dateString.slice(token.length);
          } else {
            return {
              v: new Date(NaN)
            };
          }
        }
      };
      for (_iterator.s();!(_step = _iterator.n()).done; ) {
        var _ret = _loop();
        if ((0, _typeof2.default)(_ret) === "object")
          return _ret.v;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }
    var uniquePrioritySetters = setters.map(function(setter2) {
      return setter2.priority;
    }).sort(function(a, b) {
      return b - a;
    }).filter(function(priority, index, array3) {
      return array3.indexOf(priority) === index;
    }).map(function(priority) {
      return setters.filter(function(setter2) {
        return setter2.priority === priority;
      }).sort(function(a, b) {
        return b.subPriority - a.subPriority;
      });
    }).map(function(setterArray) {
      return setterArray[0];
    });
    var date3 = (0, _index3.default)(dirtyReferenceDate);
    if (isNaN(date3.getTime())) {
      return new Date(NaN);
    }
    var utcDate = (0, _index2.default)(date3, (0, _index6.default)(date3));
    var flags = {};
    var _iterator2 = (0, _createForOfIteratorHelper2.default)(uniquePrioritySetters), _step2;
    try {
      for (_iterator2.s();!(_step2 = _iterator2.n()).done; ) {
        var setter = _step2.value;
        if (!setter.validate(utcDate, subFnOptions)) {
          return new Date(NaN);
        }
        var result = setter.set(utcDate, flags, subFnOptions);
        if (Array.isArray(result)) {
          utcDate = result[0];
          (0, _index4.default)(flags, result[1]);
        } else {
          utcDate = result;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return utcDate;
  }
  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isMatch/index.js
var require_isMatch = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMatch;
  var _index = _interopRequireDefault(require_parse3());
  var _index2 = _interopRequireDefault(require_isValid());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isMatch(dateString, formatString, options) {
    (0, _index3.default)(2, arguments);
    return (0, _index2.default)((0, _index.default)(dateString, formatString, new Date, options));
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isMonday/index.js
var require_isMonday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isMonday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isMonday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3).getDay() === 1;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isPast/index.js
var require_isPast = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isPast;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isPast(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getTime() < Date.now();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfHour/index.js
var require_startOfHour = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfHour;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfHour(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setMinutes(0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameHour/index.js
var require_isSameHour = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameHour;
  var _index = _interopRequireDefault(require_startOfHour());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameHour(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfHour = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfHour = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfHour.getTime() === dateRightStartOfHour.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameWeek/index.js
var require_isSameWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameWeek;
  var _index = _interopRequireDefault(require_startOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameWeek(dirtyDateLeft, dirtyDateRight, options) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfWeek = (0, _index.default)(dirtyDateLeft, options);
    var dateRightStartOfWeek = (0, _index.default)(dirtyDateRight, options);
    return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameISOWeek/index.js
var require_isSameISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameISOWeek;
  var _index = _interopRequireDefault(require_isSameWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameISOWeek(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    return (0, _index.default)(dirtyDateLeft, dirtyDateRight, {
      weekStartsOn: 1
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameISOWeekYear/index.js
var require_isSameISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameISOWeekYear;
  var _index = _interopRequireDefault(require_startOfISOWeekYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameISOWeekYear(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfYear = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfYear = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfYear.getTime() === dateRightStartOfYear.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameMinute/index.js
var require_isSameMinute = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameMinute;
  var _index = _interopRequireDefault(require_startOfMinute());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameMinute(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfMinute = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfMinute = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfMinute.getTime() === dateRightStartOfMinute.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameMonth/index.js
var require_isSameMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameMonth;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameMonth(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameQuarter/index.js
var require_isSameQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameQuarter;
  var _index = _interopRequireDefault(require_startOfQuarter());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfQuarter = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfQuarter = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfSecond/index.js
var require_startOfSecond = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfSecond;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfSecond(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    date3.setMilliseconds(0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameSecond/index.js
var require_isSameSecond = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameSecond;
  var _index = _interopRequireDefault(require_startOfSecond());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameSecond(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeftStartOfSecond = (0, _index.default)(dirtyDateLeft);
    var dateRightStartOfSecond = (0, _index.default)(dirtyDateRight);
    return dateLeftStartOfSecond.getTime() === dateRightStartOfSecond.getTime();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isSameYear/index.js
var require_isSameYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isSameYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isSameYear(dirtyDateLeft, dirtyDateRight) {
    (0, _index2.default)(2, arguments);
    var dateLeft = (0, _index.default)(dirtyDateLeft);
    var dateRight = (0, _index.default)(dirtyDateRight);
    return dateLeft.getFullYear() === dateRight.getFullYear();
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisHour/index.js
var require_isThisHour = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisHour;
  var _index = _interopRequireDefault(require_isSameHour());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisHour(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisISOWeek/index.js
var require_isThisISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisISOWeek;
  var _index = _interopRequireDefault(require_isSameISOWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now());
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisMinute/index.js
var require_isThisMinute = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisMinute;
  var _index = _interopRequireDefault(require_isSameMinute());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisMinute(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisMonth/index.js
var require_isThisMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisMonth;
  var _index = _interopRequireDefault(require_isSameMonth());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisMonth(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisQuarter/index.js
var require_isThisQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisQuarter;
  var _index = _interopRequireDefault(require_isSameQuarter());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisSecond/index.js
var require_isThisSecond = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisSecond;
  var _index = _interopRequireDefault(require_isSameSecond());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisSecond(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(Date.now(), dirtyDate);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisWeek/index.js
var require_isThisWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisWeek;
  var _index = _interopRequireDefault(require_isSameWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisWeek(dirtyDate, options) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now(), options);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThisYear/index.js
var require_isThisYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThisYear;
  var _index = _interopRequireDefault(require_isSameYear());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThisYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now());
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isThursday/index.js
var require_isThursday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isThursday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isThursday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 4;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isToday/index.js
var require_isToday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isToday;
  var _index = _interopRequireDefault(require_isSameDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isToday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, Date.now());
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isTomorrow/index.js
var require_isTomorrow = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTomorrow;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_isSameDay());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isTomorrow(dirtyDate) {
    (0, _index3.default)(1, arguments);
    return (0, _index2.default)(dirtyDate, (0, _index.default)(Date.now(), 1));
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isTuesday/index.js
var require_isTuesday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isTuesday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isTuesday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 2;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isWednesday/index.js
var require_isWednesday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isWednesday;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isWednesday(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate).getDay() === 3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isWithinInterval/index.js
var require_isWithinInterval = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isWithinInterval;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function isWithinInterval(dirtyDate, interval) {
    (0, _index2.default)(2, arguments);
    var time = (0, _index.default)(dirtyDate).getTime();
    var startTime = (0, _index.default)(interval.start).getTime();
    var endTime = (0, _index.default)(interval.end).getTime();
    if (!(startTime <= endTime)) {
      throw new RangeError("Invalid interval");
    }
    return time >= startTime && time <= endTime;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subDays/index.js
var require_subDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subDays;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subDays(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/isYesterday/index.js
var require_isYesterday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = isYesterday;
  var _index = _interopRequireDefault(require_isSameDay());
  var _index2 = _interopRequireDefault(require_subDays());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function isYesterday(dirtyDate) {
    (0, _index3.default)(1, arguments);
    return (0, _index.default)(dirtyDate, (0, _index2.default)(Date.now(), 1));
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfDecade/index.js
var require_lastDayOfDecade = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    var decade = 9 + Math.floor(year / 10) * 10;
    date3.setFullYear(decade + 1, 0, 0);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfWeek/index.js
var require_lastDayOfWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfWeek;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_toInteger());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = require_defaultOptions();
  function lastDayOfWeek(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index3.default)(1, arguments);
    var defaultOptions = (0, _index4.getDefaultOptions)();
    var weekStartsOn = (0, _index2.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6");
    }
    var date3 = (0, _index.default)(dirtyDate);
    var day = date3.getDay();
    var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
    date3.setHours(0, 0, 0, 0);
    date3.setDate(date3.getDate() + diff);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfISOWeek/index.js
var require_lastDayOfISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfISOWeek;
  var _index = _interopRequireDefault(require_lastDayOfWeek());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfISOWeek(dirtyDate) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(dirtyDate, {
      weekStartsOn: 1
    });
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfISOWeekYear/index.js
var require_lastDayOfISOWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfISOWeekYear;
  var _index = _interopRequireDefault(require_getISOWeekYear());
  var _index2 = _interopRequireDefault(require_startOfISOWeek());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfISOWeekYear(dirtyDate) {
    (0, _index3.default)(1, arguments);
    var year = (0, _index.default)(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setFullYear(year + 1, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    var date3 = (0, _index2.default)(fourthOfJanuary);
    date3.setDate(date3.getDate() - 1);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfQuarter/index.js
var require_lastDayOfQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfQuarter;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfQuarter(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var currentMonth = date3.getMonth();
    var month = currentMonth - currentMonth % 3 + 3;
    date3.setMonth(month, 0);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lastDayOfYear/index.js
var require_lastDayOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lastDayOfYear;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function lastDayOfYear(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    date3.setFullYear(year + 1, 0, 0);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/lightFormat/index.js
var require_lightFormat = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = lightFormat;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_lightFormatters());
  var _index3 = _interopRequireDefault(require_getTimezoneOffsetInMilliseconds());
  var _index4 = _interopRequireDefault(require_isValid());
  var _index5 = _interopRequireDefault(require_subMilliseconds());
  var _index6 = _interopRequireDefault(require_requiredArgs());
  var formattingTokensRegExp = /(\w)\1*|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function lightFormat(dirtyDate, formatStr) {
    (0, _index6.default)(2, arguments);
    var originalDate = (0, _index.default)(dirtyDate);
    if (!(0, _index4.default)(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    var timezoneOffset = (0, _index3.default)(originalDate);
    var utcDate = (0, _index5.default)(originalDate, timezoneOffset);
    var tokens = formatStr.match(formattingTokensRegExp);
    if (!tokens)
      return "";
    var result = tokens.map(function(substring) {
      if (substring === "''") {
        return "'";
      }
      var firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString(substring);
      }
      var formatter = _index2.default[firstCharacter];
      if (formatter) {
        return formatter(utcDate, substring);
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
      }
      return substring;
    }).join("");
    return result;
  }
  function cleanEscapedString(input) {
    var matches = input.match(escapedStringRegExp);
    if (!matches) {
      return input;
    }
    return matches[1].replace(doubleQuoteRegExp, "'");
  }
  module.exports = exports.default;
});

// node_modules/date-fns/milliseconds/index.js
var require_milliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = milliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var daysInYear = 365.2425;
  function milliseconds(_ref) {
    var { years, months, weeks, days, hours, minutes, seconds } = _ref;
    (0, _index.default)(1, arguments);
    var totalDays = 0;
    if (years)
      totalDays += years * daysInYear;
    if (months)
      totalDays += months * (daysInYear / 12);
    if (weeks)
      totalDays += weeks * 7;
    if (days)
      totalDays += days;
    var totalSeconds = totalDays * 24 * 60 * 60;
    if (hours)
      totalSeconds += hours * 60 * 60;
    if (minutes)
      totalSeconds += minutes * 60;
    if (seconds)
      totalSeconds += seconds;
    return Math.round(totalSeconds * 1000);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/millisecondsToHours/index.js
var require_millisecondsToHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = millisecondsToHours;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function millisecondsToHours(milliseconds) {
    (0, _index.default)(1, arguments);
    var hours = milliseconds / _index2.millisecondsInHour;
    return Math.floor(hours);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/millisecondsToMinutes/index.js
var require_millisecondsToMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = millisecondsToMinutes;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function millisecondsToMinutes(milliseconds) {
    (0, _index.default)(1, arguments);
    var minutes = milliseconds / _index2.millisecondsInMinute;
    return Math.floor(minutes);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/millisecondsToSeconds/index.js
var require_millisecondsToSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = millisecondsToSeconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function millisecondsToSeconds(milliseconds) {
    (0, _index.default)(1, arguments);
    var seconds = milliseconds / _index2.millisecondsInSecond;
    return Math.floor(seconds);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/minutesToHours/index.js
var require_minutesToHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = minutesToHours;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function minutesToHours(minutes) {
    (0, _index.default)(1, arguments);
    var hours = minutes / _index2.minutesInHour;
    return Math.floor(hours);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/minutesToMilliseconds/index.js
var require_minutesToMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = minutesToMilliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function minutesToMilliseconds(minutes) {
    (0, _index.default)(1, arguments);
    return Math.floor(minutes * _index2.millisecondsInMinute);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/minutesToSeconds/index.js
var require_minutesToSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = minutesToSeconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function minutesToSeconds(minutes) {
    (0, _index.default)(1, arguments);
    return Math.floor(minutes * _index2.secondsInMinute);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/monthsToQuarters/index.js
var require_monthsToQuarters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = monthsToQuarters;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function monthsToQuarters(months) {
    (0, _index.default)(1, arguments);
    var quarters = months / _index2.monthsInQuarter;
    return Math.floor(quarters);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/monthsToYears/index.js
var require_monthsToYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = monthsToYears;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function monthsToYears(months) {
    (0, _index.default)(1, arguments);
    var years = months / _index2.monthsInYear;
    return Math.floor(years);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextDay/index.js
var require_nextDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextDay;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_getDay());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function nextDay(date3, day) {
    (0, _index3.default)(2, arguments);
    var delta3 = day - (0, _index2.default)(date3);
    if (delta3 <= 0)
      delta3 += 7;
    return (0, _index.default)(date3, delta3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextFriday/index.js
var require_nextFriday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextFriday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextFriday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 5);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextMonday/index.js
var require_nextMonday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextMonday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextMonday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 1);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextSaturday/index.js
var require_nextSaturday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextSaturday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextSaturday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 6);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextSunday/index.js
var require_nextSunday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextSunday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextSunday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 0);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextThursday/index.js
var require_nextThursday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextThursday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextThursday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 4);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextTuesday/index.js
var require_nextTuesday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextTuesday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextTuesday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 2);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/nextWednesday/index.js
var require_nextWednesday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = nextWednesday;
  var _index = _interopRequireDefault(require_nextDay());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function nextWednesday(date3) {
    (0, _index2.default)(1, arguments);
    return (0, _index.default)(date3, 3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/parseISO/index.js
var require_parseISO = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parseISO;
  var _index = require_constants3();
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function parseISO(argument, options) {
    var _options$additionalDi;
    (0, _index2.default)(1, arguments);
    var additionalDigits = (0, _index3.default)((_options$additionalDi = options === null || options === undefined ? undefined : options.additionalDigits) !== null && _options$additionalDi !== undefined ? _options$additionalDi : 2);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    }
    if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
      return new Date(NaN);
    }
    var dateStrings = splitDateString(argument);
    var date3;
    if (dateStrings.date) {
      var parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date3 = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date3 || isNaN(date3.getTime())) {
      return new Date(NaN);
    }
    var timestamp = date3.getTime();
    var time = 0;
    var offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) {
        return new Date(NaN);
      }
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) {
        return new Date(NaN);
      }
    } else {
      var dirtyDate = new Date(timestamp + time);
      var result = new Date(0);
      result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
      result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
      return result;
    }
    return new Date(timestamp + time + offset);
  }
  var patterns3 = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function splitDateString(dateString) {
    var dateStrings = {};
    var array3 = dateString.split(patterns3.dateTimeDelimiter);
    var timeString;
    if (array3.length > 2) {
      return dateStrings;
    }
    if (/:/.test(array3[0])) {
      timeString = array3[0];
    } else {
      dateStrings.date = array3[0];
      timeString = array3[1];
      if (patterns3.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns3.timeZoneDelimiter)[0];
        timeString = dateString.substr(dateStrings.date.length, dateString.length);
      }
    }
    if (timeString) {
      var token = patterns3.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
    var captures = dateString.match(regex);
    if (!captures)
      return {
        year: NaN,
        restDateString: ""
      };
    var year = captures[1] ? parseInt(captures[1]) : null;
    var century = captures[2] ? parseInt(captures[2]) : null;
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null)
      return new Date(NaN);
    var captures = dateString.match(dateRegex);
    if (!captures)
      return new Date(NaN);
    var isWeekDate = !!captures[4];
    var dayOfYear = parseDateUnit(captures[1]);
    var month = parseDateUnit(captures[2]) - 1;
    var day = parseDateUnit(captures[3]);
    var week = parseDateUnit(captures[4]);
    var dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      var date3 = new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN);
      }
      date3.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date3;
    }
  }
  function parseDateUnit(value2) {
    return value2 ? parseInt(value2) : 1;
  }
  function parseTime(timeString) {
    var captures = timeString.match(timeRegex);
    if (!captures)
      return NaN;
    var hours = parseTimeUnit(captures[1]);
    var minutes = parseTimeUnit(captures[2]);
    var seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute + seconds * 1000;
  }
  function parseTimeUnit(value2) {
    return value2 && parseFloat(value2.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z")
      return 0;
    var captures = timezoneString.match(timezoneRegex);
    if (!captures)
      return 0;
    var sign = captures[1] === "+" ? -1 : 1;
    var hours = parseInt(captures[2]);
    var minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign * (hours * _index.millisecondsInHour + minutes * _index.millisecondsInMinute);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    var date3 = new Date(0);
    date3.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date3.getUTCDay() || 7;
    var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date3.setUTCDate(date3.getUTCDate() + diff);
    return date3;
  }
  var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date3) {
    return month >= 0 && month <= 11 && date3 >= 1 && date3 <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/parseJSON/index.js
var require_parseJSON = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = parseJSON;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function parseJSON(argument) {
    (0, _index2.default)(1, arguments);
    if (typeof argument === "string") {
      var parts = argument.match(/(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2}):(\d{2})(?:\.(\d{0,7}))?(?:Z|(.)(\d{2}):?(\d{2})?)?/);
      if (parts) {
        return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4] - (+parts[9] || 0) * (parts[8] == "-" ? -1 : 1), +parts[5] - (+parts[10] || 0) * (parts[8] == "-" ? -1 : 1), +parts[6], +((parts[7] || "0") + "00").substring(0, 3)));
      }
      return new Date(NaN);
    }
    return (0, _index.default)(argument);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousDay/index.js
var require_previousDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousDay;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_getDay());
  var _index3 = _interopRequireDefault(require_subDays());
  function previousDay(date3, day) {
    (0, _index.default)(2, arguments);
    var delta3 = (0, _index2.default)(date3) - day;
    if (delta3 <= 0)
      delta3 += 7;
    return (0, _index3.default)(date3, delta3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousFriday/index.js
var require_previousFriday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousFriday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousFriday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 5);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousMonday/index.js
var require_previousMonday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousMonday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousMonday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 1);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousSaturday/index.js
var require_previousSaturday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousSaturday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousSaturday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 6);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousSunday/index.js
var require_previousSunday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousSunday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousSunday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 0);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousThursday/index.js
var require_previousThursday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousThursday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousThursday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 4);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousTuesday/index.js
var require_previousTuesday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousTuesday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousTuesday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 2);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/previousWednesday/index.js
var require_previousWednesday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = previousWednesday;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = _interopRequireDefault(require_previousDay());
  function previousWednesday(date3) {
    (0, _index.default)(1, arguments);
    return (0, _index2.default)(date3, 3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/quartersToMonths/index.js
var require_quartersToMonths = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = quartersToMonths;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function quartersToMonths(quarters) {
    (0, _index.default)(1, arguments);
    return Math.floor(quarters * _index2.monthsInQuarter);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/quartersToYears/index.js
var require_quartersToYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = quartersToYears;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function quartersToYears(quarters) {
    (0, _index.default)(1, arguments);
    var years = quarters / _index2.quartersInYear;
    return Math.floor(years);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/roundToNearestMinutes/index.js
var require_roundToNearestMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = roundToNearestMinutes;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = require_roundingMethods();
  var _index3 = _interopRequireDefault(require_toInteger());
  function roundToNearestMinutes(dirtyDate, options) {
    var _options$nearestTo;
    if (arguments.length < 1) {
      throw new TypeError("1 argument required, but only none provided present");
    }
    var nearestTo = (0, _index3.default)((_options$nearestTo = options === null || options === undefined ? undefined : options.nearestTo) !== null && _options$nearestTo !== undefined ? _options$nearestTo : 1);
    if (nearestTo < 1 || nearestTo > 30) {
      throw new RangeError("`options.nearestTo` must be between 1 and 30");
    }
    var date3 = (0, _index.default)(dirtyDate);
    var seconds = date3.getSeconds();
    var minutes = date3.getMinutes() + seconds / 60;
    var roundingMethod = (0, _index2.getRoundingMethod)(options === null || options === undefined ? undefined : options.roundingMethod);
    var roundedMinutes = roundingMethod(minutes / nearestTo) * nearestTo;
    var remainderMinutes = minutes % nearestTo;
    var addedMinutes = Math.round(remainderMinutes / nearestTo) * nearestTo;
    return new Date(date3.getFullYear(), date3.getMonth(), date3.getDate(), date3.getHours(), roundedMinutes + addedMinutes);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/secondsToHours/index.js
var require_secondsToHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = secondsToHours;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function secondsToHours(seconds) {
    (0, _index.default)(1, arguments);
    var hours = seconds / _index2.secondsInHour;
    return Math.floor(hours);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/secondsToMilliseconds/index.js
var require_secondsToMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = secondsToMilliseconds;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function secondsToMilliseconds(seconds) {
    (0, _index.default)(1, arguments);
    return seconds * _index2.millisecondsInSecond;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/secondsToMinutes/index.js
var require_secondsToMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = secondsToMinutes;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function secondsToMinutes(seconds) {
    (0, _index.default)(1, arguments);
    var minutes = seconds / _index2.secondsInMinute;
    return Math.floor(minutes);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setMonth/index.js
var require_setMonth = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setMonth;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getDaysInMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setMonth(dirtyDate, dirtyMonth) {
    (0, _index4.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var month = (0, _index.default)(dirtyMonth);
    var year = date3.getFullYear();
    var day = date3.getDate();
    var dateWithDesiredMonth = new Date(0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    var daysInMonth = (0, _index3.default)(dateWithDesiredMonth);
    date3.setMonth(month, Math.min(day, daysInMonth));
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/set/index.js
var require_set2 = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = set2;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_setMonth());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function set2(dirtyDate, values) {
    (0, _index4.default)(2, arguments);
    if ((0, _typeof2.default)(values) !== "object" || values === null) {
      throw new RangeError("values parameter must be an object");
    }
    var date3 = (0, _index.default)(dirtyDate);
    if (isNaN(date3.getTime())) {
      return new Date(NaN);
    }
    if (values.year != null) {
      date3.setFullYear(values.year);
    }
    if (values.month != null) {
      date3 = (0, _index2.default)(date3, values.month);
    }
    if (values.date != null) {
      date3.setDate((0, _index3.default)(values.date));
    }
    if (values.hours != null) {
      date3.setHours((0, _index3.default)(values.hours));
    }
    if (values.minutes != null) {
      date3.setMinutes((0, _index3.default)(values.minutes));
    }
    if (values.seconds != null) {
      date3.setSeconds((0, _index3.default)(values.seconds));
    }
    if (values.milliseconds != null) {
      date3.setMilliseconds((0, _index3.default)(values.milliseconds));
    }
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setDate/index.js
var require_setDate = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setDate;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setDate(dirtyDate, dirtyDayOfMonth) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var dayOfMonth = (0, _index.default)(dirtyDayOfMonth);
    date3.setDate(dayOfMonth);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setDay/index.js
var require_setDay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setDay;
  var _index = _interopRequireDefault(require_addDays());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_toInteger());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  var _index5 = require_defaultOptions();
  function setDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index4.default)(2, arguments);
    var defaultOptions = (0, _index5.getDefaultOptions)();
    var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === undefined ? undefined : options.weekStartsOn) !== null && _options$weekStartsOn !== undefined ? _options$weekStartsOn : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.weekStartsOn) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.weekStartsOn) !== null && _ref !== undefined ? _ref : 0);
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    }
    var date3 = (0, _index2.default)(dirtyDate);
    var day = (0, _index3.default)(dirtyDay);
    var currentDay = date3.getDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var delta3 = 7 - weekStartsOn;
    var diff = day < 0 || day > 6 ? day - (currentDay + delta3) % 7 : (dayIndex + delta3) % 7 - (currentDay + delta3) % 7;
    return (0, _index.default)(date3, diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setDayOfYear/index.js
var require_setDayOfYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setDayOfYear;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setDayOfYear(dirtyDate, dirtyDayOfYear) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var dayOfYear = (0, _index.default)(dirtyDayOfYear);
    date3.setMonth(0);
    date3.setDate(dayOfYear);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setDefaultOptions/index.js
var require_setDefaultOptions = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setDefaultOptions;
  var _index = require_defaultOptions();
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function setDefaultOptions(newOptions) {
    (0, _index2.default)(1, arguments);
    var result = {};
    var defaultOptions = (0, _index.getDefaultOptions)();
    for (var property in defaultOptions) {
      if (Object.prototype.hasOwnProperty.call(defaultOptions, property)) {
        result[property] = defaultOptions[property];
      }
    }
    for (var _property in newOptions) {
      if (Object.prototype.hasOwnProperty.call(newOptions, _property)) {
        if (newOptions[_property] === undefined) {
          delete result[_property];
        } else {
          result[_property] = newOptions[_property];
        }
      }
    }
    (0, _index.setDefaultOptions)(result);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setHours/index.js
var require_setHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setHours;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setHours(dirtyDate, dirtyHours) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var hours = (0, _index.default)(dirtyHours);
    date3.setHours(hours);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setISODay/index.js
var require_setISODay = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setISODay;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_addDays());
  var _index4 = _interopRequireDefault(require_getISODay());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  function setISODay(dirtyDate, dirtyDay) {
    (0, _index5.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var day = (0, _index.default)(dirtyDay);
    var currentDay = (0, _index4.default)(date3);
    var diff = day - currentDay;
    return (0, _index3.default)(date3, diff);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setISOWeek/index.js
var require_setISOWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setISOWeek;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_getISOWeek());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setISOWeek(dirtyDate, dirtyISOWeek) {
    (0, _index4.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var isoWeek = (0, _index.default)(dirtyISOWeek);
    var diff = (0, _index3.default)(date3) - isoWeek;
    date3.setDate(date3.getDate() - diff * 7);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setMilliseconds/index.js
var require_setMilliseconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setMilliseconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setMilliseconds(dirtyDate, dirtyMilliseconds) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var milliseconds = (0, _index.default)(dirtyMilliseconds);
    date3.setMilliseconds(milliseconds);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setMinutes/index.js
var require_setMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setMinutes;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setMinutes(dirtyDate, dirtyMinutes) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var minutes = (0, _index.default)(dirtyMinutes);
    date3.setMinutes(minutes);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setQuarter/index.js
var require_setQuarter = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setQuarter;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_setMonth());
  var _index4 = _interopRequireDefault(require_requiredArgs());
  function setQuarter(dirtyDate, dirtyQuarter) {
    (0, _index4.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var quarter = (0, _index.default)(dirtyQuarter);
    var oldQuarter = Math.floor(date3.getMonth() / 3) + 1;
    var diff = quarter - oldQuarter;
    return (0, _index3.default)(date3, date3.getMonth() + diff * 3);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setSeconds/index.js
var require_setSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setSeconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setSeconds(dirtyDate, dirtySeconds) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var seconds = (0, _index.default)(dirtySeconds);
    date3.setSeconds(seconds);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setWeek/index.js
var require_setWeek = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setWeek;
  var _index = _interopRequireDefault(require_getWeek());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = _interopRequireDefault(require_toInteger());
  function setWeek(dirtyDate, dirtyWeek, options) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var week = (0, _index4.default)(dirtyWeek);
    var diff = (0, _index.default)(date3, options) - week;
    date3.setDate(date3.getDate() - diff * 7);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setWeekYear/index.js
var require_setWeekYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setWeekYear;
  var _index = _interopRequireDefault(require_differenceInCalendarDays());
  var _index2 = _interopRequireDefault(require_startOfWeekYear());
  var _index3 = _interopRequireDefault(require_toDate());
  var _index4 = _interopRequireDefault(require_toInteger());
  var _index5 = _interopRequireDefault(require_requiredArgs());
  var _index6 = require_defaultOptions();
  function setWeekYear(dirtyDate, dirtyWeekYear, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    (0, _index5.default)(2, arguments);
    var defaultOptions = (0, _index6.getDefaultOptions)();
    var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === undefined ? undefined : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== undefined ? _options$firstWeekCon : options === null || options === undefined ? undefined : (_options$locale = options.locale) === null || _options$locale === undefined ? undefined : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === undefined ? undefined : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== undefined ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== undefined ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === undefined ? undefined : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === undefined ? undefined : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== undefined ? _ref : 1);
    var date3 = (0, _index3.default)(dirtyDate);
    var weekYear = (0, _index4.default)(dirtyWeekYear);
    var diff = (0, _index.default)(date3, (0, _index2.default)(date3, options));
    var firstWeek = new Date(0);
    firstWeek.setFullYear(weekYear, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    date3 = (0, _index2.default)(firstWeek, options);
    date3.setDate(date3.getDate() + diff);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/setYear/index.js
var require_setYear = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = setYear;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_toDate());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function setYear(dirtyDate, dirtyYear) {
    (0, _index3.default)(2, arguments);
    var date3 = (0, _index2.default)(dirtyDate);
    var year = (0, _index.default)(dirtyYear);
    if (isNaN(date3.getTime())) {
      return new Date(NaN);
    }
    date3.setFullYear(year);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfDecade/index.js
var require_startOfDecade = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfDecade;
  var _index = _interopRequireDefault(require_toDate());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  function startOfDecade(dirtyDate) {
    (0, _index2.default)(1, arguments);
    var date3 = (0, _index.default)(dirtyDate);
    var year = date3.getFullYear();
    var decade = Math.floor(year / 10) * 10;
    date3.setFullYear(decade, 0, 1);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfToday/index.js
var require_startOfToday = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfToday;
  var _index = _interopRequireDefault(require_startOfDay());
  function startOfToday() {
    return (0, _index.default)(Date.now());
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfTomorrow/index.js
var require_startOfTomorrow = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfTomorrow;
  function startOfTomorrow() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date3 = new Date(0);
    date3.setFullYear(year, month, day + 1);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/startOfYesterday/index.js
var require_startOfYesterday = __commonJS((exports, module) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startOfYesterday;
  function startOfYesterday() {
    var now = new Date;
    var year = now.getFullYear();
    var month = now.getMonth();
    var day = now.getDate();
    var date3 = new Date(0);
    date3.setFullYear(year, month, day - 1);
    date3.setHours(0, 0, 0, 0);
    return date3;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subMonths/index.js
var require_subMonths = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subMonths;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subMonths(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/sub/index.js
var require_sub = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = sub;
  var _typeof2 = _interopRequireDefault(require_typeof());
  var _index = _interopRequireDefault(require_subDays());
  var _index2 = _interopRequireDefault(require_subMonths());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  var _index4 = _interopRequireDefault(require_toInteger());
  function sub(date3, duration) {
    (0, _index3.default)(2, arguments);
    if (!duration || (0, _typeof2.default)(duration) !== "object")
      return new Date(NaN);
    var years = duration.years ? (0, _index4.default)(duration.years) : 0;
    var months = duration.months ? (0, _index4.default)(duration.months) : 0;
    var weeks = duration.weeks ? (0, _index4.default)(duration.weeks) : 0;
    var days = duration.days ? (0, _index4.default)(duration.days) : 0;
    var hours = duration.hours ? (0, _index4.default)(duration.hours) : 0;
    var minutes = duration.minutes ? (0, _index4.default)(duration.minutes) : 0;
    var seconds = duration.seconds ? (0, _index4.default)(duration.seconds) : 0;
    var dateWithoutMonths = (0, _index2.default)(date3, months + years * 12);
    var dateWithoutDays = (0, _index.default)(dateWithoutMonths, days + weeks * 7);
    var minutestoSub = minutes + hours * 60;
    var secondstoSub = seconds + minutestoSub * 60;
    var mstoSub = secondstoSub * 1000;
    var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
    return finalDate;
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subBusinessDays/index.js
var require_subBusinessDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subBusinessDays;
  var _index = _interopRequireDefault(require_addBusinessDays());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subBusinessDays(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subHours/index.js
var require_subHours = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subHours;
  var _index = _interopRequireDefault(require_addHours());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subHours(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subMinutes/index.js
var require_subMinutes = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subMinutes;
  var _index = _interopRequireDefault(require_addMinutes());
  var _index2 = _interopRequireDefault(require_requiredArgs());
  var _index3 = _interopRequireDefault(require_toInteger());
  function subMinutes(dirtyDate, dirtyAmount) {
    (0, _index2.default)(2, arguments);
    var amount = (0, _index3.default)(dirtyAmount);
    return (0, _index.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subQuarters/index.js
var require_subQuarters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subQuarters;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addQuarters());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subQuarters(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subSeconds/index.js
var require_subSeconds = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subSeconds;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addSeconds());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subSeconds(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subWeeks/index.js
var require_subWeeks = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subWeeks;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addWeeks());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subWeeks(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/subYears/index.js
var require_subYears = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = subYears;
  var _index = _interopRequireDefault(require_toInteger());
  var _index2 = _interopRequireDefault(require_addYears());
  var _index3 = _interopRequireDefault(require_requiredArgs());
  function subYears(dirtyDate, dirtyAmount) {
    (0, _index3.default)(2, arguments);
    var amount = (0, _index.default)(dirtyAmount);
    return (0, _index2.default)(dirtyDate, -amount);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/weeksToDays/index.js
var require_weeksToDays = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = weeksToDays;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function weeksToDays(weeks) {
    (0, _index.default)(1, arguments);
    return Math.floor(weeks * _index2.daysInWeek);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/yearsToMonths/index.js
var require_yearsToMonths = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = yearsToMonths;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function yearsToMonths(years) {
    (0, _index.default)(1, arguments);
    return Math.floor(years * _index2.monthsInYear);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/yearsToQuarters/index.js
var require_yearsToQuarters = __commonJS((exports, module) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = yearsToQuarters;
  var _index = _interopRequireDefault(require_requiredArgs());
  var _index2 = require_constants3();
  function yearsToQuarters(years) {
    (0, _index.default)(1, arguments);
    return Math.floor(years * _index2.quartersInYear);
  }
  module.exports = exports.default;
});

// node_modules/date-fns/index.js
var require_date_fns = __commonJS((exports) => {
  var _interopRequireDefault = require_interopRequireDefault().default;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    add: true,
    addBusinessDays: true,
    addDays: true,
    addHours: true,
    addISOWeekYears: true,
    addMilliseconds: true,
    addMinutes: true,
    addMonths: true,
    addQuarters: true,
    addSeconds: true,
    addWeeks: true,
    addYears: true,
    areIntervalsOverlapping: true,
    clamp: true,
    closestIndexTo: true,
    closestTo: true,
    compareAsc: true,
    compareDesc: true,
    daysToWeeks: true,
    differenceInBusinessDays: true,
    differenceInCalendarDays: true,
    differenceInCalendarISOWeekYears: true,
    differenceInCalendarISOWeeks: true,
    differenceInCalendarMonths: true,
    differenceInCalendarQuarters: true,
    differenceInCalendarWeeks: true,
    differenceInCalendarYears: true,
    differenceInDays: true,
    differenceInHours: true,
    differenceInISOWeekYears: true,
    differenceInMilliseconds: true,
    differenceInMinutes: true,
    differenceInMonths: true,
    differenceInQuarters: true,
    differenceInSeconds: true,
    differenceInWeeks: true,
    differenceInYears: true,
    eachDayOfInterval: true,
    eachHourOfInterval: true,
    eachMinuteOfInterval: true,
    eachMonthOfInterval: true,
    eachQuarterOfInterval: true,
    eachWeekOfInterval: true,
    eachWeekendOfInterval: true,
    eachWeekendOfMonth: true,
    eachWeekendOfYear: true,
    eachYearOfInterval: true,
    endOfDay: true,
    endOfDecade: true,
    endOfHour: true,
    endOfISOWeek: true,
    endOfISOWeekYear: true,
    endOfMinute: true,
    endOfMonth: true,
    endOfQuarter: true,
    endOfSecond: true,
    endOfToday: true,
    endOfTomorrow: true,
    endOfWeek: true,
    endOfYear: true,
    endOfYesterday: true,
    format: true,
    formatDistance: true,
    formatDistanceStrict: true,
    formatDistanceToNow: true,
    formatDistanceToNowStrict: true,
    formatDuration: true,
    formatISO: true,
    formatISO9075: true,
    formatISODuration: true,
    formatRFC3339: true,
    formatRFC7231: true,
    formatRelative: true,
    fromUnixTime: true,
    getDate: true,
    getDay: true,
    getDayOfYear: true,
    getDaysInMonth: true,
    getDaysInYear: true,
    getDecade: true,
    getDefaultOptions: true,
    getHours: true,
    getISODay: true,
    getISOWeek: true,
    getISOWeekYear: true,
    getISOWeeksInYear: true,
    getMilliseconds: true,
    getMinutes: true,
    getMonth: true,
    getOverlappingDaysInIntervals: true,
    getQuarter: true,
    getSeconds: true,
    getTime: true,
    getUnixTime: true,
    getWeek: true,
    getWeekOfMonth: true,
    getWeekYear: true,
    getWeeksInMonth: true,
    getYear: true,
    hoursToMilliseconds: true,
    hoursToMinutes: true,
    hoursToSeconds: true,
    intervalToDuration: true,
    intlFormat: true,
    intlFormatDistance: true,
    isAfter: true,
    isBefore: true,
    isDate: true,
    isEqual: true,
    isExists: true,
    isFirstDayOfMonth: true,
    isFriday: true,
    isFuture: true,
    isLastDayOfMonth: true,
    isLeapYear: true,
    isMatch: true,
    isMonday: true,
    isPast: true,
    isSameDay: true,
    isSameHour: true,
    isSameISOWeek: true,
    isSameISOWeekYear: true,
    isSameMinute: true,
    isSameMonth: true,
    isSameQuarter: true,
    isSameSecond: true,
    isSameWeek: true,
    isSameYear: true,
    isSaturday: true,
    isSunday: true,
    isThisHour: true,
    isThisISOWeek: true,
    isThisMinute: true,
    isThisMonth: true,
    isThisQuarter: true,
    isThisSecond: true,
    isThisWeek: true,
    isThisYear: true,
    isThursday: true,
    isToday: true,
    isTomorrow: true,
    isTuesday: true,
    isValid: true,
    isWednesday: true,
    isWeekend: true,
    isWithinInterval: true,
    isYesterday: true,
    lastDayOfDecade: true,
    lastDayOfISOWeek: true,
    lastDayOfISOWeekYear: true,
    lastDayOfMonth: true,
    lastDayOfQuarter: true,
    lastDayOfWeek: true,
    lastDayOfYear: true,
    lightFormat: true,
    max: true,
    milliseconds: true,
    millisecondsToHours: true,
    millisecondsToMinutes: true,
    millisecondsToSeconds: true,
    min: true,
    minutesToHours: true,
    minutesToMilliseconds: true,
    minutesToSeconds: true,
    monthsToQuarters: true,
    monthsToYears: true,
    nextDay: true,
    nextFriday: true,
    nextMonday: true,
    nextSaturday: true,
    nextSunday: true,
    nextThursday: true,
    nextTuesday: true,
    nextWednesday: true,
    parse: true,
    parseISO: true,
    parseJSON: true,
    previousDay: true,
    previousFriday: true,
    previousMonday: true,
    previousSaturday: true,
    previousSunday: true,
    previousThursday: true,
    previousTuesday: true,
    previousWednesday: true,
    quartersToMonths: true,
    quartersToYears: true,
    roundToNearestMinutes: true,
    secondsToHours: true,
    secondsToMilliseconds: true,
    secondsToMinutes: true,
    set: true,
    setDate: true,
    setDay: true,
    setDayOfYear: true,
    setDefaultOptions: true,
    setHours: true,
    setISODay: true,
    setISOWeek: true,
    setISOWeekYear: true,
    setMilliseconds: true,
    setMinutes: true,
    setMonth: true,
    setQuarter: true,
    setSeconds: true,
    setWeek: true,
    setWeekYear: true,
    setYear: true,
    startOfDay: true,
    startOfDecade: true,
    startOfHour: true,
    startOfISOWeek: true,
    startOfISOWeekYear: true,
    startOfMinute: true,
    startOfMonth: true,
    startOfQuarter: true,
    startOfSecond: true,
    startOfToday: true,
    startOfTomorrow: true,
    startOfWeek: true,
    startOfWeekYear: true,
    startOfYear: true,
    startOfYesterday: true,
    sub: true,
    subBusinessDays: true,
    subDays: true,
    subHours: true,
    subISOWeekYears: true,
    subMilliseconds: true,
    subMinutes: true,
    subMonths: true,
    subQuarters: true,
    subSeconds: true,
    subWeeks: true,
    subYears: true,
    toDate: true,
    weeksToDays: true,
    yearsToMonths: true,
    yearsToQuarters: true
  };
  Object.defineProperty(exports, "add", {
    enumerable: true,
    get: function get() {
      return _index.default;
    }
  });
  Object.defineProperty(exports, "addBusinessDays", {
    enumerable: true,
    get: function get() {
      return _index2.default;
    }
  });
  Object.defineProperty(exports, "addDays", {
    enumerable: true,
    get: function get() {
      return _index3.default;
    }
  });
  Object.defineProperty(exports, "addHours", {
    enumerable: true,
    get: function get() {
      return _index4.default;
    }
  });
  Object.defineProperty(exports, "addISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index5.default;
    }
  });
  Object.defineProperty(exports, "addMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index6.default;
    }
  });
  Object.defineProperty(exports, "addMinutes", {
    enumerable: true,
    get: function get() {
      return _index7.default;
    }
  });
  Object.defineProperty(exports, "addMonths", {
    enumerable: true,
    get: function get() {
      return _index8.default;
    }
  });
  Object.defineProperty(exports, "addQuarters", {
    enumerable: true,
    get: function get() {
      return _index9.default;
    }
  });
  Object.defineProperty(exports, "addSeconds", {
    enumerable: true,
    get: function get() {
      return _index10.default;
    }
  });
  Object.defineProperty(exports, "addWeeks", {
    enumerable: true,
    get: function get() {
      return _index11.default;
    }
  });
  Object.defineProperty(exports, "addYears", {
    enumerable: true,
    get: function get() {
      return _index12.default;
    }
  });
  Object.defineProperty(exports, "areIntervalsOverlapping", {
    enumerable: true,
    get: function get() {
      return _index13.default;
    }
  });
  Object.defineProperty(exports, "clamp", {
    enumerable: true,
    get: function get() {
      return _index14.default;
    }
  });
  Object.defineProperty(exports, "closestIndexTo", {
    enumerable: true,
    get: function get() {
      return _index15.default;
    }
  });
  Object.defineProperty(exports, "closestTo", {
    enumerable: true,
    get: function get() {
      return _index16.default;
    }
  });
  Object.defineProperty(exports, "compareAsc", {
    enumerable: true,
    get: function get() {
      return _index17.default;
    }
  });
  Object.defineProperty(exports, "compareDesc", {
    enumerable: true,
    get: function get() {
      return _index18.default;
    }
  });
  Object.defineProperty(exports, "daysToWeeks", {
    enumerable: true,
    get: function get() {
      return _index19.default;
    }
  });
  Object.defineProperty(exports, "differenceInBusinessDays", {
    enumerable: true,
    get: function get() {
      return _index20.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarDays", {
    enumerable: true,
    get: function get() {
      return _index21.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index22.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarISOWeeks", {
    enumerable: true,
    get: function get() {
      return _index23.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarMonths", {
    enumerable: true,
    get: function get() {
      return _index24.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarQuarters", {
    enumerable: true,
    get: function get() {
      return _index25.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarWeeks", {
    enumerable: true,
    get: function get() {
      return _index26.default;
    }
  });
  Object.defineProperty(exports, "differenceInCalendarYears", {
    enumerable: true,
    get: function get() {
      return _index27.default;
    }
  });
  Object.defineProperty(exports, "differenceInDays", {
    enumerable: true,
    get: function get() {
      return _index28.default;
    }
  });
  Object.defineProperty(exports, "differenceInHours", {
    enumerable: true,
    get: function get() {
      return _index29.default;
    }
  });
  Object.defineProperty(exports, "differenceInISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index30.default;
    }
  });
  Object.defineProperty(exports, "differenceInMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index31.default;
    }
  });
  Object.defineProperty(exports, "differenceInMinutes", {
    enumerable: true,
    get: function get() {
      return _index32.default;
    }
  });
  Object.defineProperty(exports, "differenceInMonths", {
    enumerable: true,
    get: function get() {
      return _index33.default;
    }
  });
  Object.defineProperty(exports, "differenceInQuarters", {
    enumerable: true,
    get: function get() {
      return _index34.default;
    }
  });
  Object.defineProperty(exports, "differenceInSeconds", {
    enumerable: true,
    get: function get() {
      return _index35.default;
    }
  });
  Object.defineProperty(exports, "differenceInWeeks", {
    enumerable: true,
    get: function get() {
      return _index36.default;
    }
  });
  Object.defineProperty(exports, "differenceInYears", {
    enumerable: true,
    get: function get() {
      return _index37.default;
    }
  });
  Object.defineProperty(exports, "eachDayOfInterval", {
    enumerable: true,
    get: function get() {
      return _index38.default;
    }
  });
  Object.defineProperty(exports, "eachHourOfInterval", {
    enumerable: true,
    get: function get() {
      return _index39.default;
    }
  });
  Object.defineProperty(exports, "eachMinuteOfInterval", {
    enumerable: true,
    get: function get() {
      return _index40.default;
    }
  });
  Object.defineProperty(exports, "eachMonthOfInterval", {
    enumerable: true,
    get: function get() {
      return _index41.default;
    }
  });
  Object.defineProperty(exports, "eachQuarterOfInterval", {
    enumerable: true,
    get: function get() {
      return _index42.default;
    }
  });
  Object.defineProperty(exports, "eachWeekOfInterval", {
    enumerable: true,
    get: function get() {
      return _index43.default;
    }
  });
  Object.defineProperty(exports, "eachWeekendOfInterval", {
    enumerable: true,
    get: function get() {
      return _index44.default;
    }
  });
  Object.defineProperty(exports, "eachWeekendOfMonth", {
    enumerable: true,
    get: function get() {
      return _index45.default;
    }
  });
  Object.defineProperty(exports, "eachWeekendOfYear", {
    enumerable: true,
    get: function get() {
      return _index46.default;
    }
  });
  Object.defineProperty(exports, "eachYearOfInterval", {
    enumerable: true,
    get: function get() {
      return _index47.default;
    }
  });
  Object.defineProperty(exports, "endOfDay", {
    enumerable: true,
    get: function get() {
      return _index48.default;
    }
  });
  Object.defineProperty(exports, "endOfDecade", {
    enumerable: true,
    get: function get() {
      return _index49.default;
    }
  });
  Object.defineProperty(exports, "endOfHour", {
    enumerable: true,
    get: function get() {
      return _index50.default;
    }
  });
  Object.defineProperty(exports, "endOfISOWeek", {
    enumerable: true,
    get: function get() {
      return _index51.default;
    }
  });
  Object.defineProperty(exports, "endOfISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index52.default;
    }
  });
  Object.defineProperty(exports, "endOfMinute", {
    enumerable: true,
    get: function get() {
      return _index53.default;
    }
  });
  Object.defineProperty(exports, "endOfMonth", {
    enumerable: true,
    get: function get() {
      return _index54.default;
    }
  });
  Object.defineProperty(exports, "endOfQuarter", {
    enumerable: true,
    get: function get() {
      return _index55.default;
    }
  });
  Object.defineProperty(exports, "endOfSecond", {
    enumerable: true,
    get: function get() {
      return _index56.default;
    }
  });
  Object.defineProperty(exports, "endOfToday", {
    enumerable: true,
    get: function get() {
      return _index57.default;
    }
  });
  Object.defineProperty(exports, "endOfTomorrow", {
    enumerable: true,
    get: function get() {
      return _index58.default;
    }
  });
  Object.defineProperty(exports, "endOfWeek", {
    enumerable: true,
    get: function get() {
      return _index59.default;
    }
  });
  Object.defineProperty(exports, "endOfYear", {
    enumerable: true,
    get: function get() {
      return _index60.default;
    }
  });
  Object.defineProperty(exports, "endOfYesterday", {
    enumerable: true,
    get: function get() {
      return _index61.default;
    }
  });
  Object.defineProperty(exports, "format", {
    enumerable: true,
    get: function get() {
      return _index62.default;
    }
  });
  Object.defineProperty(exports, "formatDistance", {
    enumerable: true,
    get: function get() {
      return _index63.default;
    }
  });
  Object.defineProperty(exports, "formatDistanceStrict", {
    enumerable: true,
    get: function get() {
      return _index64.default;
    }
  });
  Object.defineProperty(exports, "formatDistanceToNow", {
    enumerable: true,
    get: function get() {
      return _index65.default;
    }
  });
  Object.defineProperty(exports, "formatDistanceToNowStrict", {
    enumerable: true,
    get: function get() {
      return _index66.default;
    }
  });
  Object.defineProperty(exports, "formatDuration", {
    enumerable: true,
    get: function get() {
      return _index67.default;
    }
  });
  Object.defineProperty(exports, "formatISO", {
    enumerable: true,
    get: function get() {
      return _index68.default;
    }
  });
  Object.defineProperty(exports, "formatISO9075", {
    enumerable: true,
    get: function get() {
      return _index69.default;
    }
  });
  Object.defineProperty(exports, "formatISODuration", {
    enumerable: true,
    get: function get() {
      return _index70.default;
    }
  });
  Object.defineProperty(exports, "formatRFC3339", {
    enumerable: true,
    get: function get() {
      return _index71.default;
    }
  });
  Object.defineProperty(exports, "formatRFC7231", {
    enumerable: true,
    get: function get() {
      return _index72.default;
    }
  });
  Object.defineProperty(exports, "formatRelative", {
    enumerable: true,
    get: function get() {
      return _index73.default;
    }
  });
  Object.defineProperty(exports, "fromUnixTime", {
    enumerable: true,
    get: function get() {
      return _index74.default;
    }
  });
  Object.defineProperty(exports, "getDate", {
    enumerable: true,
    get: function get() {
      return _index75.default;
    }
  });
  Object.defineProperty(exports, "getDay", {
    enumerable: true,
    get: function get() {
      return _index76.default;
    }
  });
  Object.defineProperty(exports, "getDayOfYear", {
    enumerable: true,
    get: function get() {
      return _index77.default;
    }
  });
  Object.defineProperty(exports, "getDaysInMonth", {
    enumerable: true,
    get: function get() {
      return _index78.default;
    }
  });
  Object.defineProperty(exports, "getDaysInYear", {
    enumerable: true,
    get: function get() {
      return _index79.default;
    }
  });
  Object.defineProperty(exports, "getDecade", {
    enumerable: true,
    get: function get() {
      return _index80.default;
    }
  });
  Object.defineProperty(exports, "getDefaultOptions", {
    enumerable: true,
    get: function get() {
      return _index81.default;
    }
  });
  Object.defineProperty(exports, "getHours", {
    enumerable: true,
    get: function get() {
      return _index82.default;
    }
  });
  Object.defineProperty(exports, "getISODay", {
    enumerable: true,
    get: function get() {
      return _index83.default;
    }
  });
  Object.defineProperty(exports, "getISOWeek", {
    enumerable: true,
    get: function get() {
      return _index84.default;
    }
  });
  Object.defineProperty(exports, "getISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index85.default;
    }
  });
  Object.defineProperty(exports, "getISOWeeksInYear", {
    enumerable: true,
    get: function get() {
      return _index86.default;
    }
  });
  Object.defineProperty(exports, "getMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index87.default;
    }
  });
  Object.defineProperty(exports, "getMinutes", {
    enumerable: true,
    get: function get() {
      return _index88.default;
    }
  });
  Object.defineProperty(exports, "getMonth", {
    enumerable: true,
    get: function get() {
      return _index89.default;
    }
  });
  Object.defineProperty(exports, "getOverlappingDaysInIntervals", {
    enumerable: true,
    get: function get() {
      return _index90.default;
    }
  });
  Object.defineProperty(exports, "getQuarter", {
    enumerable: true,
    get: function get() {
      return _index91.default;
    }
  });
  Object.defineProperty(exports, "getSeconds", {
    enumerable: true,
    get: function get() {
      return _index92.default;
    }
  });
  Object.defineProperty(exports, "getTime", {
    enumerable: true,
    get: function get() {
      return _index93.default;
    }
  });
  Object.defineProperty(exports, "getUnixTime", {
    enumerable: true,
    get: function get() {
      return _index94.default;
    }
  });
  Object.defineProperty(exports, "getWeek", {
    enumerable: true,
    get: function get() {
      return _index95.default;
    }
  });
  Object.defineProperty(exports, "getWeekOfMonth", {
    enumerable: true,
    get: function get() {
      return _index96.default;
    }
  });
  Object.defineProperty(exports, "getWeekYear", {
    enumerable: true,
    get: function get() {
      return _index97.default;
    }
  });
  Object.defineProperty(exports, "getWeeksInMonth", {
    enumerable: true,
    get: function get() {
      return _index98.default;
    }
  });
  Object.defineProperty(exports, "getYear", {
    enumerable: true,
    get: function get() {
      return _index99.default;
    }
  });
  Object.defineProperty(exports, "hoursToMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index100.default;
    }
  });
  Object.defineProperty(exports, "hoursToMinutes", {
    enumerable: true,
    get: function get() {
      return _index101.default;
    }
  });
  Object.defineProperty(exports, "hoursToSeconds", {
    enumerable: true,
    get: function get() {
      return _index102.default;
    }
  });
  Object.defineProperty(exports, "intervalToDuration", {
    enumerable: true,
    get: function get() {
      return _index103.default;
    }
  });
  Object.defineProperty(exports, "intlFormat", {
    enumerable: true,
    get: function get() {
      return _index104.default;
    }
  });
  Object.defineProperty(exports, "intlFormatDistance", {
    enumerable: true,
    get: function get() {
      return _index105.default;
    }
  });
  Object.defineProperty(exports, "isAfter", {
    enumerable: true,
    get: function get() {
      return _index106.default;
    }
  });
  Object.defineProperty(exports, "isBefore", {
    enumerable: true,
    get: function get() {
      return _index107.default;
    }
  });
  Object.defineProperty(exports, "isDate", {
    enumerable: true,
    get: function get() {
      return _index108.default;
    }
  });
  Object.defineProperty(exports, "isEqual", {
    enumerable: true,
    get: function get() {
      return _index109.default;
    }
  });
  Object.defineProperty(exports, "isExists", {
    enumerable: true,
    get: function get() {
      return _index110.default;
    }
  });
  Object.defineProperty(exports, "isFirstDayOfMonth", {
    enumerable: true,
    get: function get() {
      return _index111.default;
    }
  });
  Object.defineProperty(exports, "isFriday", {
    enumerable: true,
    get: function get() {
      return _index112.default;
    }
  });
  Object.defineProperty(exports, "isFuture", {
    enumerable: true,
    get: function get() {
      return _index113.default;
    }
  });
  Object.defineProperty(exports, "isLastDayOfMonth", {
    enumerable: true,
    get: function get() {
      return _index114.default;
    }
  });
  Object.defineProperty(exports, "isLeapYear", {
    enumerable: true,
    get: function get() {
      return _index115.default;
    }
  });
  Object.defineProperty(exports, "isMatch", {
    enumerable: true,
    get: function get() {
      return _index116.default;
    }
  });
  Object.defineProperty(exports, "isMonday", {
    enumerable: true,
    get: function get() {
      return _index117.default;
    }
  });
  Object.defineProperty(exports, "isPast", {
    enumerable: true,
    get: function get() {
      return _index118.default;
    }
  });
  Object.defineProperty(exports, "isSameDay", {
    enumerable: true,
    get: function get() {
      return _index119.default;
    }
  });
  Object.defineProperty(exports, "isSameHour", {
    enumerable: true,
    get: function get() {
      return _index120.default;
    }
  });
  Object.defineProperty(exports, "isSameISOWeek", {
    enumerable: true,
    get: function get() {
      return _index121.default;
    }
  });
  Object.defineProperty(exports, "isSameISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index122.default;
    }
  });
  Object.defineProperty(exports, "isSameMinute", {
    enumerable: true,
    get: function get() {
      return _index123.default;
    }
  });
  Object.defineProperty(exports, "isSameMonth", {
    enumerable: true,
    get: function get() {
      return _index124.default;
    }
  });
  Object.defineProperty(exports, "isSameQuarter", {
    enumerable: true,
    get: function get() {
      return _index125.default;
    }
  });
  Object.defineProperty(exports, "isSameSecond", {
    enumerable: true,
    get: function get() {
      return _index126.default;
    }
  });
  Object.defineProperty(exports, "isSameWeek", {
    enumerable: true,
    get: function get() {
      return _index127.default;
    }
  });
  Object.defineProperty(exports, "isSameYear", {
    enumerable: true,
    get: function get() {
      return _index128.default;
    }
  });
  Object.defineProperty(exports, "isSaturday", {
    enumerable: true,
    get: function get() {
      return _index129.default;
    }
  });
  Object.defineProperty(exports, "isSunday", {
    enumerable: true,
    get: function get() {
      return _index130.default;
    }
  });
  Object.defineProperty(exports, "isThisHour", {
    enumerable: true,
    get: function get() {
      return _index131.default;
    }
  });
  Object.defineProperty(exports, "isThisISOWeek", {
    enumerable: true,
    get: function get() {
      return _index132.default;
    }
  });
  Object.defineProperty(exports, "isThisMinute", {
    enumerable: true,
    get: function get() {
      return _index133.default;
    }
  });
  Object.defineProperty(exports, "isThisMonth", {
    enumerable: true,
    get: function get() {
      return _index134.default;
    }
  });
  Object.defineProperty(exports, "isThisQuarter", {
    enumerable: true,
    get: function get() {
      return _index135.default;
    }
  });
  Object.defineProperty(exports, "isThisSecond", {
    enumerable: true,
    get: function get() {
      return _index136.default;
    }
  });
  Object.defineProperty(exports, "isThisWeek", {
    enumerable: true,
    get: function get() {
      return _index137.default;
    }
  });
  Object.defineProperty(exports, "isThisYear", {
    enumerable: true,
    get: function get() {
      return _index138.default;
    }
  });
  Object.defineProperty(exports, "isThursday", {
    enumerable: true,
    get: function get() {
      return _index139.default;
    }
  });
  Object.defineProperty(exports, "isToday", {
    enumerable: true,
    get: function get() {
      return _index140.default;
    }
  });
  Object.defineProperty(exports, "isTomorrow", {
    enumerable: true,
    get: function get() {
      return _index141.default;
    }
  });
  Object.defineProperty(exports, "isTuesday", {
    enumerable: true,
    get: function get() {
      return _index142.default;
    }
  });
  Object.defineProperty(exports, "isValid", {
    enumerable: true,
    get: function get() {
      return _index143.default;
    }
  });
  Object.defineProperty(exports, "isWednesday", {
    enumerable: true,
    get: function get() {
      return _index144.default;
    }
  });
  Object.defineProperty(exports, "isWeekend", {
    enumerable: true,
    get: function get() {
      return _index145.default;
    }
  });
  Object.defineProperty(exports, "isWithinInterval", {
    enumerable: true,
    get: function get() {
      return _index146.default;
    }
  });
  Object.defineProperty(exports, "isYesterday", {
    enumerable: true,
    get: function get() {
      return _index147.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfDecade", {
    enumerable: true,
    get: function get() {
      return _index148.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfISOWeek", {
    enumerable: true,
    get: function get() {
      return _index149.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index150.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfMonth", {
    enumerable: true,
    get: function get() {
      return _index151.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfQuarter", {
    enumerable: true,
    get: function get() {
      return _index152.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfWeek", {
    enumerable: true,
    get: function get() {
      return _index153.default;
    }
  });
  Object.defineProperty(exports, "lastDayOfYear", {
    enumerable: true,
    get: function get() {
      return _index154.default;
    }
  });
  Object.defineProperty(exports, "lightFormat", {
    enumerable: true,
    get: function get() {
      return _index155.default;
    }
  });
  Object.defineProperty(exports, "max", {
    enumerable: true,
    get: function get() {
      return _index156.default;
    }
  });
  Object.defineProperty(exports, "milliseconds", {
    enumerable: true,
    get: function get() {
      return _index157.default;
    }
  });
  Object.defineProperty(exports, "millisecondsToHours", {
    enumerable: true,
    get: function get() {
      return _index158.default;
    }
  });
  Object.defineProperty(exports, "millisecondsToMinutes", {
    enumerable: true,
    get: function get() {
      return _index159.default;
    }
  });
  Object.defineProperty(exports, "millisecondsToSeconds", {
    enumerable: true,
    get: function get() {
      return _index160.default;
    }
  });
  Object.defineProperty(exports, "min", {
    enumerable: true,
    get: function get() {
      return _index161.default;
    }
  });
  Object.defineProperty(exports, "minutesToHours", {
    enumerable: true,
    get: function get() {
      return _index162.default;
    }
  });
  Object.defineProperty(exports, "minutesToMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index163.default;
    }
  });
  Object.defineProperty(exports, "minutesToSeconds", {
    enumerable: true,
    get: function get() {
      return _index164.default;
    }
  });
  Object.defineProperty(exports, "monthsToQuarters", {
    enumerable: true,
    get: function get() {
      return _index165.default;
    }
  });
  Object.defineProperty(exports, "monthsToYears", {
    enumerable: true,
    get: function get() {
      return _index166.default;
    }
  });
  Object.defineProperty(exports, "nextDay", {
    enumerable: true,
    get: function get() {
      return _index167.default;
    }
  });
  Object.defineProperty(exports, "nextFriday", {
    enumerable: true,
    get: function get() {
      return _index168.default;
    }
  });
  Object.defineProperty(exports, "nextMonday", {
    enumerable: true,
    get: function get() {
      return _index169.default;
    }
  });
  Object.defineProperty(exports, "nextSaturday", {
    enumerable: true,
    get: function get() {
      return _index170.default;
    }
  });
  Object.defineProperty(exports, "nextSunday", {
    enumerable: true,
    get: function get() {
      return _index171.default;
    }
  });
  Object.defineProperty(exports, "nextThursday", {
    enumerable: true,
    get: function get() {
      return _index172.default;
    }
  });
  Object.defineProperty(exports, "nextTuesday", {
    enumerable: true,
    get: function get() {
      return _index173.default;
    }
  });
  Object.defineProperty(exports, "nextWednesday", {
    enumerable: true,
    get: function get() {
      return _index174.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function get() {
      return _index175.default;
    }
  });
  Object.defineProperty(exports, "parseISO", {
    enumerable: true,
    get: function get() {
      return _index176.default;
    }
  });
  Object.defineProperty(exports, "parseJSON", {
    enumerable: true,
    get: function get() {
      return _index177.default;
    }
  });
  Object.defineProperty(exports, "previousDay", {
    enumerable: true,
    get: function get() {
      return _index178.default;
    }
  });
  Object.defineProperty(exports, "previousFriday", {
    enumerable: true,
    get: function get() {
      return _index179.default;
    }
  });
  Object.defineProperty(exports, "previousMonday", {
    enumerable: true,
    get: function get() {
      return _index180.default;
    }
  });
  Object.defineProperty(exports, "previousSaturday", {
    enumerable: true,
    get: function get() {
      return _index181.default;
    }
  });
  Object.defineProperty(exports, "previousSunday", {
    enumerable: true,
    get: function get() {
      return _index182.default;
    }
  });
  Object.defineProperty(exports, "previousThursday", {
    enumerable: true,
    get: function get() {
      return _index183.default;
    }
  });
  Object.defineProperty(exports, "previousTuesday", {
    enumerable: true,
    get: function get() {
      return _index184.default;
    }
  });
  Object.defineProperty(exports, "previousWednesday", {
    enumerable: true,
    get: function get() {
      return _index185.default;
    }
  });
  Object.defineProperty(exports, "quartersToMonths", {
    enumerable: true,
    get: function get() {
      return _index186.default;
    }
  });
  Object.defineProperty(exports, "quartersToYears", {
    enumerable: true,
    get: function get() {
      return _index187.default;
    }
  });
  Object.defineProperty(exports, "roundToNearestMinutes", {
    enumerable: true,
    get: function get() {
      return _index188.default;
    }
  });
  Object.defineProperty(exports, "secondsToHours", {
    enumerable: true,
    get: function get() {
      return _index189.default;
    }
  });
  Object.defineProperty(exports, "secondsToMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index190.default;
    }
  });
  Object.defineProperty(exports, "secondsToMinutes", {
    enumerable: true,
    get: function get() {
      return _index191.default;
    }
  });
  Object.defineProperty(exports, "set", {
    enumerable: true,
    get: function get() {
      return _index192.default;
    }
  });
  Object.defineProperty(exports, "setDate", {
    enumerable: true,
    get: function get() {
      return _index193.default;
    }
  });
  Object.defineProperty(exports, "setDay", {
    enumerable: true,
    get: function get() {
      return _index194.default;
    }
  });
  Object.defineProperty(exports, "setDayOfYear", {
    enumerable: true,
    get: function get() {
      return _index195.default;
    }
  });
  Object.defineProperty(exports, "setDefaultOptions", {
    enumerable: true,
    get: function get() {
      return _index196.default;
    }
  });
  Object.defineProperty(exports, "setHours", {
    enumerable: true,
    get: function get() {
      return _index197.default;
    }
  });
  Object.defineProperty(exports, "setISODay", {
    enumerable: true,
    get: function get() {
      return _index198.default;
    }
  });
  Object.defineProperty(exports, "setISOWeek", {
    enumerable: true,
    get: function get() {
      return _index199.default;
    }
  });
  Object.defineProperty(exports, "setISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index200.default;
    }
  });
  Object.defineProperty(exports, "setMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index201.default;
    }
  });
  Object.defineProperty(exports, "setMinutes", {
    enumerable: true,
    get: function get() {
      return _index202.default;
    }
  });
  Object.defineProperty(exports, "setMonth", {
    enumerable: true,
    get: function get() {
      return _index203.default;
    }
  });
  Object.defineProperty(exports, "setQuarter", {
    enumerable: true,
    get: function get() {
      return _index204.default;
    }
  });
  Object.defineProperty(exports, "setSeconds", {
    enumerable: true,
    get: function get() {
      return _index205.default;
    }
  });
  Object.defineProperty(exports, "setWeek", {
    enumerable: true,
    get: function get() {
      return _index206.default;
    }
  });
  Object.defineProperty(exports, "setWeekYear", {
    enumerable: true,
    get: function get() {
      return _index207.default;
    }
  });
  Object.defineProperty(exports, "setYear", {
    enumerable: true,
    get: function get() {
      return _index208.default;
    }
  });
  Object.defineProperty(exports, "startOfDay", {
    enumerable: true,
    get: function get() {
      return _index209.default;
    }
  });
  Object.defineProperty(exports, "startOfDecade", {
    enumerable: true,
    get: function get() {
      return _index210.default;
    }
  });
  Object.defineProperty(exports, "startOfHour", {
    enumerable: true,
    get: function get() {
      return _index211.default;
    }
  });
  Object.defineProperty(exports, "startOfISOWeek", {
    enumerable: true,
    get: function get() {
      return _index212.default;
    }
  });
  Object.defineProperty(exports, "startOfISOWeekYear", {
    enumerable: true,
    get: function get() {
      return _index213.default;
    }
  });
  Object.defineProperty(exports, "startOfMinute", {
    enumerable: true,
    get: function get() {
      return _index214.default;
    }
  });
  Object.defineProperty(exports, "startOfMonth", {
    enumerable: true,
    get: function get() {
      return _index215.default;
    }
  });
  Object.defineProperty(exports, "startOfQuarter", {
    enumerable: true,
    get: function get() {
      return _index216.default;
    }
  });
  Object.defineProperty(exports, "startOfSecond", {
    enumerable: true,
    get: function get() {
      return _index217.default;
    }
  });
  Object.defineProperty(exports, "startOfToday", {
    enumerable: true,
    get: function get() {
      return _index218.default;
    }
  });
  Object.defineProperty(exports, "startOfTomorrow", {
    enumerable: true,
    get: function get() {
      return _index219.default;
    }
  });
  Object.defineProperty(exports, "startOfWeek", {
    enumerable: true,
    get: function get() {
      return _index220.default;
    }
  });
  Object.defineProperty(exports, "startOfWeekYear", {
    enumerable: true,
    get: function get() {
      return _index221.default;
    }
  });
  Object.defineProperty(exports, "startOfYear", {
    enumerable: true,
    get: function get() {
      return _index222.default;
    }
  });
  Object.defineProperty(exports, "startOfYesterday", {
    enumerable: true,
    get: function get() {
      return _index223.default;
    }
  });
  Object.defineProperty(exports, "sub", {
    enumerable: true,
    get: function get() {
      return _index224.default;
    }
  });
  Object.defineProperty(exports, "subBusinessDays", {
    enumerable: true,
    get: function get() {
      return _index225.default;
    }
  });
  Object.defineProperty(exports, "subDays", {
    enumerable: true,
    get: function get() {
      return _index226.default;
    }
  });
  Object.defineProperty(exports, "subHours", {
    enumerable: true,
    get: function get() {
      return _index227.default;
    }
  });
  Object.defineProperty(exports, "subISOWeekYears", {
    enumerable: true,
    get: function get() {
      return _index228.default;
    }
  });
  Object.defineProperty(exports, "subMilliseconds", {
    enumerable: true,
    get: function get() {
      return _index229.default;
    }
  });
  Object.defineProperty(exports, "subMinutes", {
    enumerable: true,
    get: function get() {
      return _index230.default;
    }
  });
  Object.defineProperty(exports, "subMonths", {
    enumerable: true,
    get: function get() {
      return _index231.default;
    }
  });
  Object.defineProperty(exports, "subQuarters", {
    enumerable: true,
    get: function get() {
      return _index232.default;
    }
  });
  Object.defineProperty(exports, "subSeconds", {
    enumerable: true,
    get: function get() {
      return _index233.default;
    }
  });
  Object.defineProperty(exports, "subWeeks", {
    enumerable: true,
    get: function get() {
      return _index234.default;
    }
  });
  Object.defineProperty(exports, "subYears", {
    enumerable: true,
    get: function get() {
      return _index235.default;
    }
  });
  Object.defineProperty(exports, "toDate", {
    enumerable: true,
    get: function get() {
      return _index236.default;
    }
  });
  Object.defineProperty(exports, "weeksToDays", {
    enumerable: true,
    get: function get() {
      return _index237.default;
    }
  });
  Object.defineProperty(exports, "yearsToMonths", {
    enumerable: true,
    get: function get() {
      return _index238.default;
    }
  });
  Object.defineProperty(exports, "yearsToQuarters", {
    enumerable: true,
    get: function get() {
      return _index239.default;
    }
  });
  var _index = _interopRequireDefault(require_add());
  var _index2 = _interopRequireDefault(require_addBusinessDays());
  var _index3 = _interopRequireDefault(require_addDays());
  var _index4 = _interopRequireDefault(require_addHours());
  var _index5 = _interopRequireDefault(require_addISOWeekYears());
  var _index6 = _interopRequireDefault(require_addMilliseconds());
  var _index7 = _interopRequireDefault(require_addMinutes());
  var _index8 = _interopRequireDefault(require_addMonths());
  var _index9 = _interopRequireDefault(require_addQuarters());
  var _index10 = _interopRequireDefault(require_addSeconds());
  var _index11 = _interopRequireDefault(require_addWeeks());
  var _index12 = _interopRequireDefault(require_addYears());
  var _index13 = _interopRequireDefault(require_areIntervalsOverlapping());
  var _index14 = _interopRequireDefault(require_clamp());
  var _index15 = _interopRequireDefault(require_closestIndexTo());
  var _index16 = _interopRequireDefault(require_closestTo());
  var _index17 = _interopRequireDefault(require_compareAsc());
  var _index18 = _interopRequireDefault(require_compareDesc());
  var _index19 = _interopRequireDefault(require_daysToWeeks());
  var _index20 = _interopRequireDefault(require_differenceInBusinessDays());
  var _index21 = _interopRequireDefault(require_differenceInCalendarDays());
  var _index22 = _interopRequireDefault(require_differenceInCalendarISOWeekYears());
  var _index23 = _interopRequireDefault(require_differenceInCalendarISOWeeks());
  var _index24 = _interopRequireDefault(require_differenceInCalendarMonths());
  var _index25 = _interopRequireDefault(require_differenceInCalendarQuarters());
  var _index26 = _interopRequireDefault(require_differenceInCalendarWeeks());
  var _index27 = _interopRequireDefault(require_differenceInCalendarYears());
  var _index28 = _interopRequireDefault(require_differenceInDays());
  var _index29 = _interopRequireDefault(require_differenceInHours());
  var _index30 = _interopRequireDefault(require_differenceInISOWeekYears());
  var _index31 = _interopRequireDefault(require_differenceInMilliseconds());
  var _index32 = _interopRequireDefault(require_differenceInMinutes());
  var _index33 = _interopRequireDefault(require_differenceInMonths());
  var _index34 = _interopRequireDefault(require_differenceInQuarters());
  var _index35 = _interopRequireDefault(require_differenceInSeconds());
  var _index36 = _interopRequireDefault(require_differenceInWeeks());
  var _index37 = _interopRequireDefault(require_differenceInYears());
  var _index38 = _interopRequireDefault(require_eachDayOfInterval());
  var _index39 = _interopRequireDefault(require_eachHourOfInterval());
  var _index40 = _interopRequireDefault(require_eachMinuteOfInterval());
  var _index41 = _interopRequireDefault(require_eachMonthOfInterval());
  var _index42 = _interopRequireDefault(require_eachQuarterOfInterval());
  var _index43 = _interopRequireDefault(require_eachWeekOfInterval());
  var _index44 = _interopRequireDefault(require_eachWeekendOfInterval());
  var _index45 = _interopRequireDefault(require_eachWeekendOfMonth());
  var _index46 = _interopRequireDefault(require_eachWeekendOfYear());
  var _index47 = _interopRequireDefault(require_eachYearOfInterval());
  var _index48 = _interopRequireDefault(require_endOfDay());
  var _index49 = _interopRequireDefault(require_endOfDecade());
  var _index50 = _interopRequireDefault(require_endOfHour());
  var _index51 = _interopRequireDefault(require_endOfISOWeek());
  var _index52 = _interopRequireDefault(require_endOfISOWeekYear());
  var _index53 = _interopRequireDefault(require_endOfMinute());
  var _index54 = _interopRequireDefault(require_endOfMonth());
  var _index55 = _interopRequireDefault(require_endOfQuarter());
  var _index56 = _interopRequireDefault(require_endOfSecond());
  var _index57 = _interopRequireDefault(require_endOfToday());
  var _index58 = _interopRequireDefault(require_endOfTomorrow());
  var _index59 = _interopRequireDefault(require_endOfWeek());
  var _index60 = _interopRequireDefault(require_endOfYear());
  var _index61 = _interopRequireDefault(require_endOfYesterday());
  var _index62 = _interopRequireDefault(require_format2());
  var _index63 = _interopRequireDefault(require_formatDistance2());
  var _index64 = _interopRequireDefault(require_formatDistanceStrict());
  var _index65 = _interopRequireDefault(require_formatDistanceToNow());
  var _index66 = _interopRequireDefault(require_formatDistanceToNowStrict());
  var _index67 = _interopRequireDefault(require_formatDuration());
  var _index68 = _interopRequireDefault(require_formatISO());
  var _index69 = _interopRequireDefault(require_formatISO9075());
  var _index70 = _interopRequireDefault(require_formatISODuration());
  var _index71 = _interopRequireDefault(require_formatRFC3339());
  var _index72 = _interopRequireDefault(require_formatRFC7231());
  var _index73 = _interopRequireDefault(require_formatRelative2());
  var _index74 = _interopRequireDefault(require_fromUnixTime());
  var _index75 = _interopRequireDefault(require_getDate());
  var _index76 = _interopRequireDefault(require_getDay());
  var _index77 = _interopRequireDefault(require_getDayOfYear());
  var _index78 = _interopRequireDefault(require_getDaysInMonth());
  var _index79 = _interopRequireDefault(require_getDaysInYear());
  var _index80 = _interopRequireDefault(require_getDecade());
  var _index81 = _interopRequireDefault(require_getDefaultOptions());
  var _index82 = _interopRequireDefault(require_getHours());
  var _index83 = _interopRequireDefault(require_getISODay());
  var _index84 = _interopRequireDefault(require_getISOWeek());
  var _index85 = _interopRequireDefault(require_getISOWeekYear());
  var _index86 = _interopRequireDefault(require_getISOWeeksInYear());
  var _index87 = _interopRequireDefault(require_getMilliseconds());
  var _index88 = _interopRequireDefault(require_getMinutes());
  var _index89 = _interopRequireDefault(require_getMonth());
  var _index90 = _interopRequireDefault(require_getOverlappingDaysInIntervals());
  var _index91 = _interopRequireDefault(require_getQuarter());
  var _index92 = _interopRequireDefault(require_getSeconds());
  var _index93 = _interopRequireDefault(require_getTime());
  var _index94 = _interopRequireDefault(require_getUnixTime());
  var _index95 = _interopRequireDefault(require_getWeek());
  var _index96 = _interopRequireDefault(require_getWeekOfMonth());
  var _index97 = _interopRequireDefault(require_getWeekYear());
  var _index98 = _interopRequireDefault(require_getWeeksInMonth());
  var _index99 = _interopRequireDefault(require_getYear());
  var _index100 = _interopRequireDefault(require_hoursToMilliseconds());
  var _index101 = _interopRequireDefault(require_hoursToMinutes());
  var _index102 = _interopRequireDefault(require_hoursToSeconds());
  var _index103 = _interopRequireDefault(require_intervalToDuration());
  var _index104 = _interopRequireDefault(require_intlFormat());
  var _index105 = _interopRequireDefault(require_intlFormatDistance());
  var _index106 = _interopRequireDefault(require_isAfter());
  var _index107 = _interopRequireDefault(require_isBefore());
  var _index108 = _interopRequireDefault(require_isDate());
  var _index109 = _interopRequireDefault(require_isEqual());
  var _index110 = _interopRequireDefault(require_isExists());
  var _index111 = _interopRequireDefault(require_isFirstDayOfMonth());
  var _index112 = _interopRequireDefault(require_isFriday());
  var _index113 = _interopRequireDefault(require_isFuture());
  var _index114 = _interopRequireDefault(require_isLastDayOfMonth());
  var _index115 = _interopRequireDefault(require_isLeapYear());
  var _index116 = _interopRequireDefault(require_isMatch());
  var _index117 = _interopRequireDefault(require_isMonday());
  var _index118 = _interopRequireDefault(require_isPast());
  var _index119 = _interopRequireDefault(require_isSameDay());
  var _index120 = _interopRequireDefault(require_isSameHour());
  var _index121 = _interopRequireDefault(require_isSameISOWeek());
  var _index122 = _interopRequireDefault(require_isSameISOWeekYear());
  var _index123 = _interopRequireDefault(require_isSameMinute());
  var _index124 = _interopRequireDefault(require_isSameMonth());
  var _index125 = _interopRequireDefault(require_isSameQuarter());
  var _index126 = _interopRequireDefault(require_isSameSecond());
  var _index127 = _interopRequireDefault(require_isSameWeek());
  var _index128 = _interopRequireDefault(require_isSameYear());
  var _index129 = _interopRequireDefault(require_isSaturday());
  var _index130 = _interopRequireDefault(require_isSunday());
  var _index131 = _interopRequireDefault(require_isThisHour());
  var _index132 = _interopRequireDefault(require_isThisISOWeek());
  var _index133 = _interopRequireDefault(require_isThisMinute());
  var _index134 = _interopRequireDefault(require_isThisMonth());
  var _index135 = _interopRequireDefault(require_isThisQuarter());
  var _index136 = _interopRequireDefault(require_isThisSecond());
  var _index137 = _interopRequireDefault(require_isThisWeek());
  var _index138 = _interopRequireDefault(require_isThisYear());
  var _index139 = _interopRequireDefault(require_isThursday());
  var _index140 = _interopRequireDefault(require_isToday());
  var _index141 = _interopRequireDefault(require_isTomorrow());
  var _index142 = _interopRequireDefault(require_isTuesday());
  var _index143 = _interopRequireDefault(require_isValid());
  var _index144 = _interopRequireDefault(require_isWednesday());
  var _index145 = _interopRequireDefault(require_isWeekend());
  var _index146 = _interopRequireDefault(require_isWithinInterval());
  var _index147 = _interopRequireDefault(require_isYesterday());
  var _index148 = _interopRequireDefault(require_lastDayOfDecade());
  var _index149 = _interopRequireDefault(require_lastDayOfISOWeek());
  var _index150 = _interopRequireDefault(require_lastDayOfISOWeekYear());
  var _index151 = _interopRequireDefault(require_lastDayOfMonth());
  var _index152 = _interopRequireDefault(require_lastDayOfQuarter());
  var _index153 = _interopRequireDefault(require_lastDayOfWeek());
  var _index154 = _interopRequireDefault(require_lastDayOfYear());
  var _index155 = _interopRequireDefault(require_lightFormat());
  var _index156 = _interopRequireDefault(require_max());
  var _index157 = _interopRequireDefault(require_milliseconds());
  var _index158 = _interopRequireDefault(require_millisecondsToHours());
  var _index159 = _interopRequireDefault(require_millisecondsToMinutes());
  var _index160 = _interopRequireDefault(require_millisecondsToSeconds());
  var _index161 = _interopRequireDefault(require_min());
  var _index162 = _interopRequireDefault(require_minutesToHours());
  var _index163 = _interopRequireDefault(require_minutesToMilliseconds());
  var _index164 = _interopRequireDefault(require_minutesToSeconds());
  var _index165 = _interopRequireDefault(require_monthsToQuarters());
  var _index166 = _interopRequireDefault(require_monthsToYears());
  var _index167 = _interopRequireDefault(require_nextDay());
  var _index168 = _interopRequireDefault(require_nextFriday());
  var _index169 = _interopRequireDefault(require_nextMonday());
  var _index170 = _interopRequireDefault(require_nextSaturday());
  var _index171 = _interopRequireDefault(require_nextSunday());
  var _index172 = _interopRequireDefault(require_nextThursday());
  var _index173 = _interopRequireDefault(require_nextTuesday());
  var _index174 = _interopRequireDefault(require_nextWednesday());
  var _index175 = _interopRequireDefault(require_parse3());
  var _index176 = _interopRequireDefault(require_parseISO());
  var _index177 = _interopRequireDefault(require_parseJSON());
  var _index178 = _interopRequireDefault(require_previousDay());
  var _index179 = _interopRequireDefault(require_previousFriday());
  var _index180 = _interopRequireDefault(require_previousMonday());
  var _index181 = _interopRequireDefault(require_previousSaturday());
  var _index182 = _interopRequireDefault(require_previousSunday());
  var _index183 = _interopRequireDefault(require_previousThursday());
  var _index184 = _interopRequireDefault(require_previousTuesday());
  var _index185 = _interopRequireDefault(require_previousWednesday());
  var _index186 = _interopRequireDefault(require_quartersToMonths());
  var _index187 = _interopRequireDefault(require_quartersToYears());
  var _index188 = _interopRequireDefault(require_roundToNearestMinutes());
  var _index189 = _interopRequireDefault(require_secondsToHours());
  var _index190 = _interopRequireDefault(require_secondsToMilliseconds());
  var _index191 = _interopRequireDefault(require_secondsToMinutes());
  var _index192 = _interopRequireDefault(require_set2());
  var _index193 = _interopRequireDefault(require_setDate());
  var _index194 = _interopRequireDefault(require_setDay());
  var _index195 = _interopRequireDefault(require_setDayOfYear());
  var _index196 = _interopRequireDefault(require_setDefaultOptions());
  var _index197 = _interopRequireDefault(require_setHours());
  var _index198 = _interopRequireDefault(require_setISODay());
  var _index199 = _interopRequireDefault(require_setISOWeek());
  var _index200 = _interopRequireDefault(require_setISOWeekYear());
  var _index201 = _interopRequireDefault(require_setMilliseconds());
  var _index202 = _interopRequireDefault(require_setMinutes());
  var _index203 = _interopRequireDefault(require_setMonth());
  var _index204 = _interopRequireDefault(require_setQuarter());
  var _index205 = _interopRequireDefault(require_setSeconds());
  var _index206 = _interopRequireDefault(require_setWeek());
  var _index207 = _interopRequireDefault(require_setWeekYear());
  var _index208 = _interopRequireDefault(require_setYear());
  var _index209 = _interopRequireDefault(require_startOfDay());
  var _index210 = _interopRequireDefault(require_startOfDecade());
  var _index211 = _interopRequireDefault(require_startOfHour());
  var _index212 = _interopRequireDefault(require_startOfISOWeek());
  var _index213 = _interopRequireDefault(require_startOfISOWeekYear());
  var _index214 = _interopRequireDefault(require_startOfMinute());
  var _index215 = _interopRequireDefault(require_startOfMonth());
  var _index216 = _interopRequireDefault(require_startOfQuarter());
  var _index217 = _interopRequireDefault(require_startOfSecond());
  var _index218 = _interopRequireDefault(require_startOfToday());
  var _index219 = _interopRequireDefault(require_startOfTomorrow());
  var _index220 = _interopRequireDefault(require_startOfWeek());
  var _index221 = _interopRequireDefault(require_startOfWeekYear());
  var _index222 = _interopRequireDefault(require_startOfYear());
  var _index223 = _interopRequireDefault(require_startOfYesterday());
  var _index224 = _interopRequireDefault(require_sub());
  var _index225 = _interopRequireDefault(require_subBusinessDays());
  var _index226 = _interopRequireDefault(require_subDays());
  var _index227 = _interopRequireDefault(require_subHours());
  var _index228 = _interopRequireDefault(require_subISOWeekYears());
  var _index229 = _interopRequireDefault(require_subMilliseconds());
  var _index230 = _interopRequireDefault(require_subMinutes());
  var _index231 = _interopRequireDefault(require_subMonths());
  var _index232 = _interopRequireDefault(require_subQuarters());
  var _index233 = _interopRequireDefault(require_subSeconds());
  var _index234 = _interopRequireDefault(require_subWeeks());
  var _index235 = _interopRequireDefault(require_subYears());
  var _index236 = _interopRequireDefault(require_toDate());
  var _index237 = _interopRequireDefault(require_weeksToDays());
  var _index238 = _interopRequireDefault(require_yearsToMonths());
  var _index239 = _interopRequireDefault(require_yearsToQuarters());
  var _index240 = require_constants3();
  Object.keys(_index240).forEach(function(key) {
    if (key === "default" || key === "__esModule")
      return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key))
      return;
    if (key in exports && exports[key] === _index240[key])
      return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _index240[key];
      }
    });
  });
});

// node_modules/web-streams-polyfill/dist/ponyfill.es2018.js
var require_ponyfill_es2018 = __commonJS((exports, module) => {
  (function(global2, factory) {
    typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.WebStreamsPolyfill = {}));
  })(exports, function(exports2) {
    function noop() {
      return;
    }
    function typeIsObject(x) {
      return typeof x === "object" && x !== null || typeof x === "function";
    }
    const rethrowAssertionErrorRejection = noop;
    function setFunctionName(fn, name) {
      try {
        Object.defineProperty(fn, "name", {
          value: name,
          configurable: true
        });
      } catch (_a2) {}
    }
    const originalPromise = Promise;
    const originalPromiseThen = Promise.prototype.then;
    const originalPromiseReject = Promise.reject.bind(originalPromise);
    function newPromise(executor) {
      return new originalPromise(executor);
    }
    function promiseResolvedWith(value2) {
      return newPromise((resolve) => resolve(value2));
    }
    function promiseRejectedWith(reason) {
      return originalPromiseReject(reason);
    }
    function PerformPromiseThen(promise3, onFulfilled, onRejected) {
      return originalPromiseThen.call(promise3, onFulfilled, onRejected);
    }
    function uponPromise(promise3, onFulfilled, onRejected) {
      PerformPromiseThen(PerformPromiseThen(promise3, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
    }
    function uponFulfillment(promise3, onFulfilled) {
      uponPromise(promise3, onFulfilled);
    }
    function uponRejection(promise3, onRejected) {
      uponPromise(promise3, undefined, onRejected);
    }
    function transformPromiseWith(promise3, fulfillmentHandler, rejectionHandler) {
      return PerformPromiseThen(promise3, fulfillmentHandler, rejectionHandler);
    }
    function setPromiseIsHandledToTrue(promise3) {
      PerformPromiseThen(promise3, undefined, rethrowAssertionErrorRejection);
    }
    let _queueMicrotask = (callback) => {
      if (typeof queueMicrotask === "function") {
        _queueMicrotask = queueMicrotask;
      } else {
        const resolvedPromise = promiseResolvedWith(undefined);
        _queueMicrotask = (cb) => PerformPromiseThen(resolvedPromise, cb);
      }
      return _queueMicrotask(callback);
    };
    function reflectCall(F, V, args) {
      if (typeof F !== "function") {
        throw new TypeError("Argument is not a function");
      }
      return Function.prototype.apply.call(F, V, args);
    }
    function promiseCall(F, V, args) {
      try {
        return promiseResolvedWith(reflectCall(F, V, args));
      } catch (value2) {
        return promiseRejectedWith(value2);
      }
    }
    const QUEUE_MAX_ARRAY_SIZE = 16384;

    class SimpleQueue {
      constructor() {
        this._cursor = 0;
        this._size = 0;
        this._front = {
          _elements: [],
          _next: undefined
        };
        this._back = this._front;
        this._cursor = 0;
        this._size = 0;
      }
      get length() {
        return this._size;
      }
      push(element) {
        const oldBack = this._back;
        let newBack = oldBack;
        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
          newBack = {
            _elements: [],
            _next: undefined
          };
        }
        oldBack._elements.push(element);
        if (newBack !== oldBack) {
          this._back = newBack;
          oldBack._next = newBack;
        }
        ++this._size;
      }
      shift() {
        const oldFront = this._front;
        let newFront = oldFront;
        const oldCursor = this._cursor;
        let newCursor = oldCursor + 1;
        const elements = oldFront._elements;
        const element = elements[oldCursor];
        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
          newFront = oldFront._next;
          newCursor = 0;
        }
        --this._size;
        this._cursor = newCursor;
        if (oldFront !== newFront) {
          this._front = newFront;
        }
        elements[oldCursor] = undefined;
        return element;
      }
      forEach(callback) {
        let i = this._cursor;
        let node = this._front;
        let elements = node._elements;
        while (i !== elements.length || node._next !== undefined) {
          if (i === elements.length) {
            node = node._next;
            elements = node._elements;
            i = 0;
            if (elements.length === 0) {
              break;
            }
          }
          callback(elements[i]);
          ++i;
        }
      }
      peek() {
        const front = this._front;
        const cursor = this._cursor;
        return front._elements[cursor];
      }
    }
    const AbortSteps = Symbol("[[AbortSteps]]");
    const ErrorSteps = Symbol("[[ErrorSteps]]");
    const CancelSteps = Symbol("[[CancelSteps]]");
    const PullSteps = Symbol("[[PullSteps]]");
    const ReleaseSteps = Symbol("[[ReleaseSteps]]");
    function ReadableStreamReaderGenericInitialize(reader, stream) {
      reader._ownerReadableStream = stream;
      stream._reader = reader;
      if (stream._state === "readable") {
        defaultReaderClosedPromiseInitialize(reader);
      } else if (stream._state === "closed") {
        defaultReaderClosedPromiseInitializeAsResolved(reader);
      } else {
        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
      }
    }
    function ReadableStreamReaderGenericCancel(reader, reason) {
      const stream = reader._ownerReadableStream;
      return ReadableStreamCancel(stream, reason);
    }
    function ReadableStreamReaderGenericRelease(reader) {
      const stream = reader._ownerReadableStream;
      if (stream._state === "readable") {
        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
      } else {
        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
      }
      stream._readableStreamController[ReleaseSteps]();
      stream._reader = undefined;
      reader._ownerReadableStream = undefined;
    }
    function readerLockException(name) {
      return new TypeError("Cannot " + name + " a stream using a released reader");
    }
    function defaultReaderClosedPromiseInitialize(reader) {
      reader._closedPromise = newPromise((resolve, reject) => {
        reader._closedPromise_resolve = resolve;
        reader._closedPromise_reject = reject;
      });
    }
    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
      defaultReaderClosedPromiseInitialize(reader);
      defaultReaderClosedPromiseReject(reader, reason);
    }
    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
      defaultReaderClosedPromiseInitialize(reader);
      defaultReaderClosedPromiseResolve(reader);
    }
    function defaultReaderClosedPromiseReject(reader, reason) {
      if (reader._closedPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(reader._closedPromise);
      reader._closedPromise_reject(reason);
      reader._closedPromise_resolve = undefined;
      reader._closedPromise_reject = undefined;
    }
    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
      defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
    }
    function defaultReaderClosedPromiseResolve(reader) {
      if (reader._closedPromise_resolve === undefined) {
        return;
      }
      reader._closedPromise_resolve(undefined);
      reader._closedPromise_resolve = undefined;
      reader._closedPromise_reject = undefined;
    }
    const NumberIsFinite = Number.isFinite || function(x) {
      return typeof x === "number" && isFinite(x);
    };
    const MathTrunc = Math.trunc || function(v) {
      return v < 0 ? Math.ceil(v) : Math.floor(v);
    };
    function isDictionary(x) {
      return typeof x === "object" || typeof x === "function";
    }
    function assertDictionary(obj, context) {
      if (obj !== undefined && !isDictionary(obj)) {
        throw new TypeError(`${context} is not an object.`);
      }
    }
    function assertFunction(x, context) {
      if (typeof x !== "function") {
        throw new TypeError(`${context} is not a function.`);
      }
    }
    function isObject2(x) {
      return typeof x === "object" && x !== null || typeof x === "function";
    }
    function assertObject(x, context) {
      if (!isObject2(x)) {
        throw new TypeError(`${context} is not an object.`);
      }
    }
    function assertRequiredArgument(x, position, context) {
      if (x === undefined) {
        throw new TypeError(`Parameter ${position} is required in '${context}'.`);
      }
    }
    function assertRequiredField(x, field, context) {
      if (x === undefined) {
        throw new TypeError(`${field} is required in '${context}'.`);
      }
    }
    function convertUnrestrictedDouble(value2) {
      return Number(value2);
    }
    function censorNegativeZero(x) {
      return x === 0 ? 0 : x;
    }
    function integerPart(x) {
      return censorNegativeZero(MathTrunc(x));
    }
    function convertUnsignedLongLongWithEnforceRange(value2, context) {
      const lowerBound = 0;
      const upperBound = Number.MAX_SAFE_INTEGER;
      let x = Number(value2);
      x = censorNegativeZero(x);
      if (!NumberIsFinite(x)) {
        throw new TypeError(`${context} is not a finite number`);
      }
      x = integerPart(x);
      if (x < lowerBound || x > upperBound) {
        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
      }
      if (!NumberIsFinite(x) || x === 0) {
        return 0;
      }
      return x;
    }
    function assertReadableStream(x, context) {
      if (!IsReadableStream(x)) {
        throw new TypeError(`${context} is not a ReadableStream.`);
      }
    }
    function AcquireReadableStreamDefaultReader(stream) {
      return new ReadableStreamDefaultReader(stream);
    }
    function ReadableStreamAddReadRequest(stream, readRequest) {
      stream._reader._readRequests.push(readRequest);
    }
    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
      const reader = stream._reader;
      const readRequest = reader._readRequests.shift();
      if (done) {
        readRequest._closeSteps();
      } else {
        readRequest._chunkSteps(chunk);
      }
    }
    function ReadableStreamGetNumReadRequests(stream) {
      return stream._reader._readRequests.length;
    }
    function ReadableStreamHasDefaultReader(stream) {
      const reader = stream._reader;
      if (reader === undefined) {
        return false;
      }
      if (!IsReadableStreamDefaultReader(reader)) {
        return false;
      }
      return true;
    }

    class ReadableStreamDefaultReader {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamDefaultReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readRequests = new SimpleQueue;
      }
      get closed() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      cancel(reason = undefined) {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      }
      read() {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException("read"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise3 = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readRequest = {
          _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
          _closeSteps: () => resolvePromise({ value: undefined, done: true }),
          _errorSteps: (e) => rejectPromise(e)
        };
        ReadableStreamDefaultReaderRead(this, readRequest);
        return promise3;
      }
      releaseLock() {
        if (!IsReadableStreamDefaultReader(this)) {
          throw defaultReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === undefined) {
          return;
        }
        ReadableStreamDefaultReaderRelease(this);
      }
    }
    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultReader.prototype.cancel, "cancel");
    setFunctionName(ReadableStreamDefaultReader.prototype.read, "read");
    setFunctionName(ReadableStreamDefaultReader.prototype.releaseLock, "releaseLock");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, {
        value: "ReadableStreamDefaultReader",
        configurable: true
      });
    }
    function IsReadableStreamDefaultReader(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_readRequests")) {
        return false;
      }
      return x instanceof ReadableStreamDefaultReader;
    }
    function ReadableStreamDefaultReaderRead(reader, readRequest) {
      const stream = reader._ownerReadableStream;
      stream._disturbed = true;
      if (stream._state === "closed") {
        readRequest._closeSteps();
      } else if (stream._state === "errored") {
        readRequest._errorSteps(stream._storedError);
      } else {
        stream._readableStreamController[PullSteps](readRequest);
      }
    }
    function ReadableStreamDefaultReaderRelease(reader) {
      ReadableStreamReaderGenericRelease(reader);
      const e = new TypeError("Reader was released");
      ReadableStreamDefaultReaderErrorReadRequests(reader, e);
    }
    function ReadableStreamDefaultReaderErrorReadRequests(reader, e) {
      const readRequests = reader._readRequests;
      reader._readRequests = new SimpleQueue;
      readRequests.forEach((readRequest) => {
        readRequest._errorSteps(e);
      });
    }
    function defaultReaderBrandCheckException(name) {
      return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
    }
    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () {}).prototype);

    class ReadableStreamAsyncIteratorImpl {
      constructor(reader, preventCancel) {
        this._ongoingPromise = undefined;
        this._isFinished = false;
        this._reader = reader;
        this._preventCancel = preventCancel;
      }
      next() {
        const nextSteps = () => this._nextSteps();
        this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
        return this._ongoingPromise;
      }
      return(value2) {
        const returnSteps = () => this._returnSteps(value2);
        return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
      }
      _nextSteps() {
        if (this._isFinished) {
          return Promise.resolve({ value: undefined, done: true });
        }
        const reader = this._reader;
        let resolvePromise;
        let rejectPromise;
        const promise3 = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readRequest = {
          _chunkSteps: (chunk) => {
            this._ongoingPromise = undefined;
            _queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
          },
          _closeSteps: () => {
            this._ongoingPromise = undefined;
            this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            resolvePromise({ value: undefined, done: true });
          },
          _errorSteps: (reason) => {
            this._ongoingPromise = undefined;
            this._isFinished = true;
            ReadableStreamReaderGenericRelease(reader);
            rejectPromise(reason);
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promise3;
      }
      _returnSteps(value2) {
        if (this._isFinished) {
          return Promise.resolve({ value: value2, done: true });
        }
        this._isFinished = true;
        const reader = this._reader;
        if (!this._preventCancel) {
          const result = ReadableStreamReaderGenericCancel(reader, value2);
          ReadableStreamReaderGenericRelease(reader);
          return transformPromiseWith(result, () => ({ value: value2, done: true }));
        }
        ReadableStreamReaderGenericRelease(reader);
        return promiseResolvedWith({ value: value2, done: true });
      }
    }
    const ReadableStreamAsyncIteratorPrototype = {
      next() {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("next"));
        }
        return this._asyncIteratorImpl.next();
      },
      return(value2) {
        if (!IsReadableStreamAsyncIterator(this)) {
          return promiseRejectedWith(streamAsyncIteratorBrandCheckException("return"));
        }
        return this._asyncIteratorImpl.return(value2);
      }
    };
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
      const iterator3 = Object.create(ReadableStreamAsyncIteratorPrototype);
      iterator3._asyncIteratorImpl = impl;
      return iterator3;
    }
    function IsReadableStreamAsyncIterator(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_asyncIteratorImpl")) {
        return false;
      }
      try {
        return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
      } catch (_a2) {
        return false;
      }
    }
    function streamAsyncIteratorBrandCheckException(name) {
      return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
    }
    const NumberIsNaN = Number.isNaN || function(x) {
      return x !== x;
    };
    var _a, _b, _c;
    function CreateArrayFromList(elements) {
      return elements.slice();
    }
    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
      new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
    }
    let TransferArrayBuffer = (O) => {
      if (typeof O.transfer === "function") {
        TransferArrayBuffer = (buffer) => buffer.transfer();
      } else if (typeof structuredClone === "function") {
        TransferArrayBuffer = (buffer) => structuredClone(buffer, { transfer: [buffer] });
      } else {
        TransferArrayBuffer = (buffer) => buffer;
      }
      return TransferArrayBuffer(O);
    };
    let IsDetachedBuffer = (O) => {
      if (typeof O.detached === "boolean") {
        IsDetachedBuffer = (buffer) => buffer.detached;
      } else {
        IsDetachedBuffer = (buffer) => buffer.byteLength === 0;
      }
      return IsDetachedBuffer(O);
    };
    function ArrayBufferSlice(buffer, begin, end) {
      if (buffer.slice) {
        return buffer.slice(begin, end);
      }
      const length = end - begin;
      const slice = new ArrayBuffer(length);
      CopyDataBlockBytes(slice, 0, buffer, begin, length);
      return slice;
    }
    function GetMethod(receiver, prop) {
      const func = receiver[prop];
      if (func === undefined || func === null) {
        return;
      }
      if (typeof func !== "function") {
        throw new TypeError(`${String(prop)} is not a function`);
      }
      return func;
    }
    function CreateAsyncFromSyncIterator(syncIteratorRecord) {
      const syncIterable = {
        [Symbol.iterator]: () => syncIteratorRecord.iterator
      };
      const asyncIterator = async function* () {
        return yield* syncIterable;
      }();
      const nextMethod = asyncIterator.next;
      return { iterator: asyncIterator, nextMethod, done: false };
    }
    const SymbolAsyncIterator = (_c = (_a = Symbol.asyncIterator) !== null && _a !== undefined ? _a : (_b = Symbol.for) === null || _b === undefined ? undefined : _b.call(Symbol, "Symbol.asyncIterator")) !== null && _c !== undefined ? _c : "@@asyncIterator";
    function GetIterator(obj, hint = "sync", method) {
      if (method === undefined) {
        if (hint === "async") {
          method = GetMethod(obj, SymbolAsyncIterator);
          if (method === undefined) {
            const syncMethod = GetMethod(obj, Symbol.iterator);
            const syncIteratorRecord = GetIterator(obj, "sync", syncMethod);
            return CreateAsyncFromSyncIterator(syncIteratorRecord);
          }
        } else {
          method = GetMethod(obj, Symbol.iterator);
        }
      }
      if (method === undefined) {
        throw new TypeError("The object is not iterable");
      }
      const iterator3 = reflectCall(method, obj, []);
      if (!typeIsObject(iterator3)) {
        throw new TypeError("The iterator method must return an object");
      }
      const nextMethod = iterator3.next;
      return { iterator: iterator3, nextMethod, done: false };
    }
    function IteratorNext(iteratorRecord) {
      const result = reflectCall(iteratorRecord.nextMethod, iteratorRecord.iterator, []);
      if (!typeIsObject(result)) {
        throw new TypeError("The iterator.next() method must return an object");
      }
      return result;
    }
    function IteratorComplete(iterResult) {
      return Boolean(iterResult.done);
    }
    function IteratorValue(iterResult) {
      return iterResult.value;
    }
    function IsNonNegativeNumber(v) {
      if (typeof v !== "number") {
        return false;
      }
      if (NumberIsNaN(v)) {
        return false;
      }
      if (v < 0) {
        return false;
      }
      return true;
    }
    function CloneAsUint8Array(O) {
      const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
      return new Uint8Array(buffer);
    }
    function DequeueValue(container) {
      const pair = container._queue.shift();
      container._queueTotalSize -= pair.size;
      if (container._queueTotalSize < 0) {
        container._queueTotalSize = 0;
      }
      return pair.value;
    }
    function EnqueueValueWithSize(container, value2, size) {
      if (!IsNonNegativeNumber(size) || size === Infinity) {
        throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
      }
      container._queue.push({ value: value2, size });
      container._queueTotalSize += size;
    }
    function PeekQueueValue(container) {
      const pair = container._queue.peek();
      return pair.value;
    }
    function ResetQueue(container) {
      container._queue = new SimpleQueue;
      container._queueTotalSize = 0;
    }
    function isDataViewConstructor(ctor) {
      return ctor === DataView;
    }
    function isDataView(view) {
      return isDataViewConstructor(view.constructor);
    }
    function arrayBufferViewElementSize(ctor) {
      if (isDataViewConstructor(ctor)) {
        return 1;
      }
      return ctor.BYTES_PER_ELEMENT;
    }

    class ReadableStreamBYOBRequest {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get view() {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("view");
        }
        return this._view;
      }
      respond(bytesWritten) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respond");
        }
        assertRequiredArgument(bytesWritten, 1, "respond");
        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, "First parameter");
        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(this._view.buffer)) {
          throw new TypeError(`The BYOB request's buffer has been detached and so cannot be used as a response`);
        }
        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
      }
      respondWithNewView(view) {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException("respondWithNewView");
        }
        assertRequiredArgument(view, 1, "respondWithNewView");
        if (!ArrayBuffer.isView(view)) {
          throw new TypeError("You can only respond with array buffer views");
        }
        if (this._associatedReadableByteStreamController === undefined) {
          throw new TypeError("This BYOB request has been invalidated");
        }
        if (IsDetachedBuffer(view.buffer)) {
          throw new TypeError("The given view's buffer has been detached and so cannot be used as a response");
        }
        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
      }
    }
    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
      respond: { enumerable: true },
      respondWithNewView: { enumerable: true },
      view: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBRequest.prototype.respond, "respond");
    setFunctionName(ReadableStreamBYOBRequest.prototype.respondWithNewView, "respondWithNewView");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, {
        value: "ReadableStreamBYOBRequest",
        configurable: true
      });
    }

    class ReadableByteStreamController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get byobRequest() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("byobRequest");
        }
        return ReadableByteStreamControllerGetBYOBRequest(this);
      }
      get desiredSize() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("desiredSize");
        }
        return ReadableByteStreamControllerGetDesiredSize(this);
      }
      close() {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("close");
        }
        if (this._closeRequested) {
          throw new TypeError("The stream has already been closed; do not close it again!");
        }
        const state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
        }
        ReadableByteStreamControllerClose(this);
      }
      enqueue(chunk) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("enqueue");
        }
        assertRequiredArgument(chunk, 1, "enqueue");
        if (!ArrayBuffer.isView(chunk)) {
          throw new TypeError("chunk must be an array buffer view");
        }
        if (chunk.byteLength === 0) {
          throw new TypeError("chunk must have non-zero byteLength");
        }
        if (chunk.buffer.byteLength === 0) {
          throw new TypeError(`chunk's buffer must have non-zero byteLength`);
        }
        if (this._closeRequested) {
          throw new TypeError("stream is closed or draining");
        }
        const state = this._controlledReadableByteStream._state;
        if (state !== "readable") {
          throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
        }
        ReadableByteStreamControllerEnqueue(this, chunk);
      }
      error(e = undefined) {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException("error");
        }
        ReadableByteStreamControllerError(this, e);
      }
      [CancelSteps](reason) {
        ReadableByteStreamControllerClearPendingPullIntos(this);
        ResetQueue(this);
        const result = this._cancelAlgorithm(reason);
        ReadableByteStreamControllerClearAlgorithms(this);
        return result;
      }
      [PullSteps](readRequest) {
        const stream = this._controlledReadableByteStream;
        if (this._queueTotalSize > 0) {
          ReadableByteStreamControllerFillReadRequestFromQueue(this, readRequest);
          return;
        }
        const autoAllocateChunkSize = this._autoAllocateChunkSize;
        if (autoAllocateChunkSize !== undefined) {
          let buffer;
          try {
            buffer = new ArrayBuffer(autoAllocateChunkSize);
          } catch (bufferE) {
            readRequest._errorSteps(bufferE);
            return;
          }
          const pullIntoDescriptor = {
            buffer,
            bufferByteLength: autoAllocateChunkSize,
            byteOffset: 0,
            byteLength: autoAllocateChunkSize,
            bytesFilled: 0,
            minimumFill: 1,
            elementSize: 1,
            viewConstructor: Uint8Array,
            readerType: "default"
          };
          this._pendingPullIntos.push(pullIntoDescriptor);
        }
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableByteStreamControllerCallPullIfNeeded(this);
      }
      [ReleaseSteps]() {
        if (this._pendingPullIntos.length > 0) {
          const firstPullInto = this._pendingPullIntos.peek();
          firstPullInto.readerType = "none";
          this._pendingPullIntos = new SimpleQueue;
          this._pendingPullIntos.push(firstPullInto);
        }
      }
    }
    Object.defineProperties(ReadableByteStreamController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      byobRequest: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableByteStreamController.prototype.close, "close");
    setFunctionName(ReadableByteStreamController.prototype.enqueue, "enqueue");
    setFunctionName(ReadableByteStreamController.prototype.error, "error");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, {
        value: "ReadableByteStreamController",
        configurable: true
      });
    }
    function IsReadableByteStreamController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableByteStream")) {
        return false;
      }
      return x instanceof ReadableByteStreamController;
    }
    function IsReadableStreamBYOBRequest(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_associatedReadableByteStreamController")) {
        return false;
      }
      return x instanceof ReadableStreamBYOBRequest;
    }
    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
      const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
      if (!shouldPull) {
        return;
      }
      if (controller._pulling) {
        controller._pullAgain = true;
        return;
      }
      controller._pulling = true;
      const pullPromise = controller._pullAlgorithm();
      uponPromise(pullPromise, () => {
        controller._pulling = false;
        if (controller._pullAgain) {
          controller._pullAgain = false;
          ReadableByteStreamControllerCallPullIfNeeded(controller);
        }
        return null;
      }, (e) => {
        ReadableByteStreamControllerError(controller, e);
        return null;
      });
    }
    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      controller._pendingPullIntos = new SimpleQueue;
    }
    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
      let done = false;
      if (stream._state === "closed") {
        done = true;
      }
      const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
      if (pullIntoDescriptor.readerType === "default") {
        ReadableStreamFulfillReadRequest(stream, filledView, done);
      } else {
        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
      }
    }
    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
      const bytesFilled = pullIntoDescriptor.bytesFilled;
      const elementSize = pullIntoDescriptor.elementSize;
      return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
    }
    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
      controller._queue.push({ buffer, byteOffset, byteLength });
      controller._queueTotalSize += byteLength;
    }
    function ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, buffer, byteOffset, byteLength) {
      let clonedChunk;
      try {
        clonedChunk = ArrayBufferSlice(buffer, byteOffset, byteOffset + byteLength);
      } catch (cloneE) {
        ReadableByteStreamControllerError(controller, cloneE);
        throw cloneE;
      }
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, clonedChunk, 0, byteLength);
    }
    function ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstDescriptor) {
      if (firstDescriptor.bytesFilled > 0) {
        ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, firstDescriptor.buffer, firstDescriptor.byteOffset, firstDescriptor.bytesFilled);
      }
      ReadableByteStreamControllerShiftPendingPullInto(controller);
    }
    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
      const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
      const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
      let totalBytesToCopyRemaining = maxBytesToCopy;
      let ready = false;
      const remainderBytes = maxBytesFilled % pullIntoDescriptor.elementSize;
      const maxAlignedBytes = maxBytesFilled - remainderBytes;
      if (maxAlignedBytes >= pullIntoDescriptor.minimumFill) {
        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
        ready = true;
      }
      const queue = controller._queue;
      while (totalBytesToCopyRemaining > 0) {
        const headOfQueue = queue.peek();
        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
        if (headOfQueue.byteLength === bytesToCopy) {
          queue.shift();
        } else {
          headOfQueue.byteOffset += bytesToCopy;
          headOfQueue.byteLength -= bytesToCopy;
        }
        controller._queueTotalSize -= bytesToCopy;
        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
        totalBytesToCopyRemaining -= bytesToCopy;
      }
      return ready;
    }
    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
      pullIntoDescriptor.bytesFilled += size;
    }
    function ReadableByteStreamControllerHandleQueueDrain(controller) {
      if (controller._queueTotalSize === 0 && controller._closeRequested) {
        ReadableByteStreamControllerClearAlgorithms(controller);
        ReadableStreamClose(controller._controlledReadableByteStream);
      } else {
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }
    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
      if (controller._byobRequest === null) {
        return;
      }
      controller._byobRequest._associatedReadableByteStreamController = undefined;
      controller._byobRequest._view = null;
      controller._byobRequest = null;
    }
    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
      while (controller._pendingPullIntos.length > 0) {
        if (controller._queueTotalSize === 0) {
          return;
        }
        const pullIntoDescriptor = controller._pendingPullIntos.peek();
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
          ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
        }
      }
    }
    function ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller) {
      const reader = controller._controlledReadableByteStream._reader;
      while (reader._readRequests.length > 0) {
        if (controller._queueTotalSize === 0) {
          return;
        }
        const readRequest = reader._readRequests.shift();
        ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest);
      }
    }
    function ReadableByteStreamControllerPullInto(controller, view, min, readIntoRequest) {
      const stream = controller._controlledReadableByteStream;
      const ctor = view.constructor;
      const elementSize = arrayBufferViewElementSize(ctor);
      const { byteOffset, byteLength } = view;
      const minimumFill = min * elementSize;
      let buffer;
      try {
        buffer = TransferArrayBuffer(view.buffer);
      } catch (e) {
        readIntoRequest._errorSteps(e);
        return;
      }
      const pullIntoDescriptor = {
        buffer,
        bufferByteLength: buffer.byteLength,
        byteOffset,
        byteLength,
        bytesFilled: 0,
        minimumFill,
        elementSize,
        viewConstructor: ctor,
        readerType: "byob"
      };
      if (controller._pendingPullIntos.length > 0) {
        controller._pendingPullIntos.push(pullIntoDescriptor);
        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
        return;
      }
      if (stream._state === "closed") {
        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
        readIntoRequest._closeSteps(emptyView);
        return;
      }
      if (controller._queueTotalSize > 0) {
        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
          const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
          ReadableByteStreamControllerHandleQueueDrain(controller);
          readIntoRequest._chunkSteps(filledView);
          return;
        }
        if (controller._closeRequested) {
          const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
          ReadableByteStreamControllerError(controller, e);
          readIntoRequest._errorSteps(e);
          return;
        }
      }
      controller._pendingPullIntos.push(pullIntoDescriptor);
      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
      if (firstDescriptor.readerType === "none") {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
      }
      const stream = controller._controlledReadableByteStream;
      if (ReadableStreamHasBYOBReader(stream)) {
        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
          const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
          ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
        }
      }
    }
    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
      if (pullIntoDescriptor.readerType === "none") {
        ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, pullIntoDescriptor);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
        return;
      }
      if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.minimumFill) {
        return;
      }
      ReadableByteStreamControllerShiftPendingPullInto(controller);
      const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
      if (remainderSize > 0) {
        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
        ReadableByteStreamControllerEnqueueClonedChunkToQueue(controller, pullIntoDescriptor.buffer, end - remainderSize, remainderSize);
      }
      pullIntoDescriptor.bytesFilled -= remainderSize;
      ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    }
    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      ReadableByteStreamControllerInvalidateBYOBRequest(controller);
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);
      } else {
        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
      }
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
      const descriptor = controller._pendingPullIntos.shift();
      return descriptor;
    }
    function ReadableByteStreamControllerShouldCallPull(controller) {
      const stream = controller._controlledReadableByteStream;
      if (stream._state !== "readable") {
        return false;
      }
      if (controller._closeRequested) {
        return false;
      }
      if (!controller._started) {
        return false;
      }
      if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        return true;
      }
      if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        return true;
      }
      const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
      if (desiredSize > 0) {
        return true;
      }
      return false;
    }
    function ReadableByteStreamControllerClearAlgorithms(controller) {
      controller._pullAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
    }
    function ReadableByteStreamControllerClose(controller) {
      const stream = controller._controlledReadableByteStream;
      if (controller._closeRequested || stream._state !== "readable") {
        return;
      }
      if (controller._queueTotalSize > 0) {
        controller._closeRequested = true;
        return;
      }
      if (controller._pendingPullIntos.length > 0) {
        const firstPendingPullInto = controller._pendingPullIntos.peek();
        if (firstPendingPullInto.bytesFilled % firstPendingPullInto.elementSize !== 0) {
          const e = new TypeError("Insufficient bytes to fill elements in the given buffer");
          ReadableByteStreamControllerError(controller, e);
          throw e;
        }
      }
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamClose(stream);
    }
    function ReadableByteStreamControllerEnqueue(controller, chunk) {
      const stream = controller._controlledReadableByteStream;
      if (controller._closeRequested || stream._state !== "readable") {
        return;
      }
      const { buffer, byteOffset, byteLength } = chunk;
      if (IsDetachedBuffer(buffer)) {
        throw new TypeError("chunk's buffer is detached and so cannot be enqueued");
      }
      const transferredBuffer = TransferArrayBuffer(buffer);
      if (controller._pendingPullIntos.length > 0) {
        const firstPendingPullInto = controller._pendingPullIntos.peek();
        if (IsDetachedBuffer(firstPendingPullInto.buffer)) {
          throw new TypeError("The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk");
        }
        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
        firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
        if (firstPendingPullInto.readerType === "none") {
          ReadableByteStreamControllerEnqueueDetachedPullIntoToQueue(controller, firstPendingPullInto);
        }
      }
      if (ReadableStreamHasDefaultReader(stream)) {
        ReadableByteStreamControllerProcessReadRequestsUsingQueue(controller);
        if (ReadableStreamGetNumReadRequests(stream) === 0) {
          ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        } else {
          if (controller._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerShiftPendingPullInto(controller);
          }
          const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
          ReadableStreamFulfillReadRequest(stream, transferredView, false);
        }
      } else if (ReadableStreamHasBYOBReader(stream)) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
      } else {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      }
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
    function ReadableByteStreamControllerError(controller, e) {
      const stream = controller._controlledReadableByteStream;
      if (stream._state !== "readable") {
        return;
      }
      ReadableByteStreamControllerClearPendingPullIntos(controller);
      ResetQueue(controller);
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamError(stream, e);
    }
    function ReadableByteStreamControllerFillReadRequestFromQueue(controller, readRequest) {
      const entry = controller._queue.shift();
      controller._queueTotalSize -= entry.byteLength;
      ReadableByteStreamControllerHandleQueueDrain(controller);
      const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
      readRequest._chunkSteps(view);
    }
    function ReadableByteStreamControllerGetBYOBRequest(controller) {
      if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
        const firstDescriptor = controller._pendingPullIntos.peek();
        const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
        const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
        SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
        controller._byobRequest = byobRequest;
      }
      return controller._byobRequest;
    }
    function ReadableByteStreamControllerGetDesiredSize(controller) {
      const state = controller._controlledReadableByteStream._state;
      if (state === "errored") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        if (bytesWritten !== 0) {
          throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
        }
      } else {
        if (bytesWritten === 0) {
          throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");
        }
        if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
          throw new RangeError("bytesWritten out of range");
        }
      }
      firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
      ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
    }
    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
      const firstDescriptor = controller._pendingPullIntos.peek();
      const state = controller._controlledReadableByteStream._state;
      if (state === "closed") {
        if (view.byteLength !== 0) {
          throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream");
        }
      } else {
        if (view.byteLength === 0) {
          throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");
        }
      }
      if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
        throw new RangeError("The region specified by view does not match byobRequest");
      }
      if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
        throw new RangeError("The buffer of view has different capacity than byobRequest");
      }
      if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
        throw new RangeError("The region specified by view is larger than byobRequest");
      }
      const viewByteLength = view.byteLength;
      firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
      ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
    }
    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
      controller._controlledReadableByteStream = stream;
      controller._pullAgain = false;
      controller._pulling = false;
      controller._byobRequest = null;
      controller._queue = controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._closeRequested = false;
      controller._started = false;
      controller._strategyHWM = highWaterMark;
      controller._pullAlgorithm = pullAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      controller._autoAllocateChunkSize = autoAllocateChunkSize;
      controller._pendingPullIntos = new SimpleQueue;
      stream._readableStreamController = controller;
      const startResult = startAlgorithm();
      uponPromise(promiseResolvedWith(startResult), () => {
        controller._started = true;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
        return null;
      }, (r) => {
        ReadableByteStreamControllerError(controller, r);
        return null;
      });
    }
    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
      const controller = Object.create(ReadableByteStreamController.prototype);
      let startAlgorithm;
      let pullAlgorithm;
      let cancelAlgorithm;
      if (underlyingByteSource.start !== undefined) {
        startAlgorithm = () => underlyingByteSource.start(controller);
      } else {
        startAlgorithm = () => {
          return;
        };
      }
      if (underlyingByteSource.pull !== undefined) {
        pullAlgorithm = () => underlyingByteSource.pull(controller);
      } else {
        pullAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingByteSource.cancel !== undefined) {
        cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
      } else {
        cancelAlgorithm = () => promiseResolvedWith(undefined);
      }
      const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
      if (autoAllocateChunkSize === 0) {
        throw new TypeError("autoAllocateChunkSize must be greater than 0");
      }
      SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
    }
    function SetUpReadableStreamBYOBRequest(request, controller, view) {
      request._associatedReadableByteStreamController = controller;
      request._view = view;
    }
    function byobRequestBrandCheckException(name) {
      return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
    }
    function byteStreamControllerBrandCheckException(name) {
      return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
    }
    function convertReaderOptions(options, context) {
      assertDictionary(options, context);
      const mode = options === null || options === undefined ? undefined : options.mode;
      return {
        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
      };
    }
    function convertReadableStreamReaderMode(mode, context) {
      mode = `${mode}`;
      if (mode !== "byob") {
        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
      }
      return mode;
    }
    function convertByobReadOptions(options, context) {
      var _a2;
      assertDictionary(options, context);
      const min = (_a2 = options === null || options === undefined ? undefined : options.min) !== null && _a2 !== undefined ? _a2 : 1;
      return {
        min: convertUnsignedLongLongWithEnforceRange(min, `${context} has member 'min' that`)
      };
    }
    function AcquireReadableStreamBYOBReader(stream) {
      return new ReadableStreamBYOBReader(stream);
    }
    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
      stream._reader._readIntoRequests.push(readIntoRequest);
    }
    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
      const reader = stream._reader;
      const readIntoRequest = reader._readIntoRequests.shift();
      if (done) {
        readIntoRequest._closeSteps(chunk);
      } else {
        readIntoRequest._chunkSteps(chunk);
      }
    }
    function ReadableStreamGetNumReadIntoRequests(stream) {
      return stream._reader._readIntoRequests.length;
    }
    function ReadableStreamHasBYOBReader(stream) {
      const reader = stream._reader;
      if (reader === undefined) {
        return false;
      }
      if (!IsReadableStreamBYOBReader(reader)) {
        return false;
      }
      return true;
    }

    class ReadableStreamBYOBReader {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "ReadableStreamBYOBReader");
        assertReadableStream(stream, "First parameter");
        if (IsReadableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive reading by another reader");
        }
        if (!IsReadableByteStreamController(stream._readableStreamController)) {
          throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte " + "source");
        }
        ReadableStreamReaderGenericInitialize(this, stream);
        this._readIntoRequests = new SimpleQueue;
      }
      get closed() {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      cancel(reason = undefined) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("cancel"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("cancel"));
        }
        return ReadableStreamReaderGenericCancel(this, reason);
      }
      read(view, rawOptions = {}) {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException("read"));
        }
        if (!ArrayBuffer.isView(view)) {
          return promiseRejectedWith(new TypeError("view must be an array buffer view"));
        }
        if (view.byteLength === 0) {
          return promiseRejectedWith(new TypeError("view must have non-zero byteLength"));
        }
        if (view.buffer.byteLength === 0) {
          return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
        }
        if (IsDetachedBuffer(view.buffer)) {
          return promiseRejectedWith(new TypeError("view's buffer has been detached"));
        }
        let options;
        try {
          options = convertByobReadOptions(rawOptions, "options");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        const min = options.min;
        if (min === 0) {
          return promiseRejectedWith(new TypeError("options.min must be greater than 0"));
        }
        if (!isDataView(view)) {
          if (min > view.length) {
            return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's length"));
          }
        } else if (min > view.byteLength) {
          return promiseRejectedWith(new RangeError("options.min must be less than or equal to view's byteLength"));
        }
        if (this._ownerReadableStream === undefined) {
          return promiseRejectedWith(readerLockException("read from"));
        }
        let resolvePromise;
        let rejectPromise;
        const promise3 = newPromise((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });
        const readIntoRequest = {
          _chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
          _closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
          _errorSteps: (e) => rejectPromise(e)
        };
        ReadableStreamBYOBReaderRead(this, view, min, readIntoRequest);
        return promise3;
      }
      releaseLock() {
        if (!IsReadableStreamBYOBReader(this)) {
          throw byobReaderBrandCheckException("releaseLock");
        }
        if (this._ownerReadableStream === undefined) {
          return;
        }
        ReadableStreamBYOBReaderRelease(this);
      }
    }
    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
      cancel: { enumerable: true },
      read: { enumerable: true },
      releaseLock: { enumerable: true },
      closed: { enumerable: true }
    });
    setFunctionName(ReadableStreamBYOBReader.prototype.cancel, "cancel");
    setFunctionName(ReadableStreamBYOBReader.prototype.read, "read");
    setFunctionName(ReadableStreamBYOBReader.prototype.releaseLock, "releaseLock");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, {
        value: "ReadableStreamBYOBReader",
        configurable: true
      });
    }
    function IsReadableStreamBYOBReader(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_readIntoRequests")) {
        return false;
      }
      return x instanceof ReadableStreamBYOBReader;
    }
    function ReadableStreamBYOBReaderRead(reader, view, min, readIntoRequest) {
      const stream = reader._ownerReadableStream;
      stream._disturbed = true;
      if (stream._state === "errored") {
        readIntoRequest._errorSteps(stream._storedError);
      } else {
        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, min, readIntoRequest);
      }
    }
    function ReadableStreamBYOBReaderRelease(reader) {
      ReadableStreamReaderGenericRelease(reader);
      const e = new TypeError("Reader was released");
      ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
    }
    function ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e) {
      const readIntoRequests = reader._readIntoRequests;
      reader._readIntoRequests = new SimpleQueue;
      readIntoRequests.forEach((readIntoRequest) => {
        readIntoRequest._errorSteps(e);
      });
    }
    function byobReaderBrandCheckException(name) {
      return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
    }
    function ExtractHighWaterMark(strategy, defaultHWM) {
      const { highWaterMark } = strategy;
      if (highWaterMark === undefined) {
        return defaultHWM;
      }
      if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
        throw new RangeError("Invalid highWaterMark");
      }
      return highWaterMark;
    }
    function ExtractSizeAlgorithm(strategy) {
      const { size } = strategy;
      if (!size) {
        return () => 1;
      }
      return size;
    }
    function convertQueuingStrategy(init, context) {
      assertDictionary(init, context);
      const highWaterMark = init === null || init === undefined ? undefined : init.highWaterMark;
      const size = init === null || init === undefined ? undefined : init.size;
      return {
        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
      };
    }
    function convertQueuingStrategySize(fn, context) {
      assertFunction(fn, context);
      return (chunk) => convertUnrestrictedDouble(fn(chunk));
    }
    function convertUnderlyingSink(original, context) {
      assertDictionary(original, context);
      const abort = original === null || original === undefined ? undefined : original.abort;
      const close = original === null || original === undefined ? undefined : original.close;
      const start = original === null || original === undefined ? undefined : original.start;
      const type3 = original === null || original === undefined ? undefined : original.type;
      const write = original === null || original === undefined ? undefined : original.write;
      return {
        abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
        close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
        start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
        write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
        type: type3
      };
    }
    function convertUnderlyingSinkAbortCallback(fn, original, context) {
      assertFunction(fn, context);
      return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSinkCloseCallback(fn, original, context) {
      assertFunction(fn, context);
      return () => promiseCall(fn, original, []);
    }
    function convertUnderlyingSinkStartCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertUnderlyingSinkWriteCallback(fn, original, context) {
      assertFunction(fn, context);
      return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function assertWritableStream(x, context) {
      if (!IsWritableStream(x)) {
        throw new TypeError(`${context} is not a WritableStream.`);
      }
    }
    function isAbortSignal(value2) {
      if (typeof value2 !== "object" || value2 === null) {
        return false;
      }
      try {
        return typeof value2.aborted === "boolean";
      } catch (_a2) {
        return false;
      }
    }
    const supportsAbortController = typeof AbortController === "function";
    function createAbortController() {
      if (supportsAbortController) {
        return new AbortController;
      }
      return;
    }

    class WritableStream {
      constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
        if (rawUnderlyingSink === undefined) {
          rawUnderlyingSink = null;
        } else {
          assertObject(rawUnderlyingSink, "First parameter");
        }
        const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, "First parameter");
        InitializeWritableStream(this);
        const type3 = underlyingSink.type;
        if (type3 !== undefined) {
          throw new RangeError("Invalid type is specified");
        }
        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        const highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
      }
      get locked() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("locked");
        }
        return IsWritableStreamLocked(this);
      }
      abort(reason = undefined) {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("abort"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot abort a stream that already has a writer"));
        }
        return WritableStreamAbort(this, reason);
      }
      close() {
        if (!IsWritableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$2("close"));
        }
        if (IsWritableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot close a stream that already has a writer"));
        }
        if (WritableStreamCloseQueuedOrInFlight(this)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamClose(this);
      }
      getWriter() {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2("getWriter");
        }
        return AcquireWritableStreamDefaultWriter(this);
      }
    }
    Object.defineProperties(WritableStream.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      getWriter: { enumerable: true },
      locked: { enumerable: true }
    });
    setFunctionName(WritableStream.prototype.abort, "abort");
    setFunctionName(WritableStream.prototype.close, "close");
    setFunctionName(WritableStream.prototype.getWriter, "getWriter");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, {
        value: "WritableStream",
        configurable: true
      });
    }
    function AcquireWritableStreamDefaultWriter(stream) {
      return new WritableStreamDefaultWriter(stream);
    }
    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
      const stream = Object.create(WritableStream.prototype);
      InitializeWritableStream(stream);
      const controller = Object.create(WritableStreamDefaultController.prototype);
      SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
      return stream;
    }
    function InitializeWritableStream(stream) {
      stream._state = "writable";
      stream._storedError = undefined;
      stream._writer = undefined;
      stream._writableStreamController = undefined;
      stream._writeRequests = new SimpleQueue;
      stream._inFlightWriteRequest = undefined;
      stream._closeRequest = undefined;
      stream._inFlightCloseRequest = undefined;
      stream._pendingAbortRequest = undefined;
      stream._backpressure = false;
    }
    function IsWritableStream(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_writableStreamController")) {
        return false;
      }
      return x instanceof WritableStream;
    }
    function IsWritableStreamLocked(stream) {
      if (stream._writer === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamAbort(stream, reason) {
      var _a2;
      if (stream._state === "closed" || stream._state === "errored") {
        return promiseResolvedWith(undefined);
      }
      stream._writableStreamController._abortReason = reason;
      (_a2 = stream._writableStreamController._abortController) === null || _a2 === undefined || _a2.abort(reason);
      const state = stream._state;
      if (state === "closed" || state === "errored") {
        return promiseResolvedWith(undefined);
      }
      if (stream._pendingAbortRequest !== undefined) {
        return stream._pendingAbortRequest._promise;
      }
      let wasAlreadyErroring = false;
      if (state === "erroring") {
        wasAlreadyErroring = true;
        reason = undefined;
      }
      const promise3 = newPromise((resolve, reject) => {
        stream._pendingAbortRequest = {
          _promise: undefined,
          _resolve: resolve,
          _reject: reject,
          _reason: reason,
          _wasAlreadyErroring: wasAlreadyErroring
        };
      });
      stream._pendingAbortRequest._promise = promise3;
      if (!wasAlreadyErroring) {
        WritableStreamStartErroring(stream, reason);
      }
      return promise3;
    }
    function WritableStreamClose(stream) {
      const state = stream._state;
      if (state === "closed" || state === "errored") {
        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
      }
      const promise3 = newPromise((resolve, reject) => {
        const closeRequest = {
          _resolve: resolve,
          _reject: reject
        };
        stream._closeRequest = closeRequest;
      });
      const writer = stream._writer;
      if (writer !== undefined && stream._backpressure && state === "writable") {
        defaultWriterReadyPromiseResolve(writer);
      }
      WritableStreamDefaultControllerClose(stream._writableStreamController);
      return promise3;
    }
    function WritableStreamAddWriteRequest(stream) {
      const promise3 = newPromise((resolve, reject) => {
        const writeRequest = {
          _resolve: resolve,
          _reject: reject
        };
        stream._writeRequests.push(writeRequest);
      });
      return promise3;
    }
    function WritableStreamDealWithRejection(stream, error3) {
      const state = stream._state;
      if (state === "writable") {
        WritableStreamStartErroring(stream, error3);
        return;
      }
      WritableStreamFinishErroring(stream);
    }
    function WritableStreamStartErroring(stream, reason) {
      const controller = stream._writableStreamController;
      stream._state = "erroring";
      stream._storedError = reason;
      const writer = stream._writer;
      if (writer !== undefined) {
        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
      }
      if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
        WritableStreamFinishErroring(stream);
      }
    }
    function WritableStreamFinishErroring(stream) {
      stream._state = "errored";
      stream._writableStreamController[ErrorSteps]();
      const storedError = stream._storedError;
      stream._writeRequests.forEach((writeRequest) => {
        writeRequest._reject(storedError);
      });
      stream._writeRequests = new SimpleQueue;
      if (stream._pendingAbortRequest === undefined) {
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return;
      }
      const abortRequest = stream._pendingAbortRequest;
      stream._pendingAbortRequest = undefined;
      if (abortRequest._wasAlreadyErroring) {
        abortRequest._reject(storedError);
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return;
      }
      const promise3 = stream._writableStreamController[AbortSteps](abortRequest._reason);
      uponPromise(promise3, () => {
        abortRequest._resolve();
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return null;
      }, (reason) => {
        abortRequest._reject(reason);
        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
        return null;
      });
    }
    function WritableStreamFinishInFlightWrite(stream) {
      stream._inFlightWriteRequest._resolve(undefined);
      stream._inFlightWriteRequest = undefined;
    }
    function WritableStreamFinishInFlightWriteWithError(stream, error3) {
      stream._inFlightWriteRequest._reject(error3);
      stream._inFlightWriteRequest = undefined;
      WritableStreamDealWithRejection(stream, error3);
    }
    function WritableStreamFinishInFlightClose(stream) {
      stream._inFlightCloseRequest._resolve(undefined);
      stream._inFlightCloseRequest = undefined;
      const state = stream._state;
      if (state === "erroring") {
        stream._storedError = undefined;
        if (stream._pendingAbortRequest !== undefined) {
          stream._pendingAbortRequest._resolve();
          stream._pendingAbortRequest = undefined;
        }
      }
      stream._state = "closed";
      const writer = stream._writer;
      if (writer !== undefined) {
        defaultWriterClosedPromiseResolve(writer);
      }
    }
    function WritableStreamFinishInFlightCloseWithError(stream, error3) {
      stream._inFlightCloseRequest._reject(error3);
      stream._inFlightCloseRequest = undefined;
      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._reject(error3);
        stream._pendingAbortRequest = undefined;
      }
      WritableStreamDealWithRejection(stream, error3);
    }
    function WritableStreamCloseQueuedOrInFlight(stream) {
      if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamHasOperationMarkedInFlight(stream) {
      if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
        return false;
      }
      return true;
    }
    function WritableStreamMarkCloseRequestInFlight(stream) {
      stream._inFlightCloseRequest = stream._closeRequest;
      stream._closeRequest = undefined;
    }
    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
      stream._inFlightWriteRequest = stream._writeRequests.shift();
    }
    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
      if (stream._closeRequest !== undefined) {
        stream._closeRequest._reject(stream._storedError);
        stream._closeRequest = undefined;
      }
      const writer = stream._writer;
      if (writer !== undefined) {
        defaultWriterClosedPromiseReject(writer, stream._storedError);
      }
    }
    function WritableStreamUpdateBackpressure(stream, backpressure) {
      const writer = stream._writer;
      if (writer !== undefined && backpressure !== stream._backpressure) {
        if (backpressure) {
          defaultWriterReadyPromiseReset(writer);
        } else {
          defaultWriterReadyPromiseResolve(writer);
        }
      }
      stream._backpressure = backpressure;
    }

    class WritableStreamDefaultWriter {
      constructor(stream) {
        assertRequiredArgument(stream, 1, "WritableStreamDefaultWriter");
        assertWritableStream(stream, "First parameter");
        if (IsWritableStreamLocked(stream)) {
          throw new TypeError("This stream has already been locked for exclusive writing by another writer");
        }
        this._ownerWritableStream = stream;
        stream._writer = this;
        const state = stream._state;
        if (state === "writable") {
          if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
            defaultWriterReadyPromiseInitialize(this);
          } else {
            defaultWriterReadyPromiseInitializeAsResolved(this);
          }
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "erroring") {
          defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
          defaultWriterClosedPromiseInitialize(this);
        } else if (state === "closed") {
          defaultWriterReadyPromiseInitializeAsResolved(this);
          defaultWriterClosedPromiseInitializeAsResolved(this);
        } else {
          const storedError = stream._storedError;
          defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
          defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
        }
      }
      get closed() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("closed"));
        }
        return this._closedPromise;
      }
      get desiredSize() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("desiredSize");
        }
        if (this._ownerWritableStream === undefined) {
          throw defaultWriterLockException("desiredSize");
        }
        return WritableStreamDefaultWriterGetDesiredSize(this);
      }
      get ready() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("ready"));
        }
        return this._readyPromise;
      }
      abort(reason = undefined) {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("abort"));
        }
        if (this._ownerWritableStream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("abort"));
        }
        return WritableStreamDefaultWriterAbort(this, reason);
      }
      close() {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("close"));
        }
        const stream = this._ownerWritableStream;
        if (stream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("close"));
        }
        if (WritableStreamCloseQueuedOrInFlight(stream)) {
          return promiseRejectedWith(new TypeError("Cannot close an already-closing stream"));
        }
        return WritableStreamDefaultWriterClose(this);
      }
      releaseLock() {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException("releaseLock");
        }
        const stream = this._ownerWritableStream;
        if (stream === undefined) {
          return;
        }
        WritableStreamDefaultWriterRelease(this);
      }
      write(chunk = undefined) {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException("write"));
        }
        if (this._ownerWritableStream === undefined) {
          return promiseRejectedWith(defaultWriterLockException("write to"));
        }
        return WritableStreamDefaultWriterWrite(this, chunk);
      }
    }
    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
      abort: { enumerable: true },
      close: { enumerable: true },
      releaseLock: { enumerable: true },
      write: { enumerable: true },
      closed: { enumerable: true },
      desiredSize: { enumerable: true },
      ready: { enumerable: true }
    });
    setFunctionName(WritableStreamDefaultWriter.prototype.abort, "abort");
    setFunctionName(WritableStreamDefaultWriter.prototype.close, "close");
    setFunctionName(WritableStreamDefaultWriter.prototype.releaseLock, "releaseLock");
    setFunctionName(WritableStreamDefaultWriter.prototype.write, "write");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, {
        value: "WritableStreamDefaultWriter",
        configurable: true
      });
    }
    function IsWritableStreamDefaultWriter(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_ownerWritableStream")) {
        return false;
      }
      return x instanceof WritableStreamDefaultWriter;
    }
    function WritableStreamDefaultWriterAbort(writer, reason) {
      const stream = writer._ownerWritableStream;
      return WritableStreamAbort(stream, reason);
    }
    function WritableStreamDefaultWriterClose(writer) {
      const stream = writer._ownerWritableStream;
      return WritableStreamClose(stream);
    }
    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
      const stream = writer._ownerWritableStream;
      const state = stream._state;
      if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
        return promiseResolvedWith(undefined);
      }
      if (state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      return WritableStreamDefaultWriterClose(writer);
    }
    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error3) {
      if (writer._closedPromiseState === "pending") {
        defaultWriterClosedPromiseReject(writer, error3);
      } else {
        defaultWriterClosedPromiseResetToRejected(writer, error3);
      }
    }
    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error3) {
      if (writer._readyPromiseState === "pending") {
        defaultWriterReadyPromiseReject(writer, error3);
      } else {
        defaultWriterReadyPromiseResetToRejected(writer, error3);
      }
    }
    function WritableStreamDefaultWriterGetDesiredSize(writer) {
      const stream = writer._ownerWritableStream;
      const state = stream._state;
      if (state === "errored" || state === "erroring") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
    }
    function WritableStreamDefaultWriterRelease(writer) {
      const stream = writer._ownerWritableStream;
      const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
      WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
      stream._writer = undefined;
      writer._ownerWritableStream = undefined;
    }
    function WritableStreamDefaultWriterWrite(writer, chunk) {
      const stream = writer._ownerWritableStream;
      const controller = stream._writableStreamController;
      const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
      if (stream !== writer._ownerWritableStream) {
        return promiseRejectedWith(defaultWriterLockException("write to"));
      }
      const state = stream._state;
      if (state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      if (WritableStreamCloseQueuedOrInFlight(stream) || state === "closed") {
        return promiseRejectedWith(new TypeError("The stream is closing or closed and cannot be written to"));
      }
      if (state === "erroring") {
        return promiseRejectedWith(stream._storedError);
      }
      const promise3 = WritableStreamAddWriteRequest(stream);
      WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
      return promise3;
    }
    const closeSentinel = {};

    class WritableStreamDefaultController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get abortReason() {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("abortReason");
        }
        return this._abortReason;
      }
      get signal() {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("signal");
        }
        if (this._abortController === undefined) {
          throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");
        }
        return this._abortController.signal;
      }
      error(e = undefined) {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2("error");
        }
        const state = this._controlledWritableStream._state;
        if (state !== "writable") {
          return;
        }
        WritableStreamDefaultControllerError(this, e);
      }
      [AbortSteps](reason) {
        const result = this._abortAlgorithm(reason);
        WritableStreamDefaultControllerClearAlgorithms(this);
        return result;
      }
      [ErrorSteps]() {
        ResetQueue(this);
      }
    }
    Object.defineProperties(WritableStreamDefaultController.prototype, {
      abortReason: { enumerable: true },
      signal: { enumerable: true },
      error: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, {
        value: "WritableStreamDefaultController",
        configurable: true
      });
    }
    function IsWritableStreamDefaultController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledWritableStream")) {
        return false;
      }
      return x instanceof WritableStreamDefaultController;
    }
    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
      controller._controlledWritableStream = stream;
      stream._writableStreamController = controller;
      controller._queue = undefined;
      controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._abortReason = undefined;
      controller._abortController = createAbortController();
      controller._started = false;
      controller._strategySizeAlgorithm = sizeAlgorithm;
      controller._strategyHWM = highWaterMark;
      controller._writeAlgorithm = writeAlgorithm;
      controller._closeAlgorithm = closeAlgorithm;
      controller._abortAlgorithm = abortAlgorithm;
      const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
      const startResult = startAlgorithm();
      const startPromise = promiseResolvedWith(startResult);
      uponPromise(startPromise, () => {
        controller._started = true;
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        return null;
      }, (r) => {
        controller._started = true;
        WritableStreamDealWithRejection(stream, r);
        return null;
      });
    }
    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
      const controller = Object.create(WritableStreamDefaultController.prototype);
      let startAlgorithm;
      let writeAlgorithm;
      let closeAlgorithm;
      let abortAlgorithm;
      if (underlyingSink.start !== undefined) {
        startAlgorithm = () => underlyingSink.start(controller);
      } else {
        startAlgorithm = () => {
          return;
        };
      }
      if (underlyingSink.write !== undefined) {
        writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
      } else {
        writeAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingSink.close !== undefined) {
        closeAlgorithm = () => underlyingSink.close();
      } else {
        closeAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingSink.abort !== undefined) {
        abortAlgorithm = (reason) => underlyingSink.abort(reason);
      } else {
        abortAlgorithm = () => promiseResolvedWith(undefined);
      }
      SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    }
    function WritableStreamDefaultControllerClearAlgorithms(controller) {
      controller._writeAlgorithm = undefined;
      controller._closeAlgorithm = undefined;
      controller._abortAlgorithm = undefined;
      controller._strategySizeAlgorithm = undefined;
    }
    function WritableStreamDefaultControllerClose(controller) {
      EnqueueValueWithSize(controller, closeSentinel, 0);
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
      try {
        return controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
        return 1;
      }
    }
    function WritableStreamDefaultControllerGetDesiredSize(controller) {
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
        return;
      }
      const stream = controller._controlledWritableStream;
      if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === "writable") {
        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }
    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
      const stream = controller._controlledWritableStream;
      if (!controller._started) {
        return;
      }
      if (stream._inFlightWriteRequest !== undefined) {
        return;
      }
      const state = stream._state;
      if (state === "erroring") {
        WritableStreamFinishErroring(stream);
        return;
      }
      if (controller._queue.length === 0) {
        return;
      }
      const value2 = PeekQueueValue(controller);
      if (value2 === closeSentinel) {
        WritableStreamDefaultControllerProcessClose(controller);
      } else {
        WritableStreamDefaultControllerProcessWrite(controller, value2);
      }
    }
    function WritableStreamDefaultControllerErrorIfNeeded(controller, error3) {
      if (controller._controlledWritableStream._state === "writable") {
        WritableStreamDefaultControllerError(controller, error3);
      }
    }
    function WritableStreamDefaultControllerProcessClose(controller) {
      const stream = controller._controlledWritableStream;
      WritableStreamMarkCloseRequestInFlight(stream);
      DequeueValue(controller);
      const sinkClosePromise = controller._closeAlgorithm();
      WritableStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(sinkClosePromise, () => {
        WritableStreamFinishInFlightClose(stream);
        return null;
      }, (reason) => {
        WritableStreamFinishInFlightCloseWithError(stream, reason);
        return null;
      });
    }
    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
      const stream = controller._controlledWritableStream;
      WritableStreamMarkFirstWriteRequestInFlight(stream);
      const sinkWritePromise = controller._writeAlgorithm(chunk);
      uponPromise(sinkWritePromise, () => {
        WritableStreamFinishInFlightWrite(stream);
        const state = stream._state;
        DequeueValue(controller);
        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === "writable") {
          const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
          WritableStreamUpdateBackpressure(stream, backpressure);
        }
        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
        return null;
      }, (reason) => {
        if (stream._state === "writable") {
          WritableStreamDefaultControllerClearAlgorithms(controller);
        }
        WritableStreamFinishInFlightWriteWithError(stream, reason);
        return null;
      });
    }
    function WritableStreamDefaultControllerGetBackpressure(controller) {
      const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
      return desiredSize <= 0;
    }
    function WritableStreamDefaultControllerError(controller, error3) {
      const stream = controller._controlledWritableStream;
      WritableStreamDefaultControllerClearAlgorithms(controller);
      WritableStreamStartErroring(stream, error3);
    }
    function streamBrandCheckException$2(name) {
      return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
    }
    function defaultControllerBrandCheckException$2(name) {
      return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
    }
    function defaultWriterBrandCheckException(name) {
      return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
    }
    function defaultWriterLockException(name) {
      return new TypeError("Cannot " + name + " a stream using a released writer");
    }
    function defaultWriterClosedPromiseInitialize(writer) {
      writer._closedPromise = newPromise((resolve, reject) => {
        writer._closedPromise_resolve = resolve;
        writer._closedPromise_reject = reject;
        writer._closedPromiseState = "pending";
      });
    }
    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
      defaultWriterClosedPromiseInitialize(writer);
      defaultWriterClosedPromiseReject(writer, reason);
    }
    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
      defaultWriterClosedPromiseInitialize(writer);
      defaultWriterClosedPromiseResolve(writer);
    }
    function defaultWriterClosedPromiseReject(writer, reason) {
      if (writer._closedPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(writer._closedPromise);
      writer._closedPromise_reject(reason);
      writer._closedPromise_resolve = undefined;
      writer._closedPromise_reject = undefined;
      writer._closedPromiseState = "rejected";
    }
    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
      defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterClosedPromiseResolve(writer) {
      if (writer._closedPromise_resolve === undefined) {
        return;
      }
      writer._closedPromise_resolve(undefined);
      writer._closedPromise_resolve = undefined;
      writer._closedPromise_reject = undefined;
      writer._closedPromiseState = "resolved";
    }
    function defaultWriterReadyPromiseInitialize(writer) {
      writer._readyPromise = newPromise((resolve, reject) => {
        writer._readyPromise_resolve = resolve;
        writer._readyPromise_reject = reject;
      });
      writer._readyPromiseState = "pending";
    }
    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
      defaultWriterReadyPromiseInitialize(writer);
      defaultWriterReadyPromiseReject(writer, reason);
    }
    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
      defaultWriterReadyPromiseInitialize(writer);
      defaultWriterReadyPromiseResolve(writer);
    }
    function defaultWriterReadyPromiseReject(writer, reason) {
      if (writer._readyPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(writer._readyPromise);
      writer._readyPromise_reject(reason);
      writer._readyPromise_resolve = undefined;
      writer._readyPromise_reject = undefined;
      writer._readyPromiseState = "rejected";
    }
    function defaultWriterReadyPromiseReset(writer) {
      defaultWriterReadyPromiseInitialize(writer);
    }
    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
      defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
    }
    function defaultWriterReadyPromiseResolve(writer) {
      if (writer._readyPromise_resolve === undefined) {
        return;
      }
      writer._readyPromise_resolve(undefined);
      writer._readyPromise_resolve = undefined;
      writer._readyPromise_reject = undefined;
      writer._readyPromiseState = "fulfilled";
    }
    function getGlobals() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      } else if (typeof self !== "undefined") {
        return self;
      } else if (typeof global !== "undefined") {
        return global;
      }
      return;
    }
    const globals = getGlobals();
    function isDOMExceptionConstructor(ctor) {
      if (!(typeof ctor === "function" || typeof ctor === "object")) {
        return false;
      }
      if (ctor.name !== "DOMException") {
        return false;
      }
      try {
        new ctor;
        return true;
      } catch (_a2) {
        return false;
      }
    }
    function getFromGlobal() {
      const ctor = globals === null || globals === undefined ? undefined : globals.DOMException;
      return isDOMExceptionConstructor(ctor) ? ctor : undefined;
    }
    function createPolyfill() {
      const ctor = function DOMException(message, name) {
        this.message = message || "";
        this.name = name || "Error";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      };
      setFunctionName(ctor, "DOMException");
      ctor.prototype = Object.create(Error.prototype);
      Object.defineProperty(ctor.prototype, "constructor", { value: ctor, writable: true, configurable: true });
      return ctor;
    }
    const DOMException = getFromGlobal() || createPolyfill();
    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
      const reader = AcquireReadableStreamDefaultReader(source);
      const writer = AcquireWritableStreamDefaultWriter(dest);
      source._disturbed = true;
      let shuttingDown = false;
      let currentWrite = promiseResolvedWith(undefined);
      return newPromise((resolve, reject) => {
        let abortAlgorithm;
        if (signal !== undefined) {
          abortAlgorithm = () => {
            const error3 = signal.reason !== undefined ? signal.reason : new DOMException("Aborted", "AbortError");
            const actions = [];
            if (!preventAbort) {
              actions.push(() => {
                if (dest._state === "writable") {
                  return WritableStreamAbort(dest, error3);
                }
                return promiseResolvedWith(undefined);
              });
            }
            if (!preventCancel) {
              actions.push(() => {
                if (source._state === "readable") {
                  return ReadableStreamCancel(source, error3);
                }
                return promiseResolvedWith(undefined);
              });
            }
            shutdownWithAction(() => Promise.all(actions.map((action) => action())), true, error3);
          };
          if (signal.aborted) {
            abortAlgorithm();
            return;
          }
          signal.addEventListener("abort", abortAlgorithm);
        }
        function pipeLoop() {
          return newPromise((resolveLoop, rejectLoop) => {
            function next(done) {
              if (done) {
                resolveLoop();
              } else {
                PerformPromiseThen(pipeStep(), next, rejectLoop);
              }
            }
            next(false);
          });
        }
        function pipeStep() {
          if (shuttingDown) {
            return promiseResolvedWith(true);
          }
          return PerformPromiseThen(writer._readyPromise, () => {
            return newPromise((resolveRead, rejectRead) => {
              ReadableStreamDefaultReaderRead(reader, {
                _chunkSteps: (chunk) => {
                  currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                  resolveRead(false);
                },
                _closeSteps: () => resolveRead(true),
                _errorSteps: rejectRead
              });
            });
          });
        }
        isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
          if (!preventAbort) {
            shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
          } else {
            shutdown(true, storedError);
          }
          return null;
        });
        isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
          if (!preventCancel) {
            shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
          } else {
            shutdown(true, storedError);
          }
          return null;
        });
        isOrBecomesClosed(source, reader._closedPromise, () => {
          if (!preventClose) {
            shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
          } else {
            shutdown();
          }
          return null;
        });
        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === "closed") {
          const destClosed = new TypeError("the destination writable stream closed before all data could be piped to it");
          if (!preventCancel) {
            shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
          } else {
            shutdown(true, destClosed);
          }
        }
        setPromiseIsHandledToTrue(pipeLoop());
        function waitForWritesToFinish() {
          const oldCurrentWrite = currentWrite;
          return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
        }
        function isOrBecomesErrored(stream, promise3, action) {
          if (stream._state === "errored") {
            action(stream._storedError);
          } else {
            uponRejection(promise3, action);
          }
        }
        function isOrBecomesClosed(stream, promise3, action) {
          if (stream._state === "closed") {
            action();
          } else {
            uponFulfillment(promise3, action);
          }
        }
        function shutdownWithAction(action, originalIsError, originalError) {
          if (shuttingDown) {
            return;
          }
          shuttingDown = true;
          if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
            uponFulfillment(waitForWritesToFinish(), doTheRest);
          } else {
            doTheRest();
          }
          function doTheRest() {
            uponPromise(action(), () => finalize(originalIsError, originalError), (newError) => finalize(true, newError));
            return null;
          }
        }
        function shutdown(isError, error3) {
          if (shuttingDown) {
            return;
          }
          shuttingDown = true;
          if (dest._state === "writable" && !WritableStreamCloseQueuedOrInFlight(dest)) {
            uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error3));
          } else {
            finalize(isError, error3);
          }
        }
        function finalize(isError, error3) {
          WritableStreamDefaultWriterRelease(writer);
          ReadableStreamReaderGenericRelease(reader);
          if (signal !== undefined) {
            signal.removeEventListener("abort", abortAlgorithm);
          }
          if (isError) {
            reject(error3);
          } else {
            resolve(undefined);
          }
          return null;
        }
      });
    }

    class ReadableStreamDefaultController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("desiredSize");
        }
        return ReadableStreamDefaultControllerGetDesiredSize(this);
      }
      close() {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("close");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits close");
        }
        ReadableStreamDefaultControllerClose(this);
      }
      enqueue(chunk = undefined) {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("enqueue");
        }
        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
          throw new TypeError("The stream is not in a state that permits enqueue");
        }
        return ReadableStreamDefaultControllerEnqueue(this, chunk);
      }
      error(e = undefined) {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1("error");
        }
        ReadableStreamDefaultControllerError(this, e);
      }
      [CancelSteps](reason) {
        ResetQueue(this);
        const result = this._cancelAlgorithm(reason);
        ReadableStreamDefaultControllerClearAlgorithms(this);
        return result;
      }
      [PullSteps](readRequest) {
        const stream = this._controlledReadableStream;
        if (this._queue.length > 0) {
          const chunk = DequeueValue(this);
          if (this._closeRequested && this._queue.length === 0) {
            ReadableStreamDefaultControllerClearAlgorithms(this);
            ReadableStreamClose(stream);
          } else {
            ReadableStreamDefaultControllerCallPullIfNeeded(this);
          }
          readRequest._chunkSteps(chunk);
        } else {
          ReadableStreamAddReadRequest(stream, readRequest);
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }
      }
      [ReleaseSteps]() {}
    }
    Object.defineProperties(ReadableStreamDefaultController.prototype, {
      close: { enumerable: true },
      enqueue: { enumerable: true },
      error: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    setFunctionName(ReadableStreamDefaultController.prototype.close, "close");
    setFunctionName(ReadableStreamDefaultController.prototype.enqueue, "enqueue");
    setFunctionName(ReadableStreamDefaultController.prototype.error, "error");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, {
        value: "ReadableStreamDefaultController",
        configurable: true
      });
    }
    function IsReadableStreamDefaultController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledReadableStream")) {
        return false;
      }
      return x instanceof ReadableStreamDefaultController;
    }
    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
      const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
      if (!shouldPull) {
        return;
      }
      if (controller._pulling) {
        controller._pullAgain = true;
        return;
      }
      controller._pulling = true;
      const pullPromise = controller._pullAlgorithm();
      uponPromise(pullPromise, () => {
        controller._pulling = false;
        if (controller._pullAgain) {
          controller._pullAgain = false;
          ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        }
        return null;
      }, (e) => {
        ReadableStreamDefaultControllerError(controller, e);
        return null;
      });
    }
    function ReadableStreamDefaultControllerShouldCallPull(controller) {
      const stream = controller._controlledReadableStream;
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return false;
      }
      if (!controller._started) {
        return false;
      }
      if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        return true;
      }
      const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
      if (desiredSize > 0) {
        return true;
      }
      return false;
    }
    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
      controller._pullAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
      controller._strategySizeAlgorithm = undefined;
    }
    function ReadableStreamDefaultControllerClose(controller) {
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return;
      }
      const stream = controller._controlledReadableStream;
      controller._closeRequested = true;
      if (controller._queue.length === 0) {
        ReadableStreamDefaultControllerClearAlgorithms(controller);
        ReadableStreamClose(stream);
      }
    }
    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
        return;
      }
      const stream = controller._controlledReadableStream;
      if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
        ReadableStreamFulfillReadRequest(stream, chunk, false);
      } else {
        let chunkSize;
        try {
          chunkSize = controller._strategySizeAlgorithm(chunk);
        } catch (chunkSizeE) {
          ReadableStreamDefaultControllerError(controller, chunkSizeE);
          throw chunkSizeE;
        }
        try {
          EnqueueValueWithSize(controller, chunk, chunkSize);
        } catch (enqueueE) {
          ReadableStreamDefaultControllerError(controller, enqueueE);
          throw enqueueE;
        }
      }
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }
    function ReadableStreamDefaultControllerError(controller, e) {
      const stream = controller._controlledReadableStream;
      if (stream._state !== "readable") {
        return;
      }
      ResetQueue(controller);
      ReadableStreamDefaultControllerClearAlgorithms(controller);
      ReadableStreamError(stream, e);
    }
    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
      const state = controller._controlledReadableStream._state;
      if (state === "errored") {
        return null;
      }
      if (state === "closed") {
        return 0;
      }
      return controller._strategyHWM - controller._queueTotalSize;
    }
    function ReadableStreamDefaultControllerHasBackpressure(controller) {
      if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
        return false;
      }
      return true;
    }
    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
      const state = controller._controlledReadableStream._state;
      if (!controller._closeRequested && state === "readable") {
        return true;
      }
      return false;
    }
    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
      controller._controlledReadableStream = stream;
      controller._queue = undefined;
      controller._queueTotalSize = undefined;
      ResetQueue(controller);
      controller._started = false;
      controller._closeRequested = false;
      controller._pullAgain = false;
      controller._pulling = false;
      controller._strategySizeAlgorithm = sizeAlgorithm;
      controller._strategyHWM = highWaterMark;
      controller._pullAlgorithm = pullAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      stream._readableStreamController = controller;
      const startResult = startAlgorithm();
      uponPromise(promiseResolvedWith(startResult), () => {
        controller._started = true;
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
        return null;
      }, (r) => {
        ReadableStreamDefaultControllerError(controller, r);
        return null;
      });
    }
    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
      const controller = Object.create(ReadableStreamDefaultController.prototype);
      let startAlgorithm;
      let pullAlgorithm;
      let cancelAlgorithm;
      if (underlyingSource.start !== undefined) {
        startAlgorithm = () => underlyingSource.start(controller);
      } else {
        startAlgorithm = () => {
          return;
        };
      }
      if (underlyingSource.pull !== undefined) {
        pullAlgorithm = () => underlyingSource.pull(controller);
      } else {
        pullAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (underlyingSource.cancel !== undefined) {
        cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
      } else {
        cancelAlgorithm = () => promiseResolvedWith(undefined);
      }
      SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    }
    function defaultControllerBrandCheckException$1(name) {
      return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
    }
    function ReadableStreamTee(stream, cloneForBranch2) {
      if (IsReadableByteStreamController(stream._readableStreamController)) {
        return ReadableByteStreamTee(stream);
      }
      return ReadableStreamDefaultTee(stream);
    }
    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
      const reader = AcquireReadableStreamDefaultReader(stream);
      let reading = false;
      let readAgain = false;
      let canceled1 = false;
      let canceled2 = false;
      let reason1;
      let reason2;
      let branch1;
      let branch2;
      let resolveCancelPromise;
      const cancelPromise = newPromise((resolve) => {
        resolveCancelPromise = resolve;
      });
      function pullAlgorithm() {
        if (reading) {
          readAgain = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const readRequest = {
          _chunkSteps: (chunk) => {
            _queueMicrotask(() => {
              readAgain = false;
              const chunk1 = chunk;
              const chunk2 = chunk;
              if (!canceled1) {
                ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
              }
              if (!canceled2) {
                ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
              }
              reading = false;
              if (readAgain) {
                pullAlgorithm();
              }
            });
          },
          _closeSteps: () => {
            reading = false;
            if (!canceled1) {
              ReadableStreamDefaultControllerClose(branch1._readableStreamController);
            }
            if (!canceled2) {
              ReadableStreamDefaultControllerClose(branch2._readableStreamController);
            }
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
        return promiseResolvedWith(undefined);
      }
      function cancel1Algorithm(reason) {
        canceled1 = true;
        reason1 = reason;
        if (canceled2) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function cancel2Algorithm(reason) {
        canceled2 = true;
        reason2 = reason;
        if (canceled1) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function startAlgorithm() {}
      branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
      branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
      uponRejection(reader._closedPromise, (r) => {
        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
        if (!canceled1 || !canceled2) {
          resolveCancelPromise(undefined);
        }
        return null;
      });
      return [branch1, branch2];
    }
    function ReadableByteStreamTee(stream) {
      let reader = AcquireReadableStreamDefaultReader(stream);
      let reading = false;
      let readAgainForBranch1 = false;
      let readAgainForBranch2 = false;
      let canceled1 = false;
      let canceled2 = false;
      let reason1;
      let reason2;
      let branch1;
      let branch2;
      let resolveCancelPromise;
      const cancelPromise = newPromise((resolve) => {
        resolveCancelPromise = resolve;
      });
      function forwardReaderError(thisReader) {
        uponRejection(thisReader._closedPromise, (r) => {
          if (thisReader !== reader) {
            return null;
          }
          ReadableByteStreamControllerError(branch1._readableStreamController, r);
          ReadableByteStreamControllerError(branch2._readableStreamController, r);
          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
          return null;
        });
      }
      function pullWithDefaultReader() {
        if (IsReadableStreamBYOBReader(reader)) {
          ReadableStreamReaderGenericRelease(reader);
          reader = AcquireReadableStreamDefaultReader(stream);
          forwardReaderError(reader);
        }
        const readRequest = {
          _chunkSteps: (chunk) => {
            _queueMicrotask(() => {
              readAgainForBranch1 = false;
              readAgainForBranch2 = false;
              const chunk1 = chunk;
              let chunk2 = chunk;
              if (!canceled1 && !canceled2) {
                try {
                  chunk2 = CloneAsUint8Array(chunk);
                } catch (cloneE) {
                  ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                  ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                  resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                  return;
                }
              }
              if (!canceled1) {
                ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
              }
              if (!canceled2) {
                ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
              }
              reading = false;
              if (readAgainForBranch1) {
                pull1Algorithm();
              } else if (readAgainForBranch2) {
                pull2Algorithm();
              }
            });
          },
          _closeSteps: () => {
            reading = false;
            if (!canceled1) {
              ReadableByteStreamControllerClose(branch1._readableStreamController);
            }
            if (!canceled2) {
              ReadableByteStreamControllerClose(branch2._readableStreamController);
            }
            if (branch1._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
            }
            if (branch2._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
            }
            if (!canceled1 || !canceled2) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamDefaultReaderRead(reader, readRequest);
      }
      function pullWithBYOBReader(view, forBranch2) {
        if (IsReadableStreamDefaultReader(reader)) {
          ReadableStreamReaderGenericRelease(reader);
          reader = AcquireReadableStreamBYOBReader(stream);
          forwardReaderError(reader);
        }
        const byobBranch = forBranch2 ? branch2 : branch1;
        const otherBranch = forBranch2 ? branch1 : branch2;
        const readIntoRequest = {
          _chunkSteps: (chunk) => {
            _queueMicrotask(() => {
              readAgainForBranch1 = false;
              readAgainForBranch2 = false;
              const byobCanceled = forBranch2 ? canceled2 : canceled1;
              const otherCanceled = forBranch2 ? canceled1 : canceled2;
              if (!otherCanceled) {
                let clonedChunk;
                try {
                  clonedChunk = CloneAsUint8Array(chunk);
                } catch (cloneE) {
                  ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                  ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                  resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                  return;
                }
                if (!byobCanceled) {
                  ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
                }
                ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
              } else if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              reading = false;
              if (readAgainForBranch1) {
                pull1Algorithm();
              } else if (readAgainForBranch2) {
                pull2Algorithm();
              }
            });
          },
          _closeSteps: (chunk) => {
            reading = false;
            const byobCanceled = forBranch2 ? canceled2 : canceled1;
            const otherCanceled = forBranch2 ? canceled1 : canceled2;
            if (!byobCanceled) {
              ReadableByteStreamControllerClose(byobBranch._readableStreamController);
            }
            if (!otherCanceled) {
              ReadableByteStreamControllerClose(otherBranch._readableStreamController);
            }
            if (chunk !== undefined) {
              if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }
              if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
                ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
              }
            }
            if (!byobCanceled || !otherCanceled) {
              resolveCancelPromise(undefined);
            }
          },
          _errorSteps: () => {
            reading = false;
          }
        };
        ReadableStreamBYOBReaderRead(reader, view, 1, readIntoRequest);
      }
      function pull1Algorithm() {
        if (reading) {
          readAgainForBranch1 = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
        if (byobRequest === null) {
          pullWithDefaultReader();
        } else {
          pullWithBYOBReader(byobRequest._view, false);
        }
        return promiseResolvedWith(undefined);
      }
      function pull2Algorithm() {
        if (reading) {
          readAgainForBranch2 = true;
          return promiseResolvedWith(undefined);
        }
        reading = true;
        const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
        if (byobRequest === null) {
          pullWithDefaultReader();
        } else {
          pullWithBYOBReader(byobRequest._view, true);
        }
        return promiseResolvedWith(undefined);
      }
      function cancel1Algorithm(reason) {
        canceled1 = true;
        reason1 = reason;
        if (canceled2) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function cancel2Algorithm(reason) {
        canceled2 = true;
        reason2 = reason;
        if (canceled1) {
          const compositeReason = CreateArrayFromList([reason1, reason2]);
          const cancelResult = ReadableStreamCancel(stream, compositeReason);
          resolveCancelPromise(cancelResult);
        }
        return cancelPromise;
      }
      function startAlgorithm() {
        return;
      }
      branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
      branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
      forwardReaderError(reader);
      return [branch1, branch2];
    }
    function isReadableStreamLike(stream) {
      return typeIsObject(stream) && typeof stream.getReader !== "undefined";
    }
    function ReadableStreamFrom(source) {
      if (isReadableStreamLike(source)) {
        return ReadableStreamFromDefaultReader(source.getReader());
      }
      return ReadableStreamFromIterable(source);
    }
    function ReadableStreamFromIterable(asyncIterable) {
      let stream;
      const iteratorRecord = GetIterator(asyncIterable, "async");
      const startAlgorithm = noop;
      function pullAlgorithm() {
        let nextResult;
        try {
          nextResult = IteratorNext(iteratorRecord);
        } catch (e) {
          return promiseRejectedWith(e);
        }
        const nextPromise = promiseResolvedWith(nextResult);
        return transformPromiseWith(nextPromise, (iterResult) => {
          if (!typeIsObject(iterResult)) {
            throw new TypeError("The promise returned by the iterator.next() method must fulfill with an object");
          }
          const done = IteratorComplete(iterResult);
          if (done) {
            ReadableStreamDefaultControllerClose(stream._readableStreamController);
          } else {
            const value2 = IteratorValue(iterResult);
            ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value2);
          }
        });
      }
      function cancelAlgorithm(reason) {
        const iterator3 = iteratorRecord.iterator;
        let returnMethod;
        try {
          returnMethod = GetMethod(iterator3, "return");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        if (returnMethod === undefined) {
          return promiseResolvedWith(undefined);
        }
        let returnResult;
        try {
          returnResult = reflectCall(returnMethod, iterator3, [reason]);
        } catch (e) {
          return promiseRejectedWith(e);
        }
        const returnPromise = promiseResolvedWith(returnResult);
        return transformPromiseWith(returnPromise, (iterResult) => {
          if (!typeIsObject(iterResult)) {
            throw new TypeError("The promise returned by the iterator.return() method must fulfill with an object");
          }
          return;
        });
      }
      stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
      return stream;
    }
    function ReadableStreamFromDefaultReader(reader) {
      let stream;
      const startAlgorithm = noop;
      function pullAlgorithm() {
        let readPromise;
        try {
          readPromise = reader.read();
        } catch (e) {
          return promiseRejectedWith(e);
        }
        return transformPromiseWith(readPromise, (readResult) => {
          if (!typeIsObject(readResult)) {
            throw new TypeError("The promise returned by the reader.read() method must fulfill with an object");
          }
          if (readResult.done) {
            ReadableStreamDefaultControllerClose(stream._readableStreamController);
          } else {
            const value2 = readResult.value;
            ReadableStreamDefaultControllerEnqueue(stream._readableStreamController, value2);
          }
        });
      }
      function cancelAlgorithm(reason) {
        try {
          return promiseResolvedWith(reader.cancel(reason));
        } catch (e) {
          return promiseRejectedWith(e);
        }
      }
      stream = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, 0);
      return stream;
    }
    function convertUnderlyingDefaultOrByteSource(source, context) {
      assertDictionary(source, context);
      const original = source;
      const autoAllocateChunkSize = original === null || original === undefined ? undefined : original.autoAllocateChunkSize;
      const cancel = original === null || original === undefined ? undefined : original.cancel;
      const pull = original === null || original === undefined ? undefined : original.pull;
      const start = original === null || original === undefined ? undefined : original.start;
      const type3 = original === null || original === undefined ? undefined : original.type;
      return {
        autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
        cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
        pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
        start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
        type: type3 === undefined ? undefined : convertReadableStreamType(type3, `${context} has member 'type' that`)
      };
    }
    function convertUnderlyingSourceCancelCallback(fn, original, context) {
      assertFunction(fn, context);
      return (reason) => promiseCall(fn, original, [reason]);
    }
    function convertUnderlyingSourcePullCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertUnderlyingSourceStartCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertReadableStreamType(type3, context) {
      type3 = `${type3}`;
      if (type3 !== "bytes") {
        throw new TypeError(`${context} '${type3}' is not a valid enumeration value for ReadableStreamType`);
      }
      return type3;
    }
    function convertIteratorOptions(options, context) {
      assertDictionary(options, context);
      const preventCancel = options === null || options === undefined ? undefined : options.preventCancel;
      return { preventCancel: Boolean(preventCancel) };
    }
    function convertPipeOptions(options, context) {
      assertDictionary(options, context);
      const preventAbort = options === null || options === undefined ? undefined : options.preventAbort;
      const preventCancel = options === null || options === undefined ? undefined : options.preventCancel;
      const preventClose = options === null || options === undefined ? undefined : options.preventClose;
      const signal = options === null || options === undefined ? undefined : options.signal;
      if (signal !== undefined) {
        assertAbortSignal(signal, `${context} has member 'signal' that`);
      }
      return {
        preventAbort: Boolean(preventAbort),
        preventCancel: Boolean(preventCancel),
        preventClose: Boolean(preventClose),
        signal
      };
    }
    function assertAbortSignal(signal, context) {
      if (!isAbortSignal(signal)) {
        throw new TypeError(`${context} is not an AbortSignal.`);
      }
    }
    function convertReadableWritablePair(pair, context) {
      assertDictionary(pair, context);
      const readable = pair === null || pair === undefined ? undefined : pair.readable;
      assertRequiredField(readable, "readable", "ReadableWritablePair");
      assertReadableStream(readable, `${context} has member 'readable' that`);
      const writable = pair === null || pair === undefined ? undefined : pair.writable;
      assertRequiredField(writable, "writable", "ReadableWritablePair");
      assertWritableStream(writable, `${context} has member 'writable' that`);
      return { readable, writable };
    }

    class ReadableStream2 {
      constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
        if (rawUnderlyingSource === undefined) {
          rawUnderlyingSource = null;
        } else {
          assertObject(rawUnderlyingSource, "First parameter");
        }
        const strategy = convertQueuingStrategy(rawStrategy, "Second parameter");
        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, "First parameter");
        InitializeReadableStream(this);
        if (underlyingSource.type === "bytes") {
          if (strategy.size !== undefined) {
            throw new RangeError("The strategy for a byte stream cannot have a size function");
          }
          const highWaterMark = ExtractHighWaterMark(strategy, 0);
          SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
        } else {
          const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
          const highWaterMark = ExtractHighWaterMark(strategy, 1);
          SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
        }
      }
      get locked() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("locked");
        }
        return IsReadableStreamLocked(this);
      }
      cancel(reason = undefined) {
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("cancel"));
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("Cannot cancel a stream that already has a reader"));
        }
        return ReadableStreamCancel(this, reason);
      }
      getReader(rawOptions = undefined) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("getReader");
        }
        const options = convertReaderOptions(rawOptions, "First parameter");
        if (options.mode === undefined) {
          return AcquireReadableStreamDefaultReader(this);
        }
        return AcquireReadableStreamBYOBReader(this);
      }
      pipeThrough(rawTransform, rawOptions = {}) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("pipeThrough");
        }
        assertRequiredArgument(rawTransform, 1, "pipeThrough");
        const transform4 = convertReadableWritablePair(rawTransform, "First parameter");
        const options = convertPipeOptions(rawOptions, "Second parameter");
        if (IsReadableStreamLocked(this)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");
        }
        if (IsWritableStreamLocked(transform4.writable)) {
          throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");
        }
        const promise3 = ReadableStreamPipeTo(this, transform4.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
        setPromiseIsHandledToTrue(promise3);
        return transform4.readable;
      }
      pipeTo(destination, rawOptions = {}) {
        if (!IsReadableStream(this)) {
          return promiseRejectedWith(streamBrandCheckException$1("pipeTo"));
        }
        if (destination === undefined) {
          return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
        }
        if (!IsWritableStream(destination)) {
          return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
        }
        let options;
        try {
          options = convertPipeOptions(rawOptions, "Second parameter");
        } catch (e) {
          return promiseRejectedWith(e);
        }
        if (IsReadableStreamLocked(this)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
        }
        if (IsWritableStreamLocked(destination)) {
          return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
        }
        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      }
      tee() {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("tee");
        }
        const branches = ReadableStreamTee(this);
        return CreateArrayFromList(branches);
      }
      values(rawOptions = undefined) {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1("values");
        }
        const options = convertIteratorOptions(rawOptions, "First parameter");
        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
      }
      [SymbolAsyncIterator](options) {
        return this.values(options);
      }
      static from(asyncIterable) {
        return ReadableStreamFrom(asyncIterable);
      }
    }
    Object.defineProperties(ReadableStream2, {
      from: { enumerable: true }
    });
    Object.defineProperties(ReadableStream2.prototype, {
      cancel: { enumerable: true },
      getReader: { enumerable: true },
      pipeThrough: { enumerable: true },
      pipeTo: { enumerable: true },
      tee: { enumerable: true },
      values: { enumerable: true },
      locked: { enumerable: true }
    });
    setFunctionName(ReadableStream2.from, "from");
    setFunctionName(ReadableStream2.prototype.cancel, "cancel");
    setFunctionName(ReadableStream2.prototype.getReader, "getReader");
    setFunctionName(ReadableStream2.prototype.pipeThrough, "pipeThrough");
    setFunctionName(ReadableStream2.prototype.pipeTo, "pipeTo");
    setFunctionName(ReadableStream2.prototype.tee, "tee");
    setFunctionName(ReadableStream2.prototype.values, "values");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ReadableStream2.prototype, Symbol.toStringTag, {
        value: "ReadableStream",
        configurable: true
      });
    }
    Object.defineProperty(ReadableStream2.prototype, SymbolAsyncIterator, {
      value: ReadableStream2.prototype.values,
      writable: true,
      configurable: true
    });
    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
      const stream = Object.create(ReadableStream2.prototype);
      InitializeReadableStream(stream);
      const controller = Object.create(ReadableStreamDefaultController.prototype);
      SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
      return stream;
    }
    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
      const stream = Object.create(ReadableStream2.prototype);
      InitializeReadableStream(stream);
      const controller = Object.create(ReadableByteStreamController.prototype);
      SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
      return stream;
    }
    function InitializeReadableStream(stream) {
      stream._state = "readable";
      stream._reader = undefined;
      stream._storedError = undefined;
      stream._disturbed = false;
    }
    function IsReadableStream(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_readableStreamController")) {
        return false;
      }
      return x instanceof ReadableStream2;
    }
    function IsReadableStreamLocked(stream) {
      if (stream._reader === undefined) {
        return false;
      }
      return true;
    }
    function ReadableStreamCancel(stream, reason) {
      stream._disturbed = true;
      if (stream._state === "closed") {
        return promiseResolvedWith(undefined);
      }
      if (stream._state === "errored") {
        return promiseRejectedWith(stream._storedError);
      }
      ReadableStreamClose(stream);
      const reader = stream._reader;
      if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
        const readIntoRequests = reader._readIntoRequests;
        reader._readIntoRequests = new SimpleQueue;
        readIntoRequests.forEach((readIntoRequest) => {
          readIntoRequest._closeSteps(undefined);
        });
      }
      const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
      return transformPromiseWith(sourceCancelPromise, noop);
    }
    function ReadableStreamClose(stream) {
      stream._state = "closed";
      const reader = stream._reader;
      if (reader === undefined) {
        return;
      }
      defaultReaderClosedPromiseResolve(reader);
      if (IsReadableStreamDefaultReader(reader)) {
        const readRequests = reader._readRequests;
        reader._readRequests = new SimpleQueue;
        readRequests.forEach((readRequest) => {
          readRequest._closeSteps();
        });
      }
    }
    function ReadableStreamError(stream, e) {
      stream._state = "errored";
      stream._storedError = e;
      const reader = stream._reader;
      if (reader === undefined) {
        return;
      }
      defaultReaderClosedPromiseReject(reader, e);
      if (IsReadableStreamDefaultReader(reader)) {
        ReadableStreamDefaultReaderErrorReadRequests(reader, e);
      } else {
        ReadableStreamBYOBReaderErrorReadIntoRequests(reader, e);
      }
    }
    function streamBrandCheckException$1(name) {
      return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
    }
    function convertQueuingStrategyInit(init, context) {
      assertDictionary(init, context);
      const highWaterMark = init === null || init === undefined ? undefined : init.highWaterMark;
      assertRequiredField(highWaterMark, "highWaterMark", "QueuingStrategyInit");
      return {
        highWaterMark: convertUnrestrictedDouble(highWaterMark)
      };
    }
    const byteLengthSizeFunction = (chunk) => {
      return chunk.byteLength;
    };
    setFunctionName(byteLengthSizeFunction, "size");

    class ByteLengthQueuingStrategy {
      constructor(options) {
        assertRequiredArgument(options, 1, "ByteLengthQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      get highWaterMark() {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException("highWaterMark");
        }
        return this._byteLengthQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException("size");
        }
        return byteLengthSizeFunction;
      }
    }
    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, {
        value: "ByteLengthQueuingStrategy",
        configurable: true
      });
    }
    function byteLengthBrandCheckException(name) {
      return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
    }
    function IsByteLengthQueuingStrategy(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_byteLengthQueuingStrategyHighWaterMark")) {
        return false;
      }
      return x instanceof ByteLengthQueuingStrategy;
    }
    const countSizeFunction = () => {
      return 1;
    };
    setFunctionName(countSizeFunction, "size");

    class CountQueuingStrategy {
      constructor(options) {
        assertRequiredArgument(options, 1, "CountQueuingStrategy");
        options = convertQueuingStrategyInit(options, "First parameter");
        this._countQueuingStrategyHighWaterMark = options.highWaterMark;
      }
      get highWaterMark() {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException("highWaterMark");
        }
        return this._countQueuingStrategyHighWaterMark;
      }
      get size() {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException("size");
        }
        return countSizeFunction;
      }
    }
    Object.defineProperties(CountQueuingStrategy.prototype, {
      highWaterMark: { enumerable: true },
      size: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, {
        value: "CountQueuingStrategy",
        configurable: true
      });
    }
    function countBrandCheckException(name) {
      return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
    }
    function IsCountQueuingStrategy(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_countQueuingStrategyHighWaterMark")) {
        return false;
      }
      return x instanceof CountQueuingStrategy;
    }
    function convertTransformer(original, context) {
      assertDictionary(original, context);
      const cancel = original === null || original === undefined ? undefined : original.cancel;
      const flush = original === null || original === undefined ? undefined : original.flush;
      const readableType = original === null || original === undefined ? undefined : original.readableType;
      const start = original === null || original === undefined ? undefined : original.start;
      const transform4 = original === null || original === undefined ? undefined : original.transform;
      const writableType = original === null || original === undefined ? undefined : original.writableType;
      return {
        cancel: cancel === undefined ? undefined : convertTransformerCancelCallback(cancel, original, `${context} has member 'cancel' that`),
        flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
        readableType,
        start: start === undefined ? undefined : convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
        transform: transform4 === undefined ? undefined : convertTransformerTransformCallback(transform4, original, `${context} has member 'transform' that`),
        writableType
      };
    }
    function convertTransformerFlushCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => promiseCall(fn, original, [controller]);
    }
    function convertTransformerStartCallback(fn, original, context) {
      assertFunction(fn, context);
      return (controller) => reflectCall(fn, original, [controller]);
    }
    function convertTransformerTransformCallback(fn, original, context) {
      assertFunction(fn, context);
      return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
    }
    function convertTransformerCancelCallback(fn, original, context) {
      assertFunction(fn, context);
      return (reason) => promiseCall(fn, original, [reason]);
    }

    class TransformStream {
      constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
        if (rawTransformer === undefined) {
          rawTransformer = null;
        }
        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, "Second parameter");
        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, "Third parameter");
        const transformer = convertTransformer(rawTransformer, "First parameter");
        if (transformer.readableType !== undefined) {
          throw new RangeError("Invalid readableType specified");
        }
        if (transformer.writableType !== undefined) {
          throw new RangeError("Invalid writableType specified");
        }
        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
        let startPromise_resolve;
        const startPromise = newPromise((resolve) => {
          startPromise_resolve = resolve;
        });
        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
        if (transformer.start !== undefined) {
          startPromise_resolve(transformer.start(this._transformStreamController));
        } else {
          startPromise_resolve(undefined);
        }
      }
      get readable() {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException("readable");
        }
        return this._readable;
      }
      get writable() {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException("writable");
        }
        return this._writable;
      }
    }
    Object.defineProperties(TransformStream.prototype, {
      readable: { enumerable: true },
      writable: { enumerable: true }
    });
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, {
        value: "TransformStream",
        configurable: true
      });
    }
    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
      function startAlgorithm() {
        return startPromise;
      }
      function writeAlgorithm(chunk) {
        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
      }
      function abortAlgorithm(reason) {
        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
      }
      function closeAlgorithm() {
        return TransformStreamDefaultSinkCloseAlgorithm(stream);
      }
      stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
      function pullAlgorithm() {
        return TransformStreamDefaultSourcePullAlgorithm(stream);
      }
      function cancelAlgorithm(reason) {
        return TransformStreamDefaultSourceCancelAlgorithm(stream, reason);
      }
      stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
      stream._backpressure = undefined;
      stream._backpressureChangePromise = undefined;
      stream._backpressureChangePromise_resolve = undefined;
      TransformStreamSetBackpressure(stream, true);
      stream._transformStreamController = undefined;
    }
    function IsTransformStream(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_transformStreamController")) {
        return false;
      }
      return x instanceof TransformStream;
    }
    function TransformStreamError(stream, e) {
      ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
      TransformStreamErrorWritableAndUnblockWrite(stream, e);
    }
    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
      TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
      WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
      TransformStreamUnblockWrite(stream);
    }
    function TransformStreamUnblockWrite(stream) {
      if (stream._backpressure) {
        TransformStreamSetBackpressure(stream, false);
      }
    }
    function TransformStreamSetBackpressure(stream, backpressure) {
      if (stream._backpressureChangePromise !== undefined) {
        stream._backpressureChangePromise_resolve();
      }
      stream._backpressureChangePromise = newPromise((resolve) => {
        stream._backpressureChangePromise_resolve = resolve;
      });
      stream._backpressure = backpressure;
    }

    class TransformStreamDefaultController {
      constructor() {
        throw new TypeError("Illegal constructor");
      }
      get desiredSize() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("desiredSize");
        }
        const readableController = this._controlledTransformStream._readable._readableStreamController;
        return ReadableStreamDefaultControllerGetDesiredSize(readableController);
      }
      enqueue(chunk = undefined) {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("enqueue");
        }
        TransformStreamDefaultControllerEnqueue(this, chunk);
      }
      error(reason = undefined) {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("error");
        }
        TransformStreamDefaultControllerError(this, reason);
      }
      terminate() {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException("terminate");
        }
        TransformStreamDefaultControllerTerminate(this);
      }
    }
    Object.defineProperties(TransformStreamDefaultController.prototype, {
      enqueue: { enumerable: true },
      error: { enumerable: true },
      terminate: { enumerable: true },
      desiredSize: { enumerable: true }
    });
    setFunctionName(TransformStreamDefaultController.prototype.enqueue, "enqueue");
    setFunctionName(TransformStreamDefaultController.prototype.error, "error");
    setFunctionName(TransformStreamDefaultController.prototype.terminate, "terminate");
    if (typeof Symbol.toStringTag === "symbol") {
      Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, {
        value: "TransformStreamDefaultController",
        configurable: true
      });
    }
    function IsTransformStreamDefaultController(x) {
      if (!typeIsObject(x)) {
        return false;
      }
      if (!Object.prototype.hasOwnProperty.call(x, "_controlledTransformStream")) {
        return false;
      }
      return x instanceof TransformStreamDefaultController;
    }
    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm) {
      controller._controlledTransformStream = stream;
      stream._transformStreamController = controller;
      controller._transformAlgorithm = transformAlgorithm;
      controller._flushAlgorithm = flushAlgorithm;
      controller._cancelAlgorithm = cancelAlgorithm;
      controller._finishPromise = undefined;
      controller._finishPromise_resolve = undefined;
      controller._finishPromise_reject = undefined;
    }
    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
      const controller = Object.create(TransformStreamDefaultController.prototype);
      let transformAlgorithm;
      let flushAlgorithm;
      let cancelAlgorithm;
      if (transformer.transform !== undefined) {
        transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
      } else {
        transformAlgorithm = (chunk) => {
          try {
            TransformStreamDefaultControllerEnqueue(controller, chunk);
            return promiseResolvedWith(undefined);
          } catch (transformResultE) {
            return promiseRejectedWith(transformResultE);
          }
        };
      }
      if (transformer.flush !== undefined) {
        flushAlgorithm = () => transformer.flush(controller);
      } else {
        flushAlgorithm = () => promiseResolvedWith(undefined);
      }
      if (transformer.cancel !== undefined) {
        cancelAlgorithm = (reason) => transformer.cancel(reason);
      } else {
        cancelAlgorithm = () => promiseResolvedWith(undefined);
      }
      SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm, cancelAlgorithm);
    }
    function TransformStreamDefaultControllerClearAlgorithms(controller) {
      controller._transformAlgorithm = undefined;
      controller._flushAlgorithm = undefined;
      controller._cancelAlgorithm = undefined;
    }
    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
      const stream = controller._controlledTransformStream;
      const readableController = stream._readable._readableStreamController;
      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
        throw new TypeError("Readable side is not in a state that permits enqueue");
      }
      try {
        ReadableStreamDefaultControllerEnqueue(readableController, chunk);
      } catch (e) {
        TransformStreamErrorWritableAndUnblockWrite(stream, e);
        throw stream._readable._storedError;
      }
      const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
      if (backpressure !== stream._backpressure) {
        TransformStreamSetBackpressure(stream, true);
      }
    }
    function TransformStreamDefaultControllerError(controller, e) {
      TransformStreamError(controller._controlledTransformStream, e);
    }
    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
      const transformPromise = controller._transformAlgorithm(chunk);
      return transformPromiseWith(transformPromise, undefined, (r) => {
        TransformStreamError(controller._controlledTransformStream, r);
        throw r;
      });
    }
    function TransformStreamDefaultControllerTerminate(controller) {
      const stream = controller._controlledTransformStream;
      const readableController = stream._readable._readableStreamController;
      ReadableStreamDefaultControllerClose(readableController);
      const error3 = new TypeError("TransformStream terminated");
      TransformStreamErrorWritableAndUnblockWrite(stream, error3);
    }
    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
      const controller = stream._transformStreamController;
      if (stream._backpressure) {
        const backpressureChangePromise = stream._backpressureChangePromise;
        return transformPromiseWith(backpressureChangePromise, () => {
          const writable = stream._writable;
          const state = writable._state;
          if (state === "erroring") {
            throw writable._storedError;
          }
          return TransformStreamDefaultControllerPerformTransform(controller, chunk);
        });
      }
      return TransformStreamDefaultControllerPerformTransform(controller, chunk);
    }
    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
      const controller = stream._transformStreamController;
      if (controller._finishPromise !== undefined) {
        return controller._finishPromise;
      }
      const readable = stream._readable;
      controller._finishPromise = newPromise((resolve, reject) => {
        controller._finishPromise_resolve = resolve;
        controller._finishPromise_reject = reject;
      });
      const cancelPromise = controller._cancelAlgorithm(reason);
      TransformStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(cancelPromise, () => {
        if (readable._state === "errored") {
          defaultControllerFinishPromiseReject(controller, readable._storedError);
        } else {
          ReadableStreamDefaultControllerError(readable._readableStreamController, reason);
          defaultControllerFinishPromiseResolve(controller);
        }
        return null;
      }, (r) => {
        ReadableStreamDefaultControllerError(readable._readableStreamController, r);
        defaultControllerFinishPromiseReject(controller, r);
        return null;
      });
      return controller._finishPromise;
    }
    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
      const controller = stream._transformStreamController;
      if (controller._finishPromise !== undefined) {
        return controller._finishPromise;
      }
      const readable = stream._readable;
      controller._finishPromise = newPromise((resolve, reject) => {
        controller._finishPromise_resolve = resolve;
        controller._finishPromise_reject = reject;
      });
      const flushPromise = controller._flushAlgorithm();
      TransformStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(flushPromise, () => {
        if (readable._state === "errored") {
          defaultControllerFinishPromiseReject(controller, readable._storedError);
        } else {
          ReadableStreamDefaultControllerClose(readable._readableStreamController);
          defaultControllerFinishPromiseResolve(controller);
        }
        return null;
      }, (r) => {
        ReadableStreamDefaultControllerError(readable._readableStreamController, r);
        defaultControllerFinishPromiseReject(controller, r);
        return null;
      });
      return controller._finishPromise;
    }
    function TransformStreamDefaultSourcePullAlgorithm(stream) {
      TransformStreamSetBackpressure(stream, false);
      return stream._backpressureChangePromise;
    }
    function TransformStreamDefaultSourceCancelAlgorithm(stream, reason) {
      const controller = stream._transformStreamController;
      if (controller._finishPromise !== undefined) {
        return controller._finishPromise;
      }
      const writable = stream._writable;
      controller._finishPromise = newPromise((resolve, reject) => {
        controller._finishPromise_resolve = resolve;
        controller._finishPromise_reject = reject;
      });
      const cancelPromise = controller._cancelAlgorithm(reason);
      TransformStreamDefaultControllerClearAlgorithms(controller);
      uponPromise(cancelPromise, () => {
        if (writable._state === "errored") {
          defaultControllerFinishPromiseReject(controller, writable._storedError);
        } else {
          WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, reason);
          TransformStreamUnblockWrite(stream);
          defaultControllerFinishPromiseResolve(controller);
        }
        return null;
      }, (r) => {
        WritableStreamDefaultControllerErrorIfNeeded(writable._writableStreamController, r);
        TransformStreamUnblockWrite(stream);
        defaultControllerFinishPromiseReject(controller, r);
        return null;
      });
      return controller._finishPromise;
    }
    function defaultControllerBrandCheckException(name) {
      return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
    }
    function defaultControllerFinishPromiseResolve(controller) {
      if (controller._finishPromise_resolve === undefined) {
        return;
      }
      controller._finishPromise_resolve();
      controller._finishPromise_resolve = undefined;
      controller._finishPromise_reject = undefined;
    }
    function defaultControllerFinishPromiseReject(controller, reason) {
      if (controller._finishPromise_reject === undefined) {
        return;
      }
      setPromiseIsHandledToTrue(controller._finishPromise);
      controller._finishPromise_reject(reason);
      controller._finishPromise_resolve = undefined;
      controller._finishPromise_reject = undefined;
    }
    function streamBrandCheckException(name) {
      return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
    }
    exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
    exports2.CountQueuingStrategy = CountQueuingStrategy;
    exports2.ReadableByteStreamController = ReadableByteStreamController;
    exports2.ReadableStream = ReadableStream2;
    exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
    exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
    exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
    exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
    exports2.TransformStream = TransformStream;
    exports2.TransformStreamDefaultController = TransformStreamDefaultController;
    exports2.WritableStream = WritableStream;
    exports2.WritableStreamDefaultController = WritableStreamDefaultController;
    exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
  });
});

// node_modules/fetch-blob/streams.cjs
var require_streams = __commonJS(() => {
  var POOL_SIZE = 65536;
  if (!globalThis.ReadableStream) {
    try {
      const process2 = __require("node:process");
      const { emitWarning } = process2;
      try {
        process2.emitWarning = () => {};
        Object.assign(globalThis, __require("node:stream/web"));
        process2.emitWarning = emitWarning;
      } catch (error3) {
        process2.emitWarning = emitWarning;
        throw error3;
      }
    } catch (error3) {
      Object.assign(globalThis, require_ponyfill_es2018());
    }
  }
  try {
    const { Blob: Blob2 } = __require("buffer");
    if (Blob2 && !Blob2.prototype.stream) {
      Blob2.prototype.stream = function name(params) {
        let position = 0;
        const blob = this;
        return new ReadableStream({
          type: "bytes",
          async pull(ctrl) {
            const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE));
            const buffer = await chunk.arrayBuffer();
            position += buffer.byteLength;
            ctrl.enqueue(new Uint8Array(buffer));
            if (position === blob.size) {
              ctrl.close();
            }
          }
        });
      };
    }
  } catch (error3) {}
});

// node_modules/fetch-blob/index.js
async function* toIterator(parts, clone4 = true) {
  for (const part of parts) {
    if ("stream" in part) {
      yield* part.stream();
    } else if (ArrayBuffer.isView(part)) {
      if (clone4) {
        let position = part.byteOffset;
        const end = part.byteOffset + part.byteLength;
        while (position !== end) {
          const size = Math.min(end - position, POOL_SIZE);
          const chunk = part.buffer.slice(position, position + size);
          position += chunk.byteLength;
          yield new Uint8Array(chunk);
        }
      } else {
        yield part;
      }
    } else {
      let position = 0, b = part;
      while (position !== b.size) {
        const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
      }
    }
  }
}
var import_streams, POOL_SIZE = 65536, _Blob, Blob3, fetch_blob_default;
var init_fetch_blob = __esm(() => {
  import_streams = __toESM(require_streams(), 1);
  /*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
  _Blob = class Blob2 {
    #parts = [];
    #type = "";
    #size = 0;
    #endings = "transparent";
    constructor(blobParts = [], options = {}) {
      if (typeof blobParts !== "object" || blobParts === null) {
        throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");
      }
      if (typeof blobParts[Symbol.iterator] !== "function") {
        throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");
      }
      if (typeof options !== "object" && typeof options !== "function") {
        throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
      }
      if (options === null)
        options = {};
      const encoder = new TextEncoder;
      for (const element of blobParts) {
        let part;
        if (ArrayBuffer.isView(element)) {
          part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
        } else if (element instanceof ArrayBuffer) {
          part = new Uint8Array(element.slice(0));
        } else if (element instanceof Blob2) {
          part = element;
        } else {
          part = encoder.encode(`${element}`);
        }
        this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
        this.#parts.push(part);
      }
      this.#endings = `${options.endings === undefined ? "transparent" : options.endings}`;
      const type3 = options.type === undefined ? "" : String(options.type);
      this.#type = /^[\x20-\x7E]*$/.test(type3) ? type3 : "";
    }
    get size() {
      return this.#size;
    }
    get type() {
      return this.#type;
    }
    async text() {
      const decoder = new TextDecoder;
      let str = "";
      for await (const part of toIterator(this.#parts, false)) {
        str += decoder.decode(part, { stream: true });
      }
      str += decoder.decode();
      return str;
    }
    async arrayBuffer() {
      const data = new Uint8Array(this.size);
      let offset = 0;
      for await (const chunk of toIterator(this.#parts, false)) {
        data.set(chunk, offset);
        offset += chunk.length;
      }
      return data.buffer;
    }
    stream() {
      const it = toIterator(this.#parts, true);
      return new globalThis.ReadableStream({
        type: "bytes",
        async pull(ctrl) {
          const chunk = await it.next();
          chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
        },
        async cancel() {
          await it.return();
        }
      });
    }
    slice(start = 0, end = this.size, type3 = "") {
      const { size } = this;
      let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
      let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
      const span = Math.max(relativeEnd - relativeStart, 0);
      const parts = this.#parts;
      const blobParts = [];
      let added = 0;
      for (const part of parts) {
        if (added >= span) {
          break;
        }
        const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
        if (relativeStart && size2 <= relativeStart) {
          relativeStart -= size2;
          relativeEnd -= size2;
        } else {
          let chunk;
          if (ArrayBuffer.isView(part)) {
            chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
            added += chunk.byteLength;
          } else {
            chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
            added += chunk.size;
          }
          relativeEnd -= size2;
          blobParts.push(chunk);
          relativeStart = 0;
        }
      }
      const blob = new Blob2([], { type: String(type3).toLowerCase() });
      blob.#size = span;
      blob.#parts = blobParts;
      return blob;
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
    static [Symbol.hasInstance](object3) {
      return object3 && typeof object3 === "object" && typeof object3.constructor === "function" && (typeof object3.stream === "function" || typeof object3.arrayBuffer === "function") && /^(Blob|File)$/.test(object3[Symbol.toStringTag]);
    }
  };
  Object.defineProperties(_Blob.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });
  Blob3 = _Blob;
  fetch_blob_default = Blob3;
});

// node_modules/fetch-blob/file.js
var _File, File2, file_default;
var init_file = __esm(() => {
  init_fetch_blob();
  _File = class File extends fetch_blob_default {
    #lastModified = 0;
    #name = "";
    constructor(fileBits, fileName, options = {}) {
      if (arguments.length < 2) {
        throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);
      }
      super(fileBits, options);
      if (options === null)
        options = {};
      const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
      if (!Number.isNaN(lastModified)) {
        this.#lastModified = lastModified;
      }
      this.#name = String(fileName);
    }
    get name() {
      return this.#name;
    }
    get lastModified() {
      return this.#lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
    static [Symbol.hasInstance](object3) {
      return !!object3 && object3 instanceof fetch_blob_default && /^(File)$/.test(object3[Symbol.toStringTag]);
    }
  };
  File2 = _File;
  file_default = File2;
});

// node_modules/formdata-polyfill/esm.min.js
function formDataToBlob(F, B = fetch_blob_default) {
  var b = `${r()}${r()}`.replace(/\./g, "").slice(-28).padStart(32, "-"), c = [], p = `--${b}\r
Content-Disposition: form-data; name="`;
  F.forEach((v, n) => typeof v == "string" ? c.push(p + e(n) + `"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, `\r
`)}\r
`) : c.push(p + e(n) + `"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || "application/octet-stream"}\r
\r
`, v, `\r
`));
  c.push(`--${b}--`);
  return new B(c, { type: "multipart/form-data; boundary=" + b });
}
var t2, i, h, r, m, f = (a, b, c) => (a += "", /^(Blob|File)$/.test(b && b[t2]) ? [(c = c !== undefined ? c + "" : b[t2] == "File" ? b.name : "blob", a), b.name !== c || b[t2] == "blob" ? new file_default([b], c, b) : b] : [a, b + ""]), e = (c, f2) => (f2 ? c : c.replace(/\r?\n|\r/g, `\r
`)).replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), x = (n, a, e2) => {
  if (a.length < e2) {
    throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`);
  }
}, FormData;
var init_esm_min = __esm(() => {
  init_fetch_blob();
  init_file();
  /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
  ({ toStringTag: t2, iterator: i, hasInstance: h } = Symbol);
  r = Math.random;
  m = "append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(",");
  FormData = class FormData2 {
    #d = [];
    constructor(...a) {
      if (a.length)
        throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`);
    }
    get [t2]() {
      return "FormData";
    }
    [i]() {
      return this.entries();
    }
    static [h](o) {
      return o && typeof o === "object" && o[t2] === "FormData" && !m.some((m2) => typeof o[m2] != "function");
    }
    append(...a) {
      x("append", arguments, 2);
      this.#d.push(f(...a));
    }
    delete(a) {
      x("delete", arguments, 1);
      a += "";
      this.#d = this.#d.filter(([b]) => b !== a);
    }
    get(a) {
      x("get", arguments, 1);
      a += "";
      for (var b = this.#d, l = b.length, c = 0;c < l; c++)
        if (b[c][0] === a)
          return b[c][1];
      return null;
    }
    getAll(a, b) {
      x("getAll", arguments, 1);
      b = [];
      a += "";
      this.#d.forEach((c) => c[0] === a && b.push(c[1]));
      return b;
    }
    has(a) {
      x("has", arguments, 1);
      a += "";
      return this.#d.some((b) => b[0] === a);
    }
    forEach(a, b) {
      x("forEach", arguments, 1);
      for (var [c, d] of this)
        a.call(b, d, c, this);
    }
    set(...a) {
      x("set", arguments, 2);
      var b = [], c = true;
      a = f(...a);
      this.#d.forEach((d) => {
        d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
      });
      c && b.push(a);
      this.#d = b;
    }
    *entries() {
      yield* this.#d;
    }
    *keys() {
      for (var [a] of this)
        yield a;
    }
    *values() {
      for (var [, a] of this)
        yield a;
    }
  };
});

// node_modules/node-domexception/index.js
var require_node_domexception = __commonJS((exports, module) => {
  /*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
  if (!globalThis.DOMException) {
    try {
      const { MessageChannel } = __require("worker_threads"), port = new MessageChannel().port1, ab = new ArrayBuffer;
      port.postMessage(ab, [ab, ab]);
    } catch (err) {
      err.constructor.name === "DOMException" && (globalThis.DOMException = err.constructor);
    }
  }
  module.exports = globalThis.DOMException;
});

// node_modules/fetch-blob/from.js
import { statSync, createReadStream, promises as fs } from "node:fs";
var import_node_domexception, stat, BlobDataItem;
var init_from = __esm(() => {
  import_node_domexception = __toESM(require_node_domexception(), 1);
  init_file();
  init_fetch_blob();
  ({ stat } = fs);
  BlobDataItem = class BlobDataItem {
    #path;
    #start;
    constructor(options) {
      this.#path = options.path;
      this.#start = options.start;
      this.size = options.size;
      this.lastModified = options.lastModified;
    }
    slice(start, end) {
      return new BlobDataItem({
        path: this.#path,
        lastModified: this.lastModified,
        size: end - start,
        start: this.#start + start
      });
    }
    async* stream() {
      const { mtimeMs } = await stat(this.#path);
      if (mtimeMs > this.lastModified) {
        throw new import_node_domexception.default("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.", "NotReadableError");
      }
      yield* createReadStream(this.#path, {
        start: this.#start,
        end: this.#start + this.size - 1
      });
    }
    get [Symbol.toStringTag]() {
      return "Blob";
    }
  };
});

// node_modules/node-fetch/src/utils/multipart-parser.js
var exports_multipart_parser = {};
__export(exports_multipart_parser, {
  toFormData: () => toFormData
});

class MultipartParser {
  constructor(boundary) {
    this.index = 0;
    this.flags = 0;
    this.onHeaderEnd = noop;
    this.onHeaderField = noop;
    this.onHeadersEnd = noop;
    this.onHeaderValue = noop;
    this.onPartBegin = noop;
    this.onPartData = noop;
    this.onPartEnd = noop;
    this.boundaryChars = {};
    boundary = `\r
--` + boundary;
    const ui8a = new Uint8Array(boundary.length);
    for (let i2 = 0;i2 < boundary.length; i2++) {
      ui8a[i2] = boundary.charCodeAt(i2);
      this.boundaryChars[ui8a[i2]] = true;
    }
    this.boundary = ui8a;
    this.lookbehind = new Uint8Array(this.boundary.length + 8);
    this.state = S.START_BOUNDARY;
  }
  write(data) {
    let i2 = 0;
    const length_ = data.length;
    let previousIndex = this.index;
    let { lookbehind, boundary, boundaryChars, index, state, flags } = this;
    const boundaryLength = this.boundary.length;
    const boundaryEnd = boundaryLength - 1;
    const bufferLength = data.length;
    let c;
    let cl;
    const mark = (name) => {
      this[name + "Mark"] = i2;
    };
    const clear = (name) => {
      delete this[name + "Mark"];
    };
    const callback = (callbackSymbol, start, end, ui8a) => {
      if (start === undefined || start !== end) {
        this[callbackSymbol](ui8a && ui8a.subarray(start, end));
      }
    };
    const dataCallback = (name, clear2) => {
      const markSymbol = name + "Mark";
      if (!(markSymbol in this)) {
        return;
      }
      if (clear2) {
        callback(name, this[markSymbol], i2, data);
        delete this[markSymbol];
      } else {
        callback(name, this[markSymbol], data.length, data);
        this[markSymbol] = 0;
      }
    };
    for (i2 = 0;i2 < length_; i2++) {
      c = data[i2];
      switch (state) {
        case S.START_BOUNDARY:
          if (index === boundary.length - 2) {
            if (c === HYPHEN) {
              flags |= F.LAST_BOUNDARY;
            } else if (c !== CR) {
              return;
            }
            index++;
            break;
          } else if (index - 1 === boundary.length - 2) {
            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
              state = S.END;
              flags = 0;
            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
              index = 0;
              callback("onPartBegin");
              state = S.HEADER_FIELD_START;
            } else {
              return;
            }
            break;
          }
          if (c !== boundary[index + 2]) {
            index = -2;
          }
          if (c === boundary[index + 2]) {
            index++;
          }
          break;
        case S.HEADER_FIELD_START:
          state = S.HEADER_FIELD;
          mark("onHeaderField");
          index = 0;
        case S.HEADER_FIELD:
          if (c === CR) {
            clear("onHeaderField");
            state = S.HEADERS_ALMOST_DONE;
            break;
          }
          index++;
          if (c === HYPHEN) {
            break;
          }
          if (c === COLON) {
            if (index === 1) {
              return;
            }
            dataCallback("onHeaderField", true);
            state = S.HEADER_VALUE_START;
            break;
          }
          cl = lower(c);
          if (cl < A || cl > Z) {
            return;
          }
          break;
        case S.HEADER_VALUE_START:
          if (c === SPACE) {
            break;
          }
          mark("onHeaderValue");
          state = S.HEADER_VALUE;
        case S.HEADER_VALUE:
          if (c === CR) {
            dataCallback("onHeaderValue", true);
            callback("onHeaderEnd");
            state = S.HEADER_VALUE_ALMOST_DONE;
          }
          break;
        case S.HEADER_VALUE_ALMOST_DONE:
          if (c !== LF) {
            return;
          }
          state = S.HEADER_FIELD_START;
          break;
        case S.HEADERS_ALMOST_DONE:
          if (c !== LF) {
            return;
          }
          callback("onHeadersEnd");
          state = S.PART_DATA_START;
          break;
        case S.PART_DATA_START:
          state = S.PART_DATA;
          mark("onPartData");
        case S.PART_DATA:
          previousIndex = index;
          if (index === 0) {
            i2 += boundaryEnd;
            while (i2 < bufferLength && !(data[i2] in boundaryChars)) {
              i2 += boundaryLength;
            }
            i2 -= boundaryEnd;
            c = data[i2];
          }
          if (index < boundary.length) {
            if (boundary[index] === c) {
              if (index === 0) {
                dataCallback("onPartData", true);
              }
              index++;
            } else {
              index = 0;
            }
          } else if (index === boundary.length) {
            index++;
            if (c === CR) {
              flags |= F.PART_BOUNDARY;
            } else if (c === HYPHEN) {
              flags |= F.LAST_BOUNDARY;
            } else {
              index = 0;
            }
          } else if (index - 1 === boundary.length) {
            if (flags & F.PART_BOUNDARY) {
              index = 0;
              if (c === LF) {
                flags &= ~F.PART_BOUNDARY;
                callback("onPartEnd");
                callback("onPartBegin");
                state = S.HEADER_FIELD_START;
                break;
              }
            } else if (flags & F.LAST_BOUNDARY) {
              if (c === HYPHEN) {
                callback("onPartEnd");
                state = S.END;
                flags = 0;
              } else {
                index = 0;
              }
            } else {
              index = 0;
            }
          }
          if (index > 0) {
            lookbehind[index - 1] = c;
          } else if (previousIndex > 0) {
            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
            callback("onPartData", 0, previousIndex, _lookbehind);
            previousIndex = 0;
            mark("onPartData");
            i2--;
          }
          break;
        case S.END:
          break;
        default:
          throw new Error(`Unexpected state entered: ${state}`);
      }
    }
    dataCallback("onHeaderField");
    dataCallback("onHeaderValue");
    dataCallback("onPartData");
    this.index = index;
    this.state = state;
    this.flags = flags;
  }
  end() {
    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {
      this.onPartEnd();
    } else if (this.state !== S.END) {
      throw new Error("MultipartParser.end(): stream ended unexpectedly");
    }
  }
}
function _fileName(headerValue) {
  const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  if (!m2) {
    return;
  }
  const match = m2[2] || m2[3] || "";
  let filename = match.slice(match.lastIndexOf("\\") + 1);
  filename = filename.replace(/%22/g, '"');
  filename = filename.replace(/&#(\d{4});/g, (m3, code) => {
    return String.fromCharCode(code);
  });
  return filename;
}
async function toFormData(Body, ct) {
  if (!/multipart/i.test(ct)) {
    throw new TypeError("Failed to fetch");
  }
  const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
  if (!m2) {
    throw new TypeError("no or bad content-type header, no multipart boundary");
  }
  const parser = new MultipartParser(m2[1] || m2[2]);
  let headerField;
  let headerValue;
  let entryValue;
  let entryName;
  let contentType;
  let filename;
  const entryChunks = [];
  const formData = new FormData;
  const onPartData = (ui8a) => {
    entryValue += decoder.decode(ui8a, { stream: true });
  };
  const appendToFile = (ui8a) => {
    entryChunks.push(ui8a);
  };
  const appendFileToFormData = () => {
    const file = new file_default(entryChunks, filename, { type: contentType });
    formData.append(entryName, file);
  };
  const appendEntryToFormData = () => {
    formData.append(entryName, entryValue);
  };
  const decoder = new TextDecoder("utf-8");
  decoder.decode();
  parser.onPartBegin = function() {
    parser.onPartData = onPartData;
    parser.onPartEnd = appendEntryToFormData;
    headerField = "";
    headerValue = "";
    entryValue = "";
    entryName = "";
    contentType = "";
    filename = null;
    entryChunks.length = 0;
  };
  parser.onHeaderField = function(ui8a) {
    headerField += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderValue = function(ui8a) {
    headerValue += decoder.decode(ui8a, { stream: true });
  };
  parser.onHeaderEnd = function() {
    headerValue += decoder.decode();
    headerField = headerField.toLowerCase();
    if (headerField === "content-disposition") {
      const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
      if (m3) {
        entryName = m3[2] || m3[3] || "";
      }
      filename = _fileName(headerValue);
      if (filename) {
        parser.onPartData = appendToFile;
        parser.onPartEnd = appendFileToFormData;
      }
    } else if (headerField === "content-type") {
      contentType = headerValue;
    }
    headerValue = "";
    headerField = "";
  };
  for await (const chunk of Body) {
    parser.write(chunk);
  }
  parser.end();
  return formData;
}
var s = 0, S, f2 = 1, F, LF = 10, CR = 13, SPACE = 32, HYPHEN = 45, COLON = 58, A = 97, Z = 122, lower = (c) => c | 32, noop = () => {};
var init_multipart_parser = __esm(() => {
  init_from();
  init_esm_min();
  S = {
    START_BOUNDARY: s++,
    HEADER_FIELD_START: s++,
    HEADER_FIELD: s++,
    HEADER_VALUE_START: s++,
    HEADER_VALUE: s++,
    HEADER_VALUE_ALMOST_DONE: s++,
    HEADERS_ALMOST_DONE: s++,
    PART_DATA_START: s++,
    PART_DATA: s++,
    END: s++
  };
  F = {
    PART_BOUNDARY: f2,
    LAST_BOUNDARY: f2 *= 2
  };
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports, module) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = __require("buffer");
  var Buffer4 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer4.from && Buffer4.alloc && Buffer4.allocUnsafe && Buffer4.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer4(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer4.prototype);
  copyProps(Buffer4, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer4(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer4(size);
    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer4(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var Buffer4 = require_safe_buffer().Buffer;
  var Stream3 = __require("stream");
  var util = __require("util");
  function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    if (!data) {
      this.buffer = Buffer4.alloc(0);
      return this;
    }
    if (typeof data.pipe === "function") {
      this.buffer = Buffer4.alloc(0);
      data.pipe(this);
      return this;
    }
    if (data.length || typeof data === "object") {
      this.buffer = data;
      this.writable = false;
      process.nextTick(function() {
        this.emit("end", data);
        this.readable = false;
        this.emit("close");
      }.bind(this));
      return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
  }
  util.inherits(DataStream, Stream3);
  DataStream.prototype.write = function write(data) {
    this.buffer = Buffer4.concat([this.buffer, Buffer4.from(data)]);
    this.emit("data", data);
  };
  DataStream.prototype.end = function end(data) {
    if (data)
      this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
  };
  module.exports = DataStream;
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS((exports, module) => {
  function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
  }
  var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
  };
  function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
      return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
  }
  module.exports = getParamBytesForAlg;
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS((exports, module) => {
  var Buffer4 = require_safe_buffer().Buffer;
  var getParamBytesForAlg = require_param_bytes_for_alg();
  var MAX_OCTET = 128;
  var CLASS_UNIVERSAL = 0;
  var PRIMITIVE_BIT = 32;
  var TAG_SEQ = 16;
  var TAG_INT = 2;
  var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
  var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
  function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function signatureAsBuffer(signature) {
    if (Buffer4.isBuffer(signature)) {
      return signature;
    } else if (typeof signature === "string") {
      return Buffer4.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
  }
  function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
      throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
      seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
      throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
      throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
      throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
      throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
      throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
      throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer4.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for (offset = 0;offset < rPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for (var o = offset;offset < o + sPadding; ++offset) {
      dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
  }
  function countPadding(buf, start, stop) {
    var padding = 0;
    while (start + padding < stop && buf[start + padding] === 0) {
      ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
      --padding;
    }
    return padding;
  }
  function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
      throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer4.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
      dst[offset++] = rsBytes;
    } else {
      dst[offset++] = MAX_OCTET | 1;
      dst[offset++] = rsBytes & 255;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
      dst[offset++] = 0;
      offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
      offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
      dst[offset++] = 0;
      signature.copy(dst, offset, paramBytes);
    } else {
      signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
  }
  module.exports = {
    derToJose,
    joseToDer
  };
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS((exports, module) => {
  var Buffer4 = __require("buffer").Buffer;
  var SlowBuffer = __require("buffer").SlowBuffer;
  module.exports = bufferEq;
  function bufferEq(a, b) {
    if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    var c = 0;
    for (var i2 = 0;i2 < a.length; i2++) {
      c |= a[i2] ^ b[i2];
    }
    return c === 0;
  }
  bufferEq.install = function() {
    Buffer4.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
      return bufferEq(this, that);
    };
  };
  var origBufEqual = Buffer4.prototype.equal;
  var origSlowBufEqual = SlowBuffer.prototype.equal;
  bufferEq.restore = function() {
    Buffer4.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
  };
});

// node_modules/jwa/index.js
var require_jwa = __commonJS((exports, module) => {
  var Buffer4 = require_safe_buffer().Buffer;
  var crypto3 = __require("crypto");
  var formatEcdsa = require_ecdsa_sig_formatter();
  var util = __require("util");
  var MSG_INVALID_ALGORITHM = `"%s" is not a valid algorithm.
  Supported algorithms are:
  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".`;
  var MSG_INVALID_SECRET = "secret must be a string or buffer";
  var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
  var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
  var supportsKeyObjects = typeof crypto3.createPublicKey === "function";
  if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
  }
  function checkIsPublicKey(key) {
    if (Buffer4.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
  }
  function checkIsPrivateKey(key) {
    if (Buffer4.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return;
    }
    if (typeof key === "object") {
      return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
  }
  function checkIsSecretKey(key) {
    if (Buffer4.isBuffer(key)) {
      return;
    }
    if (typeof key === "string") {
      return key;
    }
    if (!supportsKeyObjects) {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
      throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
      throw typeError(MSG_INVALID_SECRET);
    }
  }
  function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
      for (var i2 = 0;i2 < padding; ++i2) {
        base64url += "=";
      }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
  }
  function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
  }
  function bufferOrString(obj) {
    return Buffer4.isBuffer(obj) || typeof obj === "string";
  }
  function normalizeInput(thing) {
    if (!bufferOrString(thing))
      thing = JSON.stringify(thing);
    return thing;
  }
  function createHmacSigner(bits) {
    return function sign(thing, secret) {
      checkIsSecretKey(secret);
      thing = normalizeInput(thing);
      var hmac = crypto3.createHmac("sha" + bits, secret);
      var sig = (hmac.update(thing), hmac.digest("base64"));
      return fromBase64(sig);
    };
  }
  var bufferEqual;
  var timingSafeEqual = "timingSafeEqual" in crypto3 ? function timingSafeEqual(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    return crypto3.timingSafeEqual(a, b);
  } : function timingSafeEqual(a, b) {
    if (!bufferEqual) {
      bufferEqual = require_buffer_equal_constant_time();
    }
    return bufferEqual(a, b);
  };
  function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
      var computedSig = createHmacSigner(bits)(thing, secret);
      return timingSafeEqual(Buffer4.from(signature), Buffer4.from(computedSig));
    };
  }
  function createKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto3.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
      return fromBase64(sig);
    };
  }
  function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto3.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify(publicKey, signature, "base64");
    };
  }
  function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
      checkIsPrivateKey(privateKey);
      thing = normalizeInput(thing);
      var signer = crypto3.createSign("RSA-SHA" + bits);
      var sig = (signer.update(thing), signer.sign({
        key: privateKey,
        padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
      }, "base64"));
      return fromBase64(sig);
    };
  }
  function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
      checkIsPublicKey(publicKey);
      thing = normalizeInput(thing);
      signature = toBase64(signature);
      var verifier = crypto3.createVerify("RSA-SHA" + bits);
      verifier.update(thing);
      return verifier.verify({
        key: publicKey,
        padding: crypto3.constants.RSA_PKCS1_PSS_PADDING,
        saltLength: crypto3.constants.RSA_PSS_SALTLEN_DIGEST
      }, signature, "base64");
    };
  }
  function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
      var signature = inner.apply(null, arguments);
      signature = formatEcdsa.derToJose(signature, "ES" + bits);
      return signature;
    };
  }
  function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
      signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
      var result = inner(thing, signature, publicKey);
      return result;
    };
  }
  function createNoneSigner() {
    return function sign() {
      return "";
    };
  }
  function createNoneVerifier() {
    return function verify(thing, signature) {
      return signature === "";
    };
  }
  module.exports = function jwa(algorithm) {
    var signerFactories = {
      hs: createHmacSigner,
      rs: createKeySigner,
      ps: createPSSKeySigner,
      es: createECDSASigner,
      none: createNoneSigner
    };
    var verifierFactories = {
      hs: createHmacVerifier,
      rs: createKeyVerifier,
      ps: createPSSKeyVerifier,
      es: createECDSAVerifer,
      none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match)
      throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
      sign: signerFactories[algo](bits),
      verify: verifierFactories[algo](bits)
    };
  };
});

// node_modules/jws/lib/tostring.js
var require_tostring = __commonJS((exports, module) => {
  var Buffer4 = __require("buffer").Buffer;
  module.exports = function toString(obj) {
    if (typeof obj === "string")
      return obj;
    if (typeof obj === "number" || Buffer4.isBuffer(obj))
      return obj.toString();
    return JSON.stringify(obj);
  };
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS((exports, module) => {
  var Buffer4 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream3 = __require("stream");
  var toString = require_tostring();
  var util = __require("util");
  function base64url(string3, encoding) {
    return Buffer4.from(string3, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
  }
  function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
  }
  function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", function() {
      if (!this.payload.writable && this.readable)
        this.sign();
    }.bind(this));
    this.payload.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.sign();
    }.bind(this));
  }
  util.inherits(SignStream, Stream3);
  SignStream.prototype.sign = function sign() {
    try {
      var signature = jwsSign({
        header: this.header,
        payload: this.payload.buffer,
        secret: this.secret.buffer,
        encoding: this.encoding
      });
      this.emit("done", signature);
      this.emit("data", signature);
      this.emit("end");
      this.readable = false;
      return signature;
    } catch (e2) {
      this.readable = false;
      this.emit("error", e2);
      this.emit("close");
    }
  };
  SignStream.sign = jwsSign;
  module.exports = SignStream;
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS((exports, module) => {
  var Buffer4 = require_safe_buffer().Buffer;
  var DataStream = require_data_stream();
  var jwa = require_jwa();
  var Stream3 = __require("stream");
  var toString = require_tostring();
  var util = __require("util");
  var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
  function isObject2(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
  }
  function safeJsonParse(thing) {
    if (isObject2(thing))
      return thing;
    try {
      return JSON.parse(thing);
    } catch (e2) {
      return;
    }
  }
  function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer4.from(encodedHeader, "base64").toString("binary"));
  }
  function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
  }
  function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
  }
  function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer4.from(payload, "base64").toString(encoding);
  }
  function isValidJws(string3) {
    return JWS_REGEX.test(string3) && !!headerFromJWS(string3);
  }
  function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
      var err = new Error("Missing algorithm parameter for jws.verify");
      err.code = "MISSING_ALGORITHM";
      throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
  }
  function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig))
      return null;
    var header = headerFromJWS(jwsSig);
    if (!header)
      return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json)
      payload = JSON.parse(payload, opts.encoding);
    return {
      header,
      payload,
      signature: signatureFromJWS(jwsSig)
    };
  }
  function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", function() {
      if (!this.signature.writable && this.readable)
        this.verify();
    }.bind(this));
    this.signature.once("close", function() {
      if (!this.secret.writable && this.readable)
        this.verify();
    }.bind(this));
  }
  util.inherits(VerifyStream, Stream3);
  VerifyStream.prototype.verify = function verify() {
    try {
      var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
      var obj = jwsDecode(this.signature.buffer, this.encoding);
      this.emit("done", valid, obj);
      this.emit("data", valid);
      this.emit("end");
      this.readable = false;
      return valid;
    } catch (e2) {
      this.readable = false;
      this.emit("error", e2);
      this.emit("close");
    }
  };
  VerifyStream.decode = jwsDecode;
  VerifyStream.isValid = isValidJws;
  VerifyStream.verify = jwsVerify;
  module.exports = VerifyStream;
});

// node_modules/jws/index.js
var require_jws = __commonJS((exports) => {
  var SignStream = require_sign_stream();
  var VerifyStream = require_verify_stream();
  var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
  ];
  exports.ALGORITHMS = ALGORITHMS;
  exports.sign = SignStream.sign;
  exports.verify = VerifyStream.verify;
  exports.decode = VerifyStream.decode;
  exports.isValid = VerifyStream.isValid;
  exports.createSign = function createSign(opts) {
    return new SignStream(opts);
  };
  exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
  };
});

// node_modules/jsonwebtoken/decode.js
var require_decode2 = __commonJS((exports, module) => {
  var jws = require_jws();
  module.exports = function(jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
      return null;
    }
    var payload = decoded.payload;
    if (typeof payload === "string") {
      try {
        var obj = JSON.parse(payload);
        if (obj !== null && typeof obj === "object") {
          payload = obj;
        }
      } catch (e2) {}
    }
    if (options.complete === true) {
      return {
        header: decoded.header,
        payload,
        signature: decoded.signature
      };
    }
    return payload;
  };
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS((exports, module) => {
  var JsonWebTokenError = function(message, error3) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error3)
      this.inner = error3;
  };
  JsonWebTokenError.prototype = Object.create(Error.prototype);
  JsonWebTokenError.prototype.constructor = JsonWebTokenError;
  module.exports = JsonWebTokenError;
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = function(message, date3) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date3;
  };
  NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
  NotBeforeError.prototype.constructor = NotBeforeError;
  module.exports = NotBeforeError;
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
  };
  TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
  TokenExpiredError.prototype.constructor = TokenExpiredError;
  module.exports = TokenExpiredError;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var s2 = 1000;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d = h2 * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse3(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse3(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type3 = (match[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms / s2) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms, msAbs, s2, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS((exports, module) => {
  var ms = require_ms();
  module.exports = function(time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);
    if (typeof time === "string") {
      var milliseconds = ms(time);
      if (typeof milliseconds === "undefined") {
        return;
      }
      return Math.floor(timestamp + milliseconds / 1000);
    } else if (typeof time === "number") {
      return timestamp + time;
    } else {
      return;
    }
  };
});

// node_modules/semver/internal/constants.js
var require_constants5 = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {};
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants5();
  var debug = require_debug();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var safeSrc = exports.safeSrc = [];
  var t3 = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value2) => {
    for (const [token, max] of safeRegexReplacements) {
      value2 = value2.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value2;
  };
  var createToken = (name, value2, isGlobal) => {
    const safe = makeSafeRegex(value2);
    const index = R++;
    debug(name, index, value2);
    t3[name] = index;
    src[index] = value2;
    safeSrc[index] = safe;
    re[index] = new RegExp(value2, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t3.NUMERICIDENTIFIER]})\\.` + `(${src[t3.NUMERICIDENTIFIER]})\\.` + `(${src[t3.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t3.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t3.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t3.NONNUMERICIDENTIFIER]}|${src[t3.NUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t3.NONNUMERICIDENTIFIER]}|${src[t3.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASE", `(?:-(${src[t3.PRERELEASEIDENTIFIER]}(?:\\.${src[t3.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t3.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t3.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t3.BUILDIDENTIFIER]}(?:\\.${src[t3.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t3.MAINVERSION]}${src[t3.PRERELEASE]}?${src[t3.BUILD]}?`);
  createToken("FULL", `^${src[t3.FULLPLAIN]}$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t3.MAINVERSIONLOOSE]}${src[t3.PRERELEASELOOSE]}?${src[t3.BUILD]}?`);
  createToken("LOOSE", `^${src[t3.LOOSEPLAIN]}$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t3.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t3.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t3.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIER]})` + `(?:${src[t3.PRERELEASE]})?${src[t3.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t3.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t3.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t3.PRERELEASELOOSE]})?${src[t3.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAIN]}$`);
  createToken("XRANGELOOSE", `^${src[t3.GTLT]}\\s*${src[t3.XRANGEPLAINLOOSE]}$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t3.COERCEPLAIN]}(?:$|[^\\d])`);
  createToken("COERCEFULL", src[t3.COERCEPLAIN] + `(?:${src[t3.PRERELEASE]})?` + `(?:${src[t3.BUILD]})?` + `(?:$|[^\\d])`);
  createToken("COERCERTL", src[t3.COERCE], true);
  createToken("COERCERTLFULL", src[t3.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t3.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAIN]}$`);
  createToken("TILDELOOSE", `^${src[t3.LONETILDE]}${src[t3.XRANGEPLAINLOOSE]}$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t3.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAIN]}$`);
  createToken("CARETLOOSE", `^${src[t3.LONECARET]}${src[t3.XRANGEPLAINLOOSE]}$`);
  createToken("COMPARATORLOOSE", `^${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]})$|^$`);
  createToken("COMPARATOR", `^${src[t3.GTLT]}\\s*(${src[t3.FULLPLAIN]})$|^$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t3.GTLT]}\\s*(${src[t3.LOOSEPLAIN]}|${src[t3.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t3.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t3.XRANGEPLAIN]})` + `\\s*$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t3.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t3.XRANGEPLAINLOOSE]})` + `\\s*$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a, b) => {
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
      a = +a;
      b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
  };
  var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants5();
  var { safeRe: re, t: t3 } = require_re();
  var parseOptions = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version, options) {
      options = parseOptions(options);
      if (version instanceof SemVer) {
        if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m2 = version.trim().match(options.loose ? re[t3.LOOSE] : re[t3.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version}`);
      }
      this.raw = version;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i2 = 0;
      do {
        const a = this.prerelease[i2];
        const b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i2 = 0;
      do {
        const a = this.build[i2];
        const b = other.build[i2];
        debug("build compare", i2, a, b);
        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    }
    inc(release, identifier, identifierBase) {
      if (release.startsWith("pre")) {
        if (!identifier && identifierBase === false) {
          throw new Error("invalid increment argument: identifier is empty");
        }
        if (identifier) {
          const match = `-${identifier}`.match(this.options.loose ? re[t3.PRERELEASELOOSE] : re[t3.PRERELEASE]);
          if (!match || match[1] !== identifier) {
            throw new Error(`invalid identifier: ${identifier}`);
          }
        }
      }
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "release":
          if (this.prerelease.length === 0) {
            throw new Error(`version ${this.raw} is not a prerelease`);
          }
          this.prerelease.length = 0;
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse4 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse3 = (version, options, throwErrors = false) => {
    if (version instanceof SemVer) {
      return version;
    }
    try {
      return new SemVer(version, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse3;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse3 = require_parse4();
  var valid = (version, options) => {
    const v = parse3(version, options);
    return v ? v.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean3 = __commonJS((exports, module) => {
  var parse3 = require_parse4();
  var clean3 = (version, options) => {
    const s2 = parse3(version.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  };
  module.exports = clean3;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse3 = require_parse4();
  var diff = (version1, version2) => {
    const v1 = parse3(version1, null, true);
    const v2 = parse3(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (lowVersion.compareMain(highVersion) === 0) {
        if (lowVersion.minor && !lowVersion.patch) {
          return "minor";
        }
        return "patch";
      }
    }
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
      return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a, loose) => new SemVer(a, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a, loose) => new SemVer(a, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a, loose) => new SemVer(a, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse3 = require_parse4();
  var prerelease = (version, options) => {
    const parsed = parse3(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a, b, loose) => compare(b, a, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a, b) => compare(a, b, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a, b, loose) => {
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt = (a, b, loose) => compare(a, b, loose) > 0;
  module.exports = gt;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt = (a, b, loose) => compare(a, b, loose) < 0;
  module.exports = lt;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq = (a, b, loose) => compare(a, b, loose) === 0;
  module.exports = eq;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a, b, loose) => compare(a, b, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte = (a, b, loose) => compare(a, b, loose) >= 0;
  module.exports = gte;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte = (a, b, loose) => compare(a, b, loose) <= 0;
  module.exports = lte;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq = require_eq();
  var neq = require_neq();
  var gt = require_gt();
  var gte = require_gte();
  var lt = require_lt();
  var lte = require_lte();
  var cmp = (a, op, b, loose) => {
    switch (op) {
      case "===":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a === b;
      case "!==":
        if (typeof a === "object") {
          a = a.version;
        }
        if (typeof b === "object") {
          b = b.version;
        }
        return a !== b;
      case "":
      case "=":
      case "==":
        return eq(a, b, loose);
      case "!=":
        return neq(a, b, loose);
      case ">":
        return gt(a, b, loose);
      case ">=":
        return gte(a, b, loose);
      case "<":
        return lt(a, b, loose);
      case "<=":
        return lte(a, b, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse3 = require_parse4();
  var { safeRe: re, t: t3 } = require_re();
  var coerce = (version, options) => {
    if (version instanceof SemVer) {
      return version;
    }
    if (typeof version === "number") {
      version = String(version);
    }
    if (typeof version !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version.match(options.includePrerelease ? re[t3.COERCEFULL] : re[t3.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t3.COERCERTLFULL] : re[t3.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse3(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce;
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS((exports, module) => {
  class LRUCache {
    constructor() {
      this.max = 1000;
      this.map = new Map;
    }
    get(key) {
      const value2 = this.map.get(key);
      if (value2 === undefined) {
        return;
      } else {
        this.map.delete(key);
        this.map.set(key, value2);
        return value2;
      }
    }
    delete(key) {
      return this.map.delete(key);
    }
    set(key, value2) {
      const deleted = this.delete(key);
      if (!deleted && value2 !== undefined) {
        if (this.map.size >= this.max) {
          const firstKey = this.map.keys().next().value;
          this.delete(firstKey);
        }
        this.map.set(key, value2);
      }
      return this;
    }
  }
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  var SPACE_CHARACTERS = /\s+/g;

  class Range {
    constructor(range, options) {
      options = parseOptions(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.formatted = undefined;
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().replace(SPACE_CHARACTERS, " ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c) => c.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c) => !isNullSet(c[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c of this.set) {
            if (c.length === 1 && isAny(c[0])) {
              this.set = [c];
              break;
            }
          }
        }
      }
      this.formatted = undefined;
    }
    get range() {
      if (this.formatted === undefined) {
        this.formatted = "";
        for (let i2 = 0;i2 < this.set.length; i2++) {
          if (i2 > 0) {
            this.formatted += "||";
          }
          const comps = this.set[i2];
          for (let k = 0;k < comps.length; k++) {
            if (k > 0) {
              this.formatted += " ";
            }
            this.formatted += comps[k].toString().trim();
          }
        }
      }
      return this.formatted;
    }
    format() {
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t3.HYPHENRANGELOOSE] : re[t3.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t3.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t3.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t3.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t3.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result = [...rangeMap.values()];
      cache.set(memoKey, result);
      return result;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i2 = 0;i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lrucache();
  var cache = new LRU;
  var parseOptions = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t: t3,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants5();
  var isNullSet = (c) => c.value === "<0.0.0-0";
  var isAny = (c) => c.value === "";
  var isSatisfiable = (comparators, options) => {
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result && remainingComparators.length) {
      result = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r2 = options.loose ? re[t3.TILDELOOSE] : re[t3.TILDE];
    return comp.replace(r2, (_, M, m2, p, pr) => {
      debug("tilde", comp, _, M, m2, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.${p} <${M}.${+m2 + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r2 = options.loose ? re[t3.CARETLOOSE] : re[t3.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M, m2, p, pr) => {
      debug("caret", comp, _, M, m2, p, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
      } else if (isX(p)) {
        if (M === "0") {
          ret = `>=${M}.${m2}.0${z} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.0${z} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p}-${pr} <${M}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p}-${pr} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p}${z} <${M}.${m2}.${+p + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p}${z} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re[t3.XRANGELOOSE] : re[t3.XRANGE];
    return comp.replace(r2, (ret, gtlt, M, m2, p, pr) => {
      debug("xRange", comp, ret, gtlt, M, m2, p, pr);
      const xM = isX(M);
      const xm = xM || isX(m2);
      const xp = xm || isX(p);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p = 0;
          } else {
            m2 = +m2 + 1;
            p = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m2}.${p}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t3.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t3.GTE0PRE : t3.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set2, version, options) => {
    for (let i2 = 0;i2 < set2.length; i2++) {
      if (!set2[i2].test(version)) {
        return false;
      }
    }
    if (version.prerelease.length && !options.includePrerelease) {
      for (let i2 = 0;i2 < set2.length; i2++) {
        debug(set2[i2].semver);
        if (set2[i2].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i2].semver.prerelease.length > 0) {
          const allowed = set2[i2].semver;
          if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re[t3.COMPARATORLOOSE] : re[t3.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== undefined ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions = require_parse_options();
  var { safeRe: re, t: t3 } = require_re();
  var cmp = require_cmp();
  var debug = require_debug();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!max || maxSV.compare(v) === -1) {
          max = v;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v) => {
      if (rangeObj.test(v)) {
        if (!min || minSV.compare(v) === 1) {
          min = v;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i2 = 0;i2 < range.set.length; ++i2) {
      const comparators = range.set[i2];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt = require_gt();
  var lt = require_lt();
  var lte = require_lte();
  var gte = require_gte();
  var outside = (version, range, hilo, options) => {
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt;
        ltefn = lte;
        ltfn = lt;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt;
        ltefn = gte;
        ltfn = gt;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version, range, options)) {
      return false;
    }
    for (let i2 = 0;i2 < range.set.length; ++i2) {
      const comparators = range.set[i2];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version, range, options) => outside(version, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version, range, options) => outside(version, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r1, r2, options) => {
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b) => compare(a, b, options));
    for (const version of v) {
      const included = satisfies(version, range, options);
      if (included) {
        prev = version;
        if (!first) {
          first = version;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set2) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt, lt;
    for (const c of sub) {
      if (c.operator === ">" || c.operator === ">=") {
        gt = higherGT(gt, c, options);
      } else if (c.operator === "<" || c.operator === "<=") {
        lt = lowerLT(lt, c, options);
      } else {
        eqSet.add(c.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt && lt) {
      gtltComp = compare(gt.semver, lt.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
        return null;
      }
    }
    for (const eq of eqSet) {
      if (gt && !satisfies(eq, String(gt), options)) {
        return null;
      }
      if (lt && !satisfies(eq, String(lt), options)) {
        return null;
      }
      for (const c of dom) {
        if (!satisfies(eq, String(c), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower2;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c of dom) {
      hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
      hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
      if (gt) {
        if (needDomGTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c.operator === ">" || c.operator === ">=") {
          higher = higherGT(gt, c, options);
          if (higher === c && higher !== gt) {
            return false;
          }
        } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
          return false;
        }
      }
      if (lt) {
        if (needDomLTPre) {
          if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c.operator === "<" || c.operator === "<=") {
          lower2 = lowerLT(lt, c, options);
          if (lower2 === c && lower2 !== lt) {
            return false;
          }
        } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
          return false;
        }
      }
      if (!c.operator && (lt || gt) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
      return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
  };
  var lowerLT = (a, b, options) => {
    if (!a) {
      return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants5();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse3 = require_parse4();
  var valid = require_valid();
  var clean3 = require_clean3();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt = require_gt();
  var lt = require_lt();
  var eq = require_eq();
  var neq = require_neq();
  var gte = require_gte();
  var lte = require_lte();
  var cmp = require_cmp();
  var coerce = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse3,
    valid,
    clean: clean3,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=15.7.0");
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, ">=16.9.0");
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS((exports, module) => {
  var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
  var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
  var allowedAlgorithmsForKeys = {
    ec: ["ES256", "ES384", "ES512"],
    rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
    "rsa-pss": ["PS256", "PS384", "PS512"]
  };
  var allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
  };
  module.exports = function(algorithm, key) {
    if (!algorithm || !key)
      return;
    const keyType = key.asymmetricKeyType;
    if (!keyType)
      return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
      throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
      throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
      switch (keyType) {
        case "ec":
          const keyCurve = key.asymmetricKeyDetails.namedCurve;
          const allowedCurve = allowedCurves[algorithm];
          if (keyCurve !== allowedCurve) {
            throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
          }
          break;
        case "rsa-pss":
          if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
            const length = parseInt(algorithm.slice(-3), 10);
            const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
            if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
            }
            if (saltLength !== undefined && saltLength > length >> 3) {
              throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
            }
          }
          break;
      }
    }
  };
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS((exports, module) => {
  var semver = require_semver2();
  module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS((exports, module) => {
  var JsonWebTokenError = require_JsonWebTokenError();
  var NotBeforeError = require_NotBeforeError();
  var TokenExpiredError = require_TokenExpiredError();
  var decode2 = require_decode2();
  var timespan = require_timespan();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var PS_SUPPORTED = require_psSupported();
  var jws = require_jws();
  var { KeyObject, createSecretKey, createPublicKey } = __require("crypto");
  var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
  var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
  var HS_ALGS = ["HS256", "HS384", "HS512"];
  if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
  }
  module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
      callback = options;
      options = {};
    }
    if (!options) {
      options = {};
    }
    options = Object.assign({}, options);
    let done;
    if (callback) {
      done = callback;
    } else {
      done = function(err, data) {
        if (err)
          throw err;
        return data;
      };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
      return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
      return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
      return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
      return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
      return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
      return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
      decodedToken = decode2(jwtString, { complete: true });
    } catch (err) {
      return done(err);
    }
    if (!decodedToken) {
      return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
      if (!callback) {
        return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
      }
      getSecret = secretOrPublicKey;
    } else {
      getSecret = function(header2, secretCallback) {
        return secretCallback(null, secretOrPublicKey);
      };
    }
    return getSecret(header, function(err, secretOrPublicKey2) {
      if (err) {
        return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
      }
      const hasSignature = parts[2].trim() !== "";
      if (!hasSignature && secretOrPublicKey2) {
        return done(new JsonWebTokenError("jwt signature is required"));
      }
      if (hasSignature && !secretOrPublicKey2) {
        return done(new JsonWebTokenError("secret or public key must be provided"));
      }
      if (!hasSignature && !options.algorithms) {
        return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
      }
      if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject)) {
        try {
          secretOrPublicKey2 = createPublicKey(secretOrPublicKey2);
        } catch (_) {
          try {
            secretOrPublicKey2 = createSecretKey(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
          } catch (_2) {
            return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
          }
        }
      }
      if (!options.algorithms) {
        if (secretOrPublicKey2.type === "secret") {
          options.algorithms = HS_ALGS;
        } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
          options.algorithms = RSA_KEY_ALGS;
        } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
          options.algorithms = EC_KEY_ALGS;
        } else {
          options.algorithms = PUB_KEY_ALGS;
        }
      }
      if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
        return done(new JsonWebTokenError("invalid algorithm"));
      }
      if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
        return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPublicKey2);
        } catch (e2) {
          return done(e2);
        }
      }
      let valid;
      try {
        valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
      } catch (e2) {
        return done(e2);
      }
      if (!valid) {
        return done(new JsonWebTokenError("invalid signature"));
      }
      const payload = decodedToken.payload;
      if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
        if (typeof payload.nbf !== "number") {
          return done(new JsonWebTokenError("invalid nbf value"));
        }
        if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
          return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
        }
      }
      if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
        if (typeof payload.exp !== "number") {
          return done(new JsonWebTokenError("invalid exp value"));
        }
        if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
        }
      }
      if (options.audience) {
        const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
        const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
        const match = target.some(function(targetAudience) {
          return audiences.some(function(audience) {
            return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
          });
        });
        if (!match) {
          return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
        }
      }
      if (options.issuer) {
        const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
        if (invalid_issuer) {
          return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
        }
      }
      if (options.subject) {
        if (payload.sub !== options.subject) {
          return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
        }
      }
      if (options.jwtid) {
        if (payload.jti !== options.jwtid) {
          return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
        }
      }
      if (options.nonce) {
        if (payload.nonce !== options.nonce) {
          return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
        }
      }
      if (options.maxAge) {
        if (typeof payload.iat !== "number") {
          return done(new JsonWebTokenError("iat required when maxAge is specified"));
        }
        const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
        if (typeof maxAgeTimestamp === "undefined") {
          return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
        if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
          return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
        }
      }
      if (options.complete === true) {
        const signature = decodedToken.signature;
        return done(null, {
          header,
          payload,
          signature
        });
      }
      return done(null, payload);
    });
  };
});

// node_modules/lodash.includes/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  function arrayMap(array3, iteratee) {
    var index = -1, length = array3 ? array3.length : 0, result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array3[index], index, array3);
    }
    return result;
  }
  function baseFindIndex(array3, predicate, fromIndex, fromRight) {
    var length = array3.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array3[index], index, array3)) {
        return index;
      }
    }
    return -1;
  }
  function baseIndexOf(array3, value2, fromIndex) {
    if (value2 !== value2) {
      return baseFindIndex(array3, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array3.length;
    while (++index < length) {
      if (array3[index] === value2) {
        return index;
      }
    }
    return -1;
  }
  function baseIsNaN(value2) {
    return value2 !== value2;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseValues(object3, props) {
    return arrayMap(props, function(key) {
      return object3[key];
    });
  }
  function overArg(func, transform4) {
    return function(arg) {
      return func(transform4(arg));
    };
  }
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  function arrayLikeKeys(value2, inherited) {
    var result = isArray(value2) || isArguments(value2) ? baseTimes(value2.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value2) {
      if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseKeys(object3) {
    if (!isPrototype(object3)) {
      return nativeKeys(object3);
    }
    var result = [];
    for (var key in Object(object3)) {
      if (hasOwnProperty.call(object3, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function isIndex(value2, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value2 == "number" || reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
  }
  function isPrototype(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value2 === proto;
  }
  function includes(collection, value2, fromIndex, guard4) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard4 ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
      fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value2, fromIndex) > -1 : !!length && baseIndexOf(collection, value2, fromIndex) > -1;
  }
  function isArguments(value2) {
    return isArrayLikeObject(value2) && hasOwnProperty.call(value2, "callee") && (!propertyIsEnumerable.call(value2, "callee") || objectToString.call(value2) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value2) {
    return value2 != null && isLength(value2.length) && !isFunction(value2);
  }
  function isArrayLikeObject(value2) {
    return isObjectLike(value2) && isArrayLike(value2);
  }
  function isFunction(value2) {
    var tag = isObject2(value2) ? objectToString.call(value2) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  function isObject2(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isString(value2) {
    return typeof value2 == "string" || !isArray(value2) && isObjectLike(value2) && objectToString.call(value2) == stringTag;
  }
  function isSymbol(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
  }
  function toFinite(value2) {
    if (!value2) {
      return value2 === 0 ? value2 : 0;
    }
    value2 = toNumber(value2);
    if (value2 === INFINITY || value2 === -INFINITY) {
      var sign = value2 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value2 === value2 ? value2 : 0;
  }
  function toInteger(value2) {
    var result = toFinite(value2), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol(value2)) {
      return NAN;
    }
    if (isObject2(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject2(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = value2.replace(reTrim, "");
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  function keys(object3) {
    return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
  }
  function values(object3) {
    return object3 ? baseValues(object3, keys(object3)) : [];
  }
  module.exports = includes;
});

// node_modules/lodash.isboolean/index.js
var require_lodash3 = __commonJS((exports, module) => {
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isBoolean(value2) {
    return value2 === true || value2 === false || isObjectLike(value2) && objectToString.call(value2) == boolTag;
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  module.exports = isBoolean;
});

// node_modules/lodash.isinteger/index.js
var require_lodash4 = __commonJS((exports, module) => {
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isInteger(value2) {
    return typeof value2 == "number" && value2 == toInteger(value2);
  }
  function isObject2(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isSymbol(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
  }
  function toFinite(value2) {
    if (!value2) {
      return value2 === 0 ? value2 : 0;
    }
    value2 = toNumber(value2);
    if (value2 === INFINITY || value2 === -INFINITY) {
      var sign = value2 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value2 === value2 ? value2 : 0;
  }
  function toInteger(value2) {
    var result = toFinite(value2), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol(value2)) {
      return NAN;
    }
    if (isObject2(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject2(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = value2.replace(reTrim, "");
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  module.exports = isInteger;
});

// node_modules/lodash.isnumber/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var numberTag = "[object Number]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isNumber(value2) {
    return typeof value2 == "number" || isObjectLike(value2) && objectToString.call(value2) == numberTag;
  }
  module.exports = isNumber;
});

// node_modules/lodash.isplainobject/index.js
var require_lodash6 = __commonJS((exports, module) => {
  var objectTag = "[object Object]";
  function isHostObject(value2) {
    var result = false;
    if (value2 != null && typeof value2.toString != "function") {
      try {
        result = !!(value2 + "");
      } catch (e2) {}
    }
    return result;
  }
  function overArg(func, transform4) {
    return function(arg) {
      return func(transform4(arg));
    };
  }
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isPlainObject(value2) {
    if (!isObjectLike(value2) || objectToString.call(value2) != objectTag || isHostObject(value2)) {
      return false;
    }
    var proto = getPrototype(value2);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  module.exports = isPlainObject;
});

// node_modules/lodash.isstring/index.js
var require_lodash7 = __commonJS((exports, module) => {
  var stringTag = "[object String]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var isArray = Array.isArray;
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isString(value2) {
    return typeof value2 == "string" || !isArray(value2) && isObjectLike(value2) && objectToString.call(value2) == stringTag;
  }
  module.exports = isString;
});

// node_modules/lodash.once/index.js
var require_lodash8 = __commonJS((exports, module) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var INFINITY = 1 / 0;
  var MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function before(n, func) {
    var result;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
      if (--n > 0) {
        result = func.apply(this, arguments);
      }
      if (n <= 1) {
        func = undefined;
      }
      return result;
    };
  }
  function once(func) {
    return before(2, func);
  }
  function isObject2(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function isSymbol(value2) {
    return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
  }
  function toFinite(value2) {
    if (!value2) {
      return value2 === 0 ? value2 : 0;
    }
    value2 = toNumber(value2);
    if (value2 === INFINITY || value2 === -INFINITY) {
      var sign = value2 < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value2 === value2 ? value2 : 0;
  }
  function toInteger(value2) {
    var result = toFinite(value2), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value2) {
    if (typeof value2 == "number") {
      return value2;
    }
    if (isSymbol(value2)) {
      return NAN;
    }
    if (isObject2(value2)) {
      var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
      value2 = isObject2(other) ? other + "" : other;
    }
    if (typeof value2 != "string") {
      return value2 === 0 ? value2 : +value2;
    }
    value2 = value2.replace(reTrim, "");
    var isBinary = reIsBinary.test(value2);
    return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
  }
  module.exports = once;
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS((exports, module) => {
  var timespan = require_timespan();
  var PS_SUPPORTED = require_psSupported();
  var validateAsymmetricKey = require_validateAsymmetricKey();
  var jws = require_jws();
  var includes = require_lodash2();
  var isBoolean = require_lodash3();
  var isInteger = require_lodash4();
  var isNumber = require_lodash5();
  var isPlainObject = require_lodash6();
  var isString = require_lodash7();
  var once = require_lodash8();
  var { KeyObject, createSecretKey, createPrivateKey } = __require("crypto");
  var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
  if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
  }
  var sign_options_schema = {
    expiresIn: { isValid: function(value2) {
      return isInteger(value2) || isString(value2) && value2;
    }, message: '"expiresIn" should be a number of seconds or string representing a timespan' },
    notBefore: { isValid: function(value2) {
      return isInteger(value2) || isString(value2) && value2;
    }, message: '"notBefore" should be a number of seconds or string representing a timespan' },
    audience: { isValid: function(value2) {
      return isString(value2) || Array.isArray(value2);
    }, message: '"audience" must be a string or array' },
    algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
    header: { isValid: isPlainObject, message: '"header" must be an object' },
    encoding: { isValid: isString, message: '"encoding" must be a string' },
    issuer: { isValid: isString, message: '"issuer" must be a string' },
    subject: { isValid: isString, message: '"subject" must be a string' },
    jwtid: { isValid: isString, message: '"jwtid" must be a string' },
    noTimestamp: { isValid: isBoolean, message: '"noTimestamp" must be a boolean' },
    keyid: { isValid: isString, message: '"keyid" must be a string' },
    mutatePayload: { isValid: isBoolean, message: '"mutatePayload" must be a boolean' },
    allowInsecureKeySizes: { isValid: isBoolean, message: '"allowInsecureKeySizes" must be a boolean' },
    allowInvalidAsymmetricKeyTypes: { isValid: isBoolean, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
  };
  var registered_claims_schema = {
    iat: { isValid: isNumber, message: '"iat" should be a number of seconds' },
    exp: { isValid: isNumber, message: '"exp" should be a number of seconds' },
    nbf: { isValid: isNumber, message: '"nbf" should be a number of seconds' }
  };
  function validate(schema3, allowUnknown, object3, parameterName) {
    if (!isPlainObject(object3)) {
      throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object3).forEach(function(key) {
      const validator = schema3[key];
      if (!validator) {
        if (!allowUnknown) {
          throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
        }
        return;
      }
      if (!validator.isValid(object3[key])) {
        throw new Error(validator.message);
      }
    });
  }
  function validateOptions(options) {
    return validate(sign_options_schema, false, options, "options");
  }
  function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
  }
  var options_to_payload = {
    audience: "aud",
    issuer: "iss",
    subject: "sub",
    jwtid: "jti"
  };
  var options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
  ];
  module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    } else {
      options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
      alg: options.algorithm || "HS256",
      typ: isObjectPayload ? "JWT" : undefined,
      kid: options.keyid
    }, options.header);
    function failure(err) {
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
      return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
      try {
        secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
      } catch (_) {
        try {
          secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
        } catch (_2) {
          return failure(new Error("secretOrPrivateKey is not valid key material"));
        }
      }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
      return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
      if (secretOrPrivateKey.type !== "private") {
        return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
      }
      if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
        return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
      }
    }
    if (typeof payload === "undefined") {
      return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
      try {
        validatePayload(payload);
      } catch (error3) {
        return failure(error3);
      }
      if (!options.mutatePayload) {
        payload = Object.assign({}, payload);
      }
    } else {
      const invalid_options = options_for_objects.filter(function(opt) {
        return typeof options[opt] !== "undefined";
      });
      if (invalid_options.length > 0) {
        return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
      }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
      return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
      return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
      validateOptions(options);
    } catch (error3) {
      return failure(error3);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
      try {
        validateAsymmetricKey(header.alg, secretOrPrivateKey);
      } catch (error3) {
        return failure(error3);
      }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
      delete payload.iat;
    } else if (isObjectPayload) {
      payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
      try {
        payload.nbf = timespan(options.notBefore, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.nbf === "undefined") {
        return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
      try {
        payload.exp = timespan(options.expiresIn, timestamp);
      } catch (err) {
        return failure(err);
      }
      if (typeof payload.exp === "undefined") {
        return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
      }
    }
    Object.keys(options_to_payload).forEach(function(key) {
      const claim = options_to_payload[key];
      if (typeof options[key] !== "undefined") {
        if (typeof payload[claim] !== "undefined") {
          return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
        }
        payload[claim] = options[key];
      }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
      callback = callback && once(callback);
      jws.createSign({
        header,
        privateKey: secretOrPrivateKey,
        payload,
        encoding
      }).once("error", callback).once("done", function(signature) {
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
        callback(null, signature);
      });
    } else {
      let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
      if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
        throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
      }
      return signature;
    }
  };
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS((exports, module) => {
  module.exports = {
    decode: require_decode2(),
    verify: require_verify(),
    sign: require_sign(),
    JsonWebTokenError: require_JsonWebTokenError(),
    NotBeforeError: require_NotBeforeError(),
    TokenExpiredError: require_TokenExpiredError()
  };
});

// src/index.ts
var import_cors = __toESM(require_cjs4(), 1);
var import_cron2 = __toESM(require_cjs5(), 1);
var import_swagger = __toESM(require_cjs6(), 1);

// node_modules/memoirist/dist/index.mjs
var createNode = (part, inert) => ({
  part,
  store: null,
  inert: inert !== undefined ? new Map(inert.map((child) => [child.part.charCodeAt(0), child])) : null,
  params: null,
  wildcardStore: null
});
var cloneNode = (node, part) => ({
  ...node,
  part
});
var createParamNode = (paramName) => ({
  paramName,
  store: null,
  inert: null
});
var Memoirist = class _Memoirist {
  root = {};
  history = [];
  static regex = {
    static: /:.+?(?=\/|$)/,
    params: /:.+?(?=\/|$)/g
  };
  add(method, path, store) {
    if (typeof path !== "string")
      throw new TypeError("Route path must be a string");
    if (path === "")
      path = "/";
    else if (path[0] !== "/")
      path = `/${path}`;
    this.history.push([method, path, store]);
    const isWildcard = path[path.length - 1] === "*";
    if (isWildcard) {
      path = path.slice(0, -1);
    }
    const inertParts = path.split(_Memoirist.regex.static);
    const paramParts = path.match(_Memoirist.regex.params) || [];
    if (inertParts[inertParts.length - 1] === "")
      inertParts.pop();
    let node;
    if (!this.root[method])
      node = this.root[method] = createNode("/");
    else
      node = this.root[method];
    let paramPartsIndex = 0;
    for (let i = 0;i < inertParts.length; ++i) {
      let part = inertParts[i];
      if (i > 0) {
        const param = paramParts[paramPartsIndex++].slice(1);
        if (node.params === null)
          node.params = createParamNode(param);
        else if (node.params.paramName !== param)
          throw new Error(`Cannot create route "${path}" with parameter "${param}" because a route already exists with a different parameter name ("${node.params.paramName}") in the same location`);
        const params = node.params;
        if (params.inert === null) {
          node = params.inert = createNode(part);
          continue;
        }
        node = params.inert;
      }
      for (let j = 0;; ) {
        if (j === part.length) {
          if (j < node.part.length) {
            const childNode = cloneNode(node, node.part.slice(j));
            Object.assign(node, createNode(part, [childNode]));
          }
          break;
        }
        if (j === node.part.length) {
          if (node.inert === null)
            node.inert = /* @__PURE__ */ new Map;
          else if (node.inert.has(part.charCodeAt(j))) {
            node = node.inert.get(part.charCodeAt(j));
            part = part.slice(j);
            j = 0;
            continue;
          }
          const childNode = createNode(part.slice(j));
          node.inert.set(part.charCodeAt(j), childNode);
          node = childNode;
          break;
        }
        if (part[j] !== node.part[j]) {
          const existingChild = cloneNode(node, node.part.slice(j));
          const newChild = createNode(part.slice(j));
          Object.assign(node, createNode(node.part.slice(0, j), [
            existingChild,
            newChild
          ]));
          node = newChild;
          break;
        }
        ++j;
      }
    }
    if (paramPartsIndex < paramParts.length) {
      const param = paramParts[paramPartsIndex];
      const paramName = param.slice(1);
      if (node.params === null)
        node.params = createParamNode(paramName);
      else if (node.params.paramName !== paramName)
        throw new Error(`Cannot create route "${path}" with parameter "${paramName}" because a route already exists with a different parameter name ("${node.params.paramName}") in the same location`);
      if (node.params.store === null)
        node.params.store = store;
      return node.params.store;
    }
    if (isWildcard) {
      if (node.wildcardStore === null)
        node.wildcardStore = store;
      return node.wildcardStore;
    }
    if (node.store === null)
      node.store = store;
    return node.store;
  }
  find(method, url) {
    const root = this.root[method];
    if (!root)
      return null;
    return matchRoute(url, url.length, root, 0);
  }
};
var matchRoute = (url, urlLength, node, startIndex) => {
  const part = node?.part;
  const endIndex = startIndex + part.length;
  if (part.length > 1) {
    if (endIndex > urlLength)
      return null;
    if (part.length < 15) {
      for (let i = 1, j = startIndex + 1;i < part.length; ++i, ++j)
        if (part.charCodeAt(i) !== url.charCodeAt(j))
          return null;
    } else if (url.substring(startIndex, endIndex) !== part)
      return null;
  }
  if (endIndex === urlLength) {
    if (node.store !== null)
      return {
        store: node.store,
        params: {}
      };
    if (node.wildcardStore !== null)
      return {
        store: node.wildcardStore,
        params: { "*": "" }
      };
    return null;
  }
  if (node.inert !== null) {
    const inert = node.inert.get(url.charCodeAt(endIndex));
    if (inert !== undefined) {
      const route = matchRoute(url, urlLength, inert, endIndex);
      if (route !== null)
        return route;
    }
  }
  if (node.params !== null) {
    const param = node.params;
    const slashIndex = url.indexOf("/", endIndex);
    if (slashIndex !== endIndex) {
      if (slashIndex === -1 || slashIndex >= urlLength) {
        if (param.store !== null) {
          const params = {};
          params[param.paramName] = url.substring(endIndex, urlLength);
          return {
            store: param.store,
            params
          };
        }
      } else if (param.inert !== null) {
        const route = matchRoute(url, urlLength, param.inert, slashIndex);
        if (route !== null) {
          route.params[param.paramName] = url.substring(endIndex, slashIndex);
          return route;
        }
      }
    }
  }
  if (node.wildcardStore !== null)
    return {
      store: node.wildcardStore,
      params: {
        "*": url.substring(endIndex, urlLength)
      }
    };
  return null;
};

// node_modules/eventemitter3/index.mjs
var import__ = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import__.default;

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}
// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}
// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternNever = "(?!.*)";
var PatternBooleanExact = `^${PatternBoolean}$`;
var PatternNumberExact = `^${PatternNumber}$`;
var PatternStringExact = `^${PatternString}$`;
var PatternNeverExact = `^${PatternNever}$`;
// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}
// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Expected required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with $id '${schema.$id}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}
// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key);
    Visit3(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}
// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator2) {
    this.iterator = iterator2;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value) {
  return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };
}
function* FromAny(schema, references, path, value) {}
function* FromArray3(schema, references, path, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit4(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator(schema, references, path, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt(schema, references, path, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean(schema, references, path, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor(schema, references, path, value) {
  yield* Visit4(schema.returns, references, path, value.prototype);
}
function* FromDate(schema, references, path, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction(schema, references, path, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromInteger(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect3(schema, references, path, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral2(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot(schema, references, path, value) {
  if (Visit4(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull(schema, references, path, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromRegExp(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral2(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromTuple3(schema, references, path, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined(schema, references, path, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion5(schema, references, path, value) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors = [...Visit4(subschema, references, path, value)];
    if (errors.length === 0)
      return;
    count += errors.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value);
  }
}
function* FromUint8Array(schema, references, path, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown(schema, references, path, value) {}
function* FromVoid(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind(schema, references, path, value) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit4(schema, references, path, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value);
    case "Date":
      return yield* FromDate(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value);
    case "Never":
      return yield* FromNever(schema_, references_, path, value);
    case "Not":
      return yield* FromNot(schema_, references_, path, value);
    case "Null":
      return yield* FromNull(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value);
    case "Object":
      return yield* FromObject(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value);
    case "String":
      return yield* FromString(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value);
    case "This":
      return yield* FromThis(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator2 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator2);
}
// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
}
function FromStringRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== undefined;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element) => Clone2(element));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {}();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {}();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}
// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object2 = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object2.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal2 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union3, references, value) {
  const schemas = union3.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union3, references, value) {
  if ("default" in union3) {
    return typeof value === "function" ? union3.default : Clone2(union3.default);
  } else {
    const schema = SelectUnion(union3, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {};
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped2 = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped2) ? mapped2 : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (key in schema.properties) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key of Object.keys(value)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value[key]) : value[key];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  return value === undefined && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone2 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType6(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType4(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit13(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value, error2);
  }
}
function FromArray11(schema, references, path, value) {
  return IsArray(value) ? Default4(schema, path, value.map((value2, index) => Visit14(schema.items, references, `${path}/${index}`, value2))) : Default4(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromNot5(schema, references, path, value) {
  return Default4(schema, path, Visit14(schema.not, references, path, value));
}
function FromObject9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRecord9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromTuple11(schema, references, path, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value[index]))) : Default4(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path, value);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value);
}
function Visit14(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject9(schema_, references_, path, value);
    case "Record":
      return FromRecord9(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "Symbol":
      return Default4(schema_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default5(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value, error2);
  }
}
function FromArray12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  return IsArray(defaulted) ? defaulted.map((value2, index) => Visit15(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default5(schema.not, path, Default5(schema, path, value));
}
function FromObject10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromThis9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromTuple12(schema, references, path, value) {
  const value1 = Default5(schema, path, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path, value);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value);
}
function Visit15(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef9(schema_, references_, path, value);
    case "This":
      return FromThis9(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default5(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly(FromValue(value2[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value2, root) {
  return IsAsyncIterator2(value2) ? ConditionalReadonly(Any(), root) : IsIterator2(value2) ? ConditionalReadonly(Any(), root) : IsArray2(value2) ? Readonly(Tuple(FromArray14(value2))) : IsUint8Array2(value2) ? Uint8Array2() : IsDate2(value2) ? Date2() : IsObject2(value2) ? ConditionalReadonly(Object2(FromProperties8(value2)), root) : IsFunction2(value2) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value2) ? Undefined() : IsNull2(value2) ? Null() : IsSymbol2(value2) ? Symbol2() : IsBigInt2(value2) ? BigInt2() : IsNumber2(value2) ? Literal(value2) : IsBoolean2(value2) ? Literal(value2) : IsString2(value2) ? Literal(value2) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with $id ${schema.$ref}`);
  const discard2 = Discard(target, ["$id"]);
  return Deref2(discard2, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal(value2));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value2) => Literal(value2));
  const mapped2 = FromRest6(literals, mode);
  const union3 = Union(mapped2);
  return TemplateLiteral([union3], options);
}
function FromLiteralValue(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern2 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern2, T, options);
}
function FromAnyKey(K, T, options) {
  return RecordCreateFromPattern(PatternStringExact, T, options);
}
function FromNeverKey(K, T, options) {
  return RecordCreateFromPattern(PatternNeverExact, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : IsAny(K) ? FromAnyKey(K, T, options) : IsNever(K) ? FromNeverKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value2) => schema2[TransformKind].Encode(encode2(value2));
    const Decode2 = (value2) => this.decode(schema2[TransformKind].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}
// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value2) {
    return Errors(this.schema, this.references, value2);
  }
  Check(value2) {
    return this.checkFunc(value2);
  }
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value2) : value2;
  }
  Encode(value2) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i = 0;i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      const check3 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check3)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object3, key) {
    return IsAccessor(key) ? `${object3}.${key}` : `${object3}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value2} === 'number'` : `Number.isFinite(${value2})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value2) {
    yield "true";
  }
  function* FromArray16(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value2}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value2}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check3 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check3}})(${value2})`;
    }
    if (schema3.uniqueItems === true) {
      const check3 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check3} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* FromBigInt6(schema3, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value2} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value2} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value2} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value2} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value2} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value2) {
    yield* Visit17(schema3.returns, references, `${value2}.prototype`);
  }
  function* FromDate6(schema3, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* FromInteger6(schema3, references, value2) {
    yield `Number.isInteger(${value2})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value2) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value2)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* FromLiteral7(schema3, references, value2) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value2} === ${schema3.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value2) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value2) {
    const expression = CreateExpression(schema3.not, references, value2);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value2) {
    yield `(${value2} === null)`;
  }
  function* FromNumber6(schema3, references, value2) {
    yield Policy.IsNumberLike(value2);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value2) {
    yield Policy.IsObjectLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value2) {
    yield Policy.IsRecordLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value2) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value2) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
    yield* Visit17(target, references, value2);
  }
  function* FromRegExp5(schema3, references, value2) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value2})`;
  }
  function* FromString6(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value2})`;
    }
  }
  function* FromSymbol6(schema3, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* FromThis11(schema3, references, value2) {
    yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
  }
  function* FromTuple15(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema3.items === undefined)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value2}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value2) {
    yield `${value2} === undefined`;
  }
  function* FromUnion20(schema3, references, value2) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value2}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value2}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value2) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* FromKind4(schema3, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value2})`;
  }
  function* Visit17(schema3, references, value2, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value2);
      case "Array":
        return yield* FromArray16(schema_, references_, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value2);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value2);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value2);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value2);
      case "Date":
        return yield* FromDate6(schema_, references_, value2);
      case "Function":
        return yield* FromFunction7(schema_, references_, value2);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value2);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value2);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value2);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value2);
      case "Never":
        return yield* FromNever6(schema_, references_, value2);
      case "Not":
        return yield* FromNot8(schema_, references_, value2);
      case "Null":
        return yield* FromNull6(schema_, references_, value2);
      case "Number":
        return yield* FromNumber6(schema_, references_, value2);
      case "Object":
        return yield* FromObject13(schema_, references_, value2);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value2);
      case "Record":
        return yield* FromRecord12(schema_, references_, value2);
      case "Ref":
        return yield* FromRef12(schema_, references_, value2);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value2);
      case "String":
        return yield* FromString6(schema_, references_, value2);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value2);
      case "This":
        return yield* FromThis11(schema_, references_, value2);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value2);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value2);
      case "Union":
        return yield* FromUnion20(schema_, references_, value2);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value2);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value2);
      case "Void":
        return yield* FromVoid5(schema_, references_, value2);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value2, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value2, useHoisting = true) {
    const [newline, pad] = [`
`, (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})
}`;
  }
  function CreateParameter(name, type3) {
    const annotation = state.language === "typescript" ? `: ${type3}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type3) {
    return state.language === "typescript" ? `: ${type3}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {
  return ${CreateFunctionName(schema3.$id)}(value)
}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join(`
`);
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value2);
    }
    function formatRegistryFunction(format, value2) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return Hash(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/index.mjs
var import_cookie = __toESM(require_cookie(), 1);
var import_cookie2 = __toESM(require_cookie(), 1);
var import_fast_querystring = __toESM(require_lib(), 1);
var import_fast_decode_uri_component = __toESM(require_fast_decode_uri_component(), 1);
var import_fast_querystring2 = __toESM(require_lib(), 1);
var resolver = () => {
  let resolve;
  const promise3 = new Promise((r) => {
    resolve = r;
  });
  return [promise3, resolve];
};
var createSignal = () => {
  const [start, resolveStart] = resolver();
  const [end, resolveEnd] = resolver();
  const children = [];
  const resolvers = [];
  return {
    signal: start,
    consume: (trace) => {
      switch (trace.type) {
        case "begin":
          if (trace.unit && children.length === 0)
            for (let i = 0;i < trace.unit; i++) {
              const [start2, resolveStart2] = resolver();
              const [end2, resolveEnd2] = resolver();
              children.push(start2);
              resolvers.push([
                (trace2) => {
                  resolveStart2({
                    children: [],
                    end: end2,
                    name: trace2.name ?? "",
                    skip: false,
                    time: trace2.time
                  });
                },
                (time) => {
                  resolveEnd2(time);
                }
              ]);
            }
          resolveStart({
            children,
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          resolveEnd(trace.time);
          break;
      }
    },
    consumeChild(trace) {
      switch (trace.type) {
        case "begin":
          if (!resolvers[0])
            return;
          const [resolveStart2] = resolvers[0];
          resolveStart2({
            children: [],
            end,
            name: trace.name ?? "",
            skip: false,
            time: trace.time
          });
          break;
        case "end":
          const child = resolvers.shift();
          if (!child)
            return;
          child[1](trace.time);
      }
    },
    resolve() {
      resolveStart({
        children: [],
        end: new Promise((resolve) => resolve(0)),
        name: "",
        skip: true,
        time: 0
      });
      for (const [resolveStart2, resolveEnd2] of resolvers) {
        resolveStart2({
          children: [],
          end: new Promise((resolve) => resolve(0)),
          name: "",
          skip: true,
          time: 0
        });
        resolveEnd2(0);
      }
      resolveEnd(0);
    }
  };
};
var createTraceListener = (getReporter, totalListener, handler) => {
  return async function trace(trace) {
    if (trace.event !== "request" || trace.type !== "begin")
      return;
    const id = trace.id;
    const reporter = getReporter();
    const request = createSignal();
    const parse22 = createSignal();
    const transform4 = createSignal();
    const beforeHandle = createSignal();
    const handle = createSignal();
    const afterHandle = createSignal();
    const error22 = createSignal();
    const response = createSignal();
    request.consume(trace);
    const reducer = (event) => {
      if (event.id === id)
        switch (event.event) {
          case "request":
            request.consume(event);
            break;
          case "request.unit":
            request.consumeChild(event);
            break;
          case "parse":
            parse22.consume(event);
            break;
          case "parse.unit":
            parse22.consumeChild(event);
            break;
          case "transform":
            transform4.consume(event);
            break;
          case "transform.unit":
            transform4.consumeChild(event);
            break;
          case "beforeHandle":
            beforeHandle.consume(event);
            break;
          case "beforeHandle.unit":
            beforeHandle.consumeChild(event);
            break;
          case "handle":
            handle.consume(event);
            break;
          case "afterHandle":
            afterHandle.consume(event);
            break;
          case "afterHandle.unit":
            afterHandle.consumeChild(event);
            break;
          case "error":
            error22.consume(event);
            break;
          case "error.unit":
            error22.consumeChild(event);
            break;
          case "response":
            if (event.type === "begin") {
              request.resolve();
              parse22.resolve();
              transform4.resolve();
              beforeHandle.resolve();
              handle.resolve();
              afterHandle.resolve();
              error22.resolve();
            } else
              reporter.off("event", reducer);
            response.consume(event);
            break;
          case "response.unit":
            response.consumeChild(event);
            break;
          case "exit":
            request.resolve();
            parse22.resolve();
            transform4.resolve();
            beforeHandle.resolve();
            handle.resolve();
            afterHandle.resolve();
            error22.resolve();
            break;
        }
    };
    reporter.on("event", reducer);
    await handler({
      id,
      context: trace.ctx,
      set: trace.ctx?.set,
      store: trace.ctx?.store,
      time: trace.time,
      request: request.signal,
      parse: parse22.signal,
      transform: transform4.signal,
      beforeHandle: beforeHandle.signal,
      handle: handle.signal,
      afterHandle: afterHandle.signal,
      error: error22.signal,
      response: response.signal
    });
    reporter.emit(`res${id}.${totalListener}`, undefined);
  };
};
var Cookie = class {
  constructor(_value, property = {}) {
    this._value = _value;
    this.property = property;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value(value2) {
    if (typeof value2 === "object") {
      if (JSON.stringify(this.value) === JSON.stringify(value2))
        return;
    } else if (this.value === value2)
      return;
    this._value = value2;
    this.sync();
  }
  add(config) {
    const updated = Object.assign(this.property, typeof config === "function" ? config(Object.assign(this.property, this.value)) : config);
    if ("value" in updated) {
      this._value = updated.value;
      delete updated.value;
    }
    this.property = updated;
    return this.sync();
  }
  set(config) {
    const updated = typeof config === "function" ? config(Object.assign(this.property, this.value)) : config;
    if ("value" in updated) {
      this._value = updated.value;
      delete updated.value;
    }
    this.property = updated;
    return this.sync();
  }
  remove(options) {
    if (this.value === undefined)
      return;
    this.set({
      domain: options?.domain,
      expires: /* @__PURE__ */ new Date(0),
      maxAge: 0,
      path: options?.path,
      sameSite: options?.sameSite,
      secure: options?.secure,
      value: ""
    });
  }
  get domain() {
    return this.property.domain;
  }
  set domain(value2) {
    if (this.property.domain === value2)
      return;
    this.property.domain = value2;
    this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires(value2) {
    if (this.property.expires?.getTime() === value2?.getTime())
      return;
    this.property.expires = value2;
    this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly(value2) {
    if (this.property.domain === value2)
      return;
    this.property.httpOnly = value2;
    this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge(value2) {
    if (this.property.maxAge === value2)
      return;
    this.property.maxAge = value2;
    this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path(value2) {
    if (this.property.path === value2)
      return;
    this.property.path = value2;
    this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority(value2) {
    if (this.property.priority === value2)
      return;
    this.property.priority = value2;
    this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite(value2) {
    if (this.property.sameSite === value2)
      return;
    this.property.sameSite = value2;
    this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure(value2) {
    if (this.property.secure === value2)
      return;
    this.property.secure = value2;
    this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = {
        [this.name]: Object.assign(this.property, {
          value: this.toString()
        })
      };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, {
        value: this.toString()
      });
    return this;
  }
};
var createCookieJar = (initial, set2, properties) => new Proxy(initial, {
  get(target, key) {
    if (key in target)
      return target[key];
    const cookie = new Cookie(undefined, properties ? { ...properties } : undefined);
    cookie.setter = set2;
    cookie.name = key;
    return cookie;
  },
  set(target, key, value2) {
    if (!(value2 instanceof Cookie))
      return false;
    if (!set2.cookie)
      set2.cookie = {};
    value2.setter = set2;
    value2.name = key;
    value2.sync();
    target[key] = value2;
    return true;
  }
});
var parseCookie = async (set2, cookieString, {
  secret,
  sign,
  ...properties
} = {}) => {
  if (!cookieString)
    return createCookieJar({}, set2, properties);
  const jar = {};
  const isStringKey = typeof secret === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  const cookieKeys = Object.keys(import_cookie2.parse(cookieString));
  for (let i = 0;i < cookieKeys.length; i++) {
    const key = cookieKeys[i];
    let value2 = import_cookie2.parse(cookieString)[key];
    if (sign === true || sign?.includes(key)) {
      if (!secret)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        value2 = await unsignCookie(value2, secret);
        if (value2 === false)
          throw new InvalidCookieSignature(key);
      } else {
        let fail = true;
        for (let i2 = 0;i2 < secret.length; i2++) {
          const temp = await unsignCookie(value2, secret[i2]);
          if (temp !== false) {
            value2 = temp;
            fail = false;
            break;
          }
        }
        if (fail)
          throw new InvalidCookieSignature(key);
      }
    }
    if (value2 === undefined)
      continue;
    const start = value2.charCodeAt(0);
    if (start === 123 || start === 91)
      try {
        const cookie2 = new Cookie(JSON.parse(value2));
        cookie2.setter = set2;
        cookie2.name = key;
        jar[key] = cookie2;
        continue;
      } catch {}
    if (isNumericString(value2))
      value2 = +value2;
    else if (value2 === "true")
      value2 = true;
    else if (value2 === "false")
      value2 = false;
    const cookie = new Cookie(value2, properties);
    cookie.setter = set2;
    cookie.name = key;
    jar[key] = cookie;
  }
  return createCookieJar(jar, set2);
};
var hasHeaderShorthand = "toJSON" in new Headers;
var isNotEmpty = (obj) => {
  for (const x in obj)
    return true;
  return false;
};
var handleFile = (response, set2) => {
  const size = response.size;
  if (size && set2 && set2.status !== 206 && set2.status !== 304 && set2.status !== 412 && set2.status !== 416 || !set2 && size) {
    if (set2) {
      if (set2.headers instanceof Headers) {
        if (hasHeaderShorthand)
          set2.headers = set2.headers.toJSON();
        else
          for (const [key, value2] of set2.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value2;
      }
      return new Response(response, {
        status: set2.status,
        headers: Object.assign({
          "accept-ranges": "bytes",
          "content-range": `bytes 0-${size - 1}/${size}`
        }, set2.headers)
      });
    }
    return new Response(response, {
      headers: {
        "accept-ranges": "bytes",
        "content-range": `bytes 0-${size - 1}/${size}`
      }
    });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers || !Array.isArray(setCookie))
    return headers;
  headers.delete("Set-Cookie");
  for (let i = 0;i < setCookie.length; i++) {
    const index = setCookie[i].indexOf("=");
    headers.append("Set-Cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1)}`);
  }
  return headers;
};
var cookieToHeader = (cookies) => {
  if (!cookies || typeof cookies !== "object" || !isNotEmpty(cookies))
    return;
  const set2 = [];
  for (const [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    if (Array.isArray(property.value)) {
      for (let i = 0;i < property.value.length; i++) {
        let value2 = property.value[i];
        if (value2 === undefined || value2 === null)
          continue;
        if (typeof value2 === "object")
          value2 = JSON.stringify(value2);
        set2.push(import_cookie.serialize(key, value2, property));
      }
    } else {
      let value2 = property.value;
      if (value2 === undefined || value2 === null)
        continue;
      if (typeof value2 === "object")
        value2 = JSON.stringify(value2);
      set2.push(import_cookie.serialize(key, property.value, property));
    }
  }
  if (set2.length === 0)
    return;
  if (set2.length === 1)
    return set2[0];
  return set2;
};
var mapResponse = (response, set2) => {
  if (response?.[response.$passthrough])
    response = response[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = cookieToHeader(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response(response, set2);
      case undefined:
        if (!response)
          return new Response("", set2);
        return Response.json(response, set2);
      case "Response":
        const inherits = { ...set2.headers };
        if (hasHeaderShorthand)
          set2.headers = response.headers.toJSON();
        else
          for (const [key, value2] of response.headers.entries())
            if (key in set2.headers)
              set2.headers[key] = value2;
        for (const key in inherits)
          response.headers.append(key, inherits[key]);
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => mapResponse(x, set2));
      case "Function":
        return mapResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          const inherits2 = { ...set2.headers };
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value2] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value2;
          for (const key in inherits2)
            response.headers.append(key, inherits2[key]);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123) {
          if (!set2.headers["Content-Type"])
            set2.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify(response), set2);
        }
        return new Response(r, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Error":
        return errorToResponse(response, set2);
      case "Promise":
        return response.then((x) => {
          const r2 = mapCompactResponse(x);
          if (r2 !== undefined)
            return r2;
          return new Response("");
        });
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        return new Response(r);
    }
};
var mapEarlyResponse = (response, set2) => {
  if (response === undefined || response === null)
    return;
  if (response?.$passthrough)
    response = response[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE]) {
    set2.status = response[ELYSIA_RESPONSE];
    response = response.response;
  }
  if (isNotEmpty(set2.headers) || set2.status !== 200 || set2.redirect || set2.cookie) {
    if (typeof set2.status === "string")
      set2.status = StatusMap[set2.status];
    if (set2.redirect) {
      set2.headers.Location = set2.redirect;
      if (!set2.status || set2.status < 300 || set2.status >= 400)
        set2.status = 302;
    }
    if (set2.cookie && isNotEmpty(set2.cookie))
      set2.headers["Set-Cookie"] = cookieToHeader(set2.cookie);
    if (set2.headers["Set-Cookie"] && Array.isArray(set2.headers["Set-Cookie"]))
      set2.headers = parseSetCookies(new Headers(set2.headers), set2.headers["Set-Cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set2);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return Response.json(response, set2);
      case "ReadableStream":
        if (!set2.headers["content-type"]?.startsWith("text/event-stream"))
          set2.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response(response, set2);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set2);
      case "Response":
        const inherits = Object.assign({}, set2.headers);
        if (hasHeaderShorthand)
          set2.headers = response.headers.toJSON();
        else
          for (const [key, value2] of response.headers.entries())
            if (!(key in set2.headers))
              set2.headers[key] = value2;
        for (const key in inherits)
          response.headers.append(key, inherits[key]);
        if (response.status !== set2.status)
          set2.status = response.status;
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
          return;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapEarlyResponse(response(), set2);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set2);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response) {
          const inherits2 = { ...set2.headers };
          if (hasHeaderShorthand)
            set2.headers = response.headers.toJSON();
          else
            for (const [key, value2] of response.headers.entries())
              if (key in set2.headers)
                set2.headers[key] = value2;
          for (const key in inherits2)
            response.headers.append(key, inherits2[key]);
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123) {
          if (!set2.headers["Content-Type"])
            set2.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify(response), set2);
        }
        return new Response(r, set2);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set2);
      case "Object":
      case "Array":
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "ReadableStream":
        return new Response(response, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8"
          }
        });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), {
          headers: {
            "content-type": "application/json"
          }
        });
      case "Response":
        return response;
      case "Promise":
        return response.then((x) => {
          const r2 = mapEarlyResponse(x, set2);
          if (r2 !== undefined)
            return r2;
          return;
        });
      case "Error":
        return errorToResponse(response, set2);
      case "Function":
        return mapCompactResponse(response());
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set2);
        return new Response(response?.toString(), set2);
      default:
        if (response instanceof Response)
          return new Response(response.body, {
            headers: {
              "Content-Type": "application/json"
            }
          });
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set2));
        if (response instanceof Error)
          return errorToResponse(response, set2);
        const r = JSON.stringify(response);
        if (r.charCodeAt(0) === 123)
          return new Response(JSON.stringify(response), {
            headers: {
              "Content-Type": "application/json"
            }
          });
        return new Response(r);
    }
};
var mapCompactResponse = (response) => {
  if (response?.$passthrough)
    response = response[response.$passthrough];
  if (response?.[ELYSIA_RESPONSE])
    return mapResponse(response.response, {
      status: response[ELYSIA_RESPONSE],
      headers: {}
    });
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Blob":
      return handleFile(response);
    case "Object":
    case "Array":
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "ReadableStream":
      return new Response(response, {
        headers: {
          "Content-Type": "text/event-stream; charset=utf-8"
        }
      });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), {
        headers: {
          "content-type": "application/json"
        }
      });
    case "Response":
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then(mapCompactResponse);
    case "Function":
      return mapCompactResponse(response());
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    default:
      if (response instanceof Response)
        return new Response(response.body, {
          headers: {
            "Content-Type": "application/json"
          }
        });
      if (response instanceof Promise)
        return response.then(mapCompactResponse);
      if (response instanceof Error)
        return errorToResponse(response);
      const r = JSON.stringify(response);
      if (r.charCodeAt(0) === 123)
        return new Response(JSON.stringify(response), {
          headers: {
            "Content-Type": "application/json"
          }
        });
      return new Response(r);
  }
};
var errorToResponse = (error22, set2) => new Response(JSON.stringify({
  name: error22?.name,
  message: error22?.message,
  cause: error22?.cause
}), {
  status: set2?.status !== 200 ? set2?.status ?? 500 : 500,
  headers: set2?.headers
});
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var replaceUrlPath = (url, pathname) => {
  const urlObject = new URL(url);
  urlObject.pathname = pathname;
  return urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") || isNotEmpty(Object.getPrototypeOf(v));
var mergeDeep = (target, source, {
  skipKeys
} = {}) => {
  if (isObject(target) && isObject(source))
    for (const [key, value2] of Object.entries(source)) {
      if (skipKeys?.includes(key))
        continue;
      if (!isObject(value2)) {
        target[key] = value2;
        continue;
      }
      if (!(key in target)) {
        target[key] = value2;
        continue;
      }
      if (isClass(value2)) {
        target[key] = value2;
        continue;
      }
      target[key] = mergeDeep(target[key], value2);
    }
  return target;
};
var mergeCookie = (target, source) => mergeDeep(target, source, {
  skipKeys: ["properties"]
});
var mergeObjectArray = (a, b) => {
  if (!a)
    return [];
  const array3 = [...Array.isArray(a) ? a : [a]];
  const checksums = [];
  for (const item of array3) {
    if (item.$elysiaChecksum)
      checksums.push(item.$elysiaChecksum);
  }
  for (const item of Array.isArray(b) ? b : [b]) {
    if (!checksums.includes(item?.$elysiaChecksum)) {
      array3.push(item);
    }
  }
  return array3;
};
var primitiveHooks = [
  "start",
  "request",
  "parse",
  "transform",
  "resolve",
  "beforeHandle",
  "afterHandle",
  "onResponse",
  "mapResponse",
  "trace",
  "error",
  "stop",
  "body",
  "headers",
  "params",
  "query",
  "response",
  "type",
  "detail"
];
var mergeHook = (a, b) => {
  return {
    ...a,
    ...b,
    body: b?.body ?? a?.body,
    headers: b?.headers ?? a?.headers,
    params: b?.params ?? a?.params,
    query: b?.query ?? a?.query,
    response: b?.response ?? a?.response,
    type: a?.type || b?.type,
    detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}),
    parse: mergeObjectArray(a?.parse ?? [], b?.parse ?? []),
    transform: mergeObjectArray(a?.transform ?? [], b?.transform ?? []),
    beforeHandle: mergeObjectArray(a?.beforeHandle ?? [], b?.beforeHandle ?? []),
    afterHandle: mergeObjectArray(a?.afterHandle ?? [], b?.afterHandle ?? []),
    onResponse: mergeObjectArray(a?.onResponse ?? [], b?.onResponse ?? []),
    mapResponse: mergeObjectArray(a?.mapResponse ?? [], b?.mapResponse ?? []),
    trace: mergeObjectArray(a?.trace ?? [], b?.trace ?? []),
    error: mergeObjectArray(a?.error ?? [], b?.error ?? [])
  };
};
var getSchemaValidator = (s, {
  models = {},
  additionalProperties = false,
  dynamic = false
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const schema3 = typeof s === "string" ? models[s] : s;
  if (schema3.type === "object" && "additionalProperties" in schema3 === false)
    schema3.additionalProperties = additionalProperties;
  if (dynamic)
    return {
      schema: schema3,
      references: "",
      checkFunc: () => {},
      code: "",
      Check: (value2) => exports_value2.Check(schema3, value2),
      Errors: (value2) => exports_value2.Errors(schema3, value2),
      Code: () => ""
    };
  return TypeCompiler.Compile(schema3, Object.values(models));
};
var getResponseSchemaValidator = (s, {
  models = {},
  additionalProperties = false,
  dynamic = false
}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  const maybeSchemaOrRecord = typeof s === "string" ? models[s] : s;
  const compile = (schema3, references) => {
    if (dynamic)
      return {
        schema: schema3,
        references: "",
        checkFunc: () => {},
        code: "",
        Check: (value2) => exports_value2.Check(schema3, value2),
        Errors: (value2) => exports_value2.Errors(schema3, value2),
        Code: () => ""
      };
    return TypeCompiler.Compile(schema3, references);
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return {
      200: compile(maybeSchemaOrRecord, Object.values(models))
    };
  }
  const record3 = {};
  Object.keys(maybeSchemaOrRecord).forEach((status) => {
    const maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        const schema3 = models[maybeNameOrSchema];
        schema3.type === "object" && "additionalProperties" in schema3;
        record3[+status] = Kind in schema3 ? compile(schema3, Object.values(models)) : schema3;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record3[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  });
  return record3;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9);
  return h = h ^ h >>> 9;
};
var mergeLifeCycle = (a, b, checksum2) => {
  const injectChecksum = (x) => {
    if (checksum2 && !x.$elysiaChecksum)
      x.$elysiaChecksum = checksum2;
    return x;
  };
  return {
    ...a,
    ...b,
    start: mergeObjectArray(a.start, ("start" in b ? b.start ?? [] : []).map(injectChecksum)),
    request: mergeObjectArray(a.request, ("request" in b ? b.request ?? [] : []).map(injectChecksum)),
    parse: mergeObjectArray(a.parse, "parse" in b ? b?.parse ?? [] : []).map(injectChecksum),
    transform: mergeObjectArray(a.transform, (b?.transform ?? []).map(injectChecksum)),
    beforeHandle: mergeObjectArray(a.beforeHandle, (b?.beforeHandle ?? []).map(injectChecksum)),
    afterHandle: mergeObjectArray(a.afterHandle, (b?.afterHandle ?? []).map(injectChecksum)),
    mapResponse: mergeObjectArray(a.mapResponse, (b?.mapResponse ?? []).map(injectChecksum)),
    onResponse: mergeObjectArray(a.onResponse, (b?.onResponse ?? []).map(injectChecksum)),
    trace: a.trace,
    error: mergeObjectArray(a.error, (b?.error ?? []).map(injectChecksum)),
    stop: mergeObjectArray(a.stop, ("stop" in b ? b.stop ?? [] : []).map(injectChecksum))
  };
};
var asGlobal = (fn, inject = true) => {
  if (!fn)
    return fn;
  if (typeof fn === "function") {
    if (inject)
      fn.$elysiaHookType = "global";
    else
      fn.$elysiaHookType = undefined;
    return fn;
  }
  return fn.map((x) => {
    if (inject)
      x.$elysiaHookType = "global";
    else
      x.$elysiaHookType = undefined;
    return x;
  });
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (typeof fn === "function") {
    return fn.$elysiaHookType === "global" ? fn : undefined;
  }
  return fn.filter((x) => x.$elysiaHookType === "global");
};
var filterGlobalHook = (hook) => {
  return {
    ...hook,
    type: hook?.type,
    detail: hook?.detail,
    parse: filterGlobal(hook?.parse),
    transform: filterGlobal(hook?.transform),
    beforeHandle: filterGlobal(hook?.beforeHandle),
    afterHandle: filterGlobal(hook?.afterHandle),
    onResponse: filterGlobal(hook?.onResponse),
    error: filterGlobal(hook?.error)
  };
};
var StatusMap = {
  Continue: 100,
  "Switching Protocols": 101,
  Processing: 102,
  "Early Hints": 103,
  OK: 200,
  Created: 201,
  Accepted: 202,
  "Non-Authoritative Information": 203,
  "No Content": 204,
  "Reset Content": 205,
  "Partial Content": 206,
  "Multi-Status": 207,
  "Already Reported": 208,
  "Multiple Choices": 300,
  "Moved Permanently": 301,
  Found: 302,
  "See Other": 303,
  "Not Modified": 304,
  "Temporary Redirect": 307,
  "Permanent Redirect": 308,
  "Bad Request": 400,
  Unauthorized: 401,
  "Payment Required": 402,
  Forbidden: 403,
  "Not Found": 404,
  "Method Not Allowed": 405,
  "Not Acceptable": 406,
  "Proxy Authentication Required": 407,
  "Request Timeout": 408,
  Conflict: 409,
  Gone: 410,
  "Length Required": 411,
  "Precondition Failed": 412,
  "Payload Too Large": 413,
  "URI Too Long": 414,
  "Unsupported Media Type": 415,
  "Range Not Satisfiable": 416,
  "Expectation Failed": 417,
  "I'm a teapot": 418,
  "Misdirected Request": 421,
  "Unprocessable Content": 422,
  Locked: 423,
  "Failed Dependency": 424,
  "Too Early": 425,
  "Upgrade Required": 426,
  "Precondition Required": 428,
  "Too Many Requests": 429,
  "Request Header Fields Too Large": 431,
  "Unavailable For Legal Reasons": 451,
  "Internal Server Error": 500,
  "Not Implemented": 501,
  "Bad Gateway": 502,
  "Service Unavailable": 503,
  "Gateway Timeout": 504,
  "HTTP Version Not Supported": 505,
  "Variant Also Negotiates": 506,
  "Insufficient Storage": 507,
  "Loop Detected": 508,
  "Not Extended": 510,
  "Network Authentication Required": 511
};
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const encoder = new TextEncoder;
  const secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  const hmacArray = Array.from(new Uint8Array(hmacBuffer));
  const digest = btoa(String.fromCharCode(...hmacArray));
  return `${val}.${digest.replace(/=+$/, "")}`;
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  const tentativeValue = input.slice(0, input.lastIndexOf("."));
  const expectedInput = await signCookie(tentativeValue, secret);
  return expectedInput === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property, hooks = property) => {
  for (const [key, value2] of Object.entries(property ?? {})) {
    if (primitiveHooks.includes(key) || !(key in extension))
      continue;
    if (typeof extension[key] === "function") {
      extension[key](value2);
    } else if (typeof extension[key] === "object")
      traceBackMacro(extension[key], value2, hooks);
  }
};
var isNumericString = (message) => {
  if (message.length < 16)
    return message.trim().length !== 0 && !Number.isNaN(Number(message));
  if (message.length === 16) {
    const numVal = Number(message);
    if (numVal.toString() === message)
      return message.trim().length !== 0 && !Number.isNaN(numVal);
  }
  return false;
};
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var ELYSIA_RESPONSE = Symbol("ElysiaResponse");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";
var InternalServerError = class extends Error {
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
    this.code = "INTERNAL_SERVER_ERROR";
    this.status = 500;
  }
};
var NotFoundError = class extends Error {
  constructor(message) {
    super(message ?? "NOT_FOUND");
    this.code = "NOT_FOUND";
    this.status = 404;
  }
};
var InvalidCookieSignature = class extends Error {
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
    this.code = "INVALID_COOKIE_SIGNATURE";
    this.status = 400;
  }
};
var ValidationError = class _ValidationError extends Error {
  constructor(type3, validator, value2) {
    const error22 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value2).First() : exports_value2.Errors(validator, value2).First();
    const customError = error22?.schema.error ? typeof error22.schema.error === "function" ? error22.schema.error(type3, validator, value2) : error22.schema.error : undefined;
    const accessor = error22?.path?.slice(1) || "root";
    let message = "";
    if (customError) {
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    } else if (isProduction) {
      message = JSON.stringify({
        type: type3,
        message: error22?.message
      });
    } else {
      message = JSON.stringify({
        type: type3,
        at: accessor,
        message: error22?.message,
        expected: exports_value2.Create(validator.schema),
        found: value2,
        errors: [...validator.Errors(value2)]
      }, null, 2);
    }
    super(message);
    this.type = type3;
    this.validator = validator;
    this.value = value2;
    this.code = "VALIDATION";
    this.status = 400;
    Object.setPrototypeOf(this, _ValidationError.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel(validator) {
    const model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return _ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, {
      status: 400,
      headers
    });
  }
};
var websocket = {
  open(ws) {
    ws.data.open?.(ws);
  },
  message(ws, message) {
    ws.data.message?.(ws, message);
  },
  drain(ws) {
    ws.data.drain?.(ws);
  },
  close(ws, code, reason) {
    ws.data.close?.(ws, code, reason);
  }
};
var ElysiaWS = class {
  constructor(raw, data) {
    this.raw = raw;
    this.data = data;
    this.validator = raw.data.validator;
    if (raw.data.id) {
      this.id = raw.data.id;
    } else {
      const array3 = new Uint32Array(1);
      crypto.getRandomValues(array3);
      this.id = array3[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id(newID) {
    this.raw.data.id = newID;
  }
  get publish() {
    return (topic, data = undefined, compress) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.publish(topic, data, compress);
      return this;
    };
  }
  get send() {
    return (data) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (Buffer.isBuffer(data)) {
        this.raw.send(data);
        return this;
      }
      if (typeof data === "object")
        data = JSON.stringify(data);
      this.raw.send(data);
      return this;
    };
  }
  get subscribe() {
    return (room) => {
      this.raw.subscribe(room);
      return this;
    };
  }
  get unsubscribe() {
    return (room) => {
      this.raw.unsubscribe(room);
      return this;
    };
  }
  get cork() {
    return (callback) => {
      this.raw.cork(callback);
      return this;
    };
  }
  get close() {
    return () => {
      this.raw.close();
      return this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
};
var headersHasToJSON = new Headers().toJSON;
var findAliases = new RegExp(` (\\w+) = context`, "g");
var requestId = { value: 0 };
var createReport = ({
  hasTrace,
  hasTraceSet = false,
  addFn,
  condition = {}
}) => {
  if (hasTrace) {
    addFn(`
const reporter = getReporter()
`);
    return (event, {
      name,
      attribute = "",
      unit = 0
    } = {}) => {
      const dotIndex = event.indexOf(".");
      const isGroup = dotIndex === -1;
      if (event !== "request" && event !== "response" && !condition[isGroup ? event : event.slice(0, dotIndex)])
        return () => {
          if (hasTraceSet && event === "afterHandle")
            addFn(`
await traceDone
`);
        };
      if (isGroup)
        name ||= event;
      else
        name ||= "anonymous";
      addFn(`
` + `reporter.emit('event', {
					id,
					event: '${event}',
					type: 'begin',
					name: '${name}',
					time: performance.now(),
					${isGroup ? `unit: ${unit},` : ""}
					${attribute}
				})`.replace(/(\t| |\n)/g, "") + `
`);
      let handled = false;
      return () => {
        if (handled)
          return;
        handled = true;
        addFn(`
` + `reporter.emit('event', {
							id,
							event: '${event}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + `
`);
        if (hasTraceSet && event === "afterHandle")
          addFn(`
await traceDone
`);
      };
    };
  } else {
    return () => () => {};
  }
};
var hasReturn = (fnLiteral) => {
  const parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123) {
    return true;
  }
  return fnLiteral.includes("return");
};
var composeValidationFactory = (hasErrorHandler, {
  injectResponse = ""
} = {}) => ({
  composeValidation: (type3, value2 = `c.${type3}`) => hasErrorHandler ? `c.set.status = 400; throw new ValidationError(
'${type3}',
${type3},
${value2}
)` : `c.set.status = 400; return new ValidationError(
	'${type3}',
	${type3},
	${value2}
).toResponse(c.set.headers)`,
  composeResponseValidation: (name = "r") => {
    const returnError = hasErrorHandler ? `throw new ValidationError(
'response',
response[c.set.status],
${name}
)` : `return new ValidationError(
'response',
response[c.set.status],
${name}
).toResponse(c.set.headers)`;
    return `
${injectResponse}
		if(!(${name} instanceof Response) && response[c.set.status]?.Check(${name}) === false) {
	if(!(response instanceof Error))
		${returnError}
}
`;
  }
});
var isFnUse = (keyword, fnLiteral) => {
  if (fnLiteral.startsWith("[object "))
    return false;
  fnLiteral = fnLiteral.trimStart();
  fnLiteral = fnLiteral.replaceAll(/^async /g, "");
  if (/^(\w+)\(/g.test(fnLiteral))
    fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
  const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
  if (argument === "")
    return false;
  const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
  if (argument.charCodeAt(0) === 123) {
    if (argument.includes(keyword))
      return true;
    if (restIndex === -1)
      return false;
  }
  if (fnLiteral.match(new RegExp(`${argument}(.${keyword}|\\["${keyword}"\\])`))) {
    return true;
  }
  const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
  if (fnLiteral.match(new RegExp(`${restAlias}(.${keyword}|\\["${keyword}"\\])`)))
    return true;
  const aliases = [argument];
  if (restAlias)
    aliases.push(restAlias);
  for (const found of fnLiteral.matchAll(findAliases))
    aliases.push(found[1]);
  const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
  for (const [params] of fnLiteral.matchAll(destructuringRegex))
    if (params.includes(`{ ${keyword}`) || params.includes(`, ${keyword}`))
      return true;
  return false;
};
var isContextPassToFunction = (fnLiteral) => {
  fnLiteral = fnLiteral.trimStart();
  if (fnLiteral.startsWith("[object"))
    return false;
  fnLiteral = fnLiteral.replaceAll(/^async /g, "");
  if (/^(\w+)\(/g.test(fnLiteral))
    fnLiteral = fnLiteral.slice(fnLiteral.indexOf("("));
  const argument = fnLiteral.charCodeAt(0) === 40 || fnLiteral.startsWith("function") ? fnLiteral.slice(fnLiteral.indexOf("(") + 1, fnLiteral.indexOf(")")) : fnLiteral.slice(0, fnLiteral.indexOf("=") - 1);
  if (argument === "")
    return false;
  const restIndex = argument.charCodeAt(0) === 123 ? argument.indexOf("...") : -1;
  const restAlias = restIndex !== -1 ? argument.slice(restIndex + 3, argument.indexOf(" ", restIndex + 3)) : undefined;
  const aliases = [argument];
  if (restAlias)
    aliases.push(restAlias);
  for (const found of fnLiteral.matchAll(findAliases))
    aliases.push(found[1]);
  for (const alias of aliases)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${alias}\\b[^)]*\\)`).test(fnLiteral))
      return true;
  const destructuringRegex = new RegExp(`{.*?} = (${aliases.join("|")})`, "g");
  for (const [renamed] of fnLiteral.matchAll(destructuringRegex))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${renamed}\\b[^)]*\\)`).test(fnLiteral))
      return true;
  return false;
};
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasType = (type3, schema3) => {
  if (!schema3)
    return;
  if (KindSymbol in schema3 && schema3[KindSymbol] === type3)
    return true;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasType(type3, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasType(type3, property.anyOf[i]))
            return true;
      }
      if (KindSymbol in property && property[KindSymbol] === type3)
        return true;
    }
    return false;
  }
  return schema3.properties && KindSymbol in schema3.properties && schema3.properties[KindSymbol] === type3;
};
var hasProperty = (expectedProperty, schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object") {
    const properties = schema3.properties;
    if (!properties)
      return false;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++) {
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
        }
      }
    }
    return false;
  }
  return expectedProperty in schema3;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object" && schema3.properties) {
    const properties = schema3.properties;
    for (const key of Object.keys(properties)) {
      const property = properties[key];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform(property.anyOf[i]))
            return true;
      }
      const hasTransformSymbol = TransformSymbol in property;
      if (hasTransformSymbol)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema3 || schema3.properties && TransformSymbol in schema3.properties;
};
var getUnionedType = (validator) => {
  if (!validator)
    return;
  const schema3 = validator?.schema;
  if (schema3 && "anyOf" in schema3) {
    let foundDifference = false;
    const type3 = schema3.anyOf[0].type;
    for (const validator2 of schema3.anyOf) {
      if (validator2.type !== type3) {
        foundDifference = true;
        break;
      }
    }
    if (!foundDifference)
      return type3;
  }
  return validator.schema?.type;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsync = (fn) => {
  if (fn.constructor.name === "AsyncFunction")
    return true;
  const literal3 = fn.toString();
  if (literal3.includes("=> response.clone("))
    return false;
  return !!literal3.match(matchFnReturn);
};
var getDestructureQuery = (fn) => {
  if (!fn.includes("query: {") || fn.includes("query,") || fn.includes("query }"))
    return false;
  const start = fn.indexOf("query: {");
  fn = fn.slice(start + 9);
  fn = fn.slice(0, fn.indexOf("}"));
  return fn.split(",").map((x) => {
    const indexOf = x.indexOf(":");
    if (indexOf === -1)
      return x.trim();
    return x.slice(0, indexOf).trim();
  });
};
var composeHandler = ({
  path,
  method,
  hooks,
  validator,
  handler,
  handleError,
  definitions,
  schema: schema3,
  onRequest,
  config,
  getReporter,
  setHeader
}) => {
  const hasErrorHandler = config.forceErrorEncapsulation || hooks.error.length > 0 || typeof Bun === "undefined" || hooks.onResponse.length > 0 || !!hooks.trace.length;
  const isHandleFn = typeof handler === "function";
  const handle = isHandleFn ? `handler(c)` : `handler`;
  const handleResponse = hooks.onResponse.length ? `
;(async () => {${hooks.onResponse.map((_, i) => `await res${i}(c)`).join(";")}})();
` : "";
  const traceLiteral = hooks.trace.map((x) => x.toString());
  let hasUnknownContext = false;
  if (isHandleFn && isContextPassToFunction(handler.toString()))
    hasUnknownContext = true;
  if (!hasUnknownContext)
    for (const [key, value2] of Object.entries(hooks)) {
      if (!Array.isArray(value2) || !value2.length || ![
        "parse",
        "transform",
        "beforeHandle",
        "afterHandle",
        "onResponse"
      ].includes(key))
        continue;
      for (const handle2 of value2) {
        if (typeof handle2 !== "function")
          continue;
        if (isContextPassToFunction(handle2.toString())) {
          hasUnknownContext = true;
          break;
        }
      }
      if (hasUnknownContext)
        break;
    }
  const traceConditions = {
    parse: traceLiteral.some((x) => isFnUse("parse", x)),
    transform: traceLiteral.some((x) => isFnUse("transform", x)),
    handle: traceLiteral.some((x) => isFnUse("handle", x)),
    beforeHandle: traceLiteral.some((x) => isFnUse("beforeHandle", x)),
    afterHandle: traceLiteral.some((x) => isFnUse("afterHandle", x)),
    error: hasErrorHandler || traceLiteral.some((x) => isFnUse("error", x))
  };
  const hasTrace = hooks.trace.length > 0;
  let fnLiteral = "";
  const lifeCycleLiteral = validator || method !== "GET" && method !== "HEAD" ? [
    handler,
    ...hooks.transform,
    ...hooks.beforeHandle,
    ...hooks.afterHandle,
    ...hooks.mapResponse
  ].map((x) => typeof x === "function" ? x.toString() : `${x}`) : [];
  const hasBody = method !== "GET" && method !== "HEAD" && (hasUnknownContext || hooks.type !== "none" && (!!validator.body || !!hooks.type || lifeCycleLiteral.some((fn) => isFnUse("body", fn))));
  const hasHeaders = hasUnknownContext || validator.headers || lifeCycleLiteral.some((fn) => isFnUse("headers", fn)) || setHeader && Object.keys(setHeader).length;
  const hasCookie = hasUnknownContext || !!validator.cookie || lifeCycleLiteral.some((fn) => isFnUse("cookie", fn));
  const cookieMeta = validator?.cookie?.schema;
  let encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    encodeCookie += `const _setCookie = c.set.cookie
		if(_setCookie) {`;
    if (cookieMeta.sign === true) {
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
			}`;
    } else
      for (const name of cookieMeta.sign) {
        encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
      }
    encodeCookie += `}
`;
  }
  const { composeValidation, composeResponseValidation } = composeValidationFactory(hasErrorHandler);
  if (hasHeaders) {
    fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  }
  if (hasCookie) {
    const get = (name, defaultValue) => {
      const value2 = cookieMeta?.[name] ?? defaultValue;
      if (!value2)
        return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
      if (typeof value2 === "string")
        return `${name}: '${value2}',`;
      if (value2 instanceof Date)
        return `${name}: new Date(${value2.getTime()}),`;
      return `${name}: ${value2},`;
    };
    const options = cookieMeta ? `{
			secret: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			sign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
			${get("domain")}
			${get("expires")}
			${get("httpOnly")}
			${get("maxAge")}
			${get("path", "/")}
			${get("priority")}
			${get("sameSite")}
			${get("secure")}
		}` : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
    else
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
  }
  const hasQuery = hasUnknownContext || validator.query || lifeCycleLiteral.some((fn) => isFnUse("query", fn));
  if (hasQuery) {
    let destructured = [];
    let referenceFullQuery = false;
    if (validator.query && validator.query.schema.type === "object") {
      destructured = Object.keys(validator.query.schema.properties);
    } else
      for (const event of lifeCycleLiteral) {
        const queries = getDestructureQuery(event);
        if (!queries) {
          referenceFullQuery = true;
          continue;
        }
        for (const query of queries)
          if (destructured.indexOf(query) === -1)
            destructured.push(query);
      }
    if (!referenceFullQuery && destructured.length) {
      fnLiteral += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${destructured.map((name, index) => `
						memory = url.indexOf('${name}=')

						const a${index} = memory === -1 ? undefined : url.slice(memory = memory + ${name.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join(`
`)}

				c.query = {
					${destructured.map((name, index) => `'${name}': a${index}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    } else {
      fnLiteral += `c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}`;
    }
  }
  const traceLiterals = hooks.trace.map((x) => x.toString());
  const hasTraceSet = traceLiterals.some((fn) => isFnUse("set", fn) || isContextPassToFunction(fn));
  hasUnknownContext || hooks.trace.some((fn) => isFnUse("set", fn.toString()));
  const hasSet = setHeader && Object.keys(setHeader).length || hasTraceSet || hasCookie || lifeCycleLiteral.some((fn) => isFnUse("set", fn)) || onRequest.some((fn) => isFnUse("set", fn.toString()));
  if (hasTrace)
    fnLiteral += `
const id = c.$$requestId
`;
  const report = createReport({
    hasTrace,
    hasTraceSet,
    condition: traceConditions,
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  fnLiteral += hasErrorHandler ? `
 try {
` : "";
  if (hasTraceSet) {
    fnLiteral += `
const traceDone = Promise.all([`;
    for (let i = 0;i < hooks.trace.length; i++) {
      fnLiteral += `new Promise(r => { reporter.once(\`res\${id}.${i}\`, r) }),`;
    }
    fnLiteral += `])
`;
  }
  const isAsyncHandler = typeof handler === "function" && isAsync(handler);
  const maybeAsync = hasCookie || hasBody || hasTraceSet || isAsyncHandler || !!hooks.mapResponse.length || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync);
  const endParse = report("parse", {
    unit: hooks.parse.length
  });
  if (hasBody) {
    const type3 = getUnionedType(validator?.body);
    if (hooks.type && !Array.isArray(hooks.type)) {
      if (hooks.type) {
        switch (hooks.type) {
          case "json":
          case "application/json":
            fnLiteral += `c.body = await c.request.json()
`;
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}
`;
            break;
        }
      }
      if (hooks.parse.length)
        fnLiteral += "}}";
    } else {
      const getAotParser = () => {
        if (hooks.parse.length && type3 && !Array.isArray(hooks.type)) {
          const schema22 = validator?.body?.schema;
          switch (type3) {
            case "object":
              if (hasType("File", schema22) || hasType("Files", schema22))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      };
      const aotParse = getAotParser();
      if (aotParse)
        fnLiteral += aotParse;
      else {
        fnLiteral += `
`;
        fnLiteral += hasHeaders ? `let contentType = c.headers['content-type']` : `let contentType = c.request.headers.get('content-type')`;
        fnLiteral += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)
`;
        if (hooks.parse.length) {
          fnLiteral += `let used = false
`;
          const endReport = report("parse", {
            unit: hooks.parse.length
          });
          for (let i = 0;i < hooks.parse.length; i++) {
            const endUnit = report("parse.unit", {
              name: hooks.parse[i].name
            });
            const name = `bo${i}`;
            if (i !== 0)
              fnLiteral += `if(!used) {
`;
            fnLiteral += `let ${name} = parse[${i}](c, contentType)
`;
            fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`;
            fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`;
            endUnit();
            if (i !== 0)
              fnLiteral += `}`;
          }
          endReport();
        }
        if (hooks.parse.length)
          fnLiteral += `if (!used)`;
        fnLiteral += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}
`;
        fnLiteral += `}
`;
      }
    }
    fnLiteral += `
`;
  }
  endParse();
  if (hooks?.transform) {
    const endTransform = report("transform", {
      unit: hooks.transform.length
    });
    for (let i = 0;i < hooks.transform.length; i++) {
      const transform4 = hooks.transform[i];
      const endUnit = report("transform.unit", {
        name: transform4.name
      });
      if (transform4.$elysia === "derive")
        fnLiteral += isAsync(transform4) ? `Object.assign(c, await transform[${i}](c));` : `Object.assign(c, transform[${i}](c));`;
      else
        fnLiteral += isAsync(transform4) ? `await transform[${i}](c);` : `transform[${i}](c);`;
      endUnit();
    }
    endTransform();
  }
  if (validator) {
    fnLiteral += `
`;
    if (validator.headers) {
      if (hasProperty("default", validator.headers.params))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          const parsed = typeof value2 === "object" ? JSON.stringify(value2) : `'${value2}'`;
          if (parsed)
            fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(headers.Check(c.headers) === false) {
				${composeValidation("headers")}
			}`;
      if (hasTransform(validator.headers.schema))
        fnLiteral += `
c.headers = headers.Decode(c.headers)
`;
    }
    if (validator.params) {
      if (hasProperty("default", validator.params.schema))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          const parsed = typeof value2 === "object" ? JSON.stringify(value2) : `'${value2}'`;
          if (parsed)
            fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(params.Check(c.params) === false) {
				${composeValidation("params")}
			}`;
      if (hasTransform(validator.params.schema))
        fnLiteral += `
c.params = params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (hasProperty("default", validator.query.schema))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          const parsed = typeof value2 === "object" ? JSON.stringify(value2) : `'${value2}'`;
          if (parsed)
            fnLiteral += `c.query['${key}'] ??= ${parsed}
`;
        }
      fnLiteral += `if(query.Check(c.query) === false) {
				${composeValidation("query")}
			}`;
      if (hasTransform(validator.query.schema))
        fnLiteral += `
c.query = query.Decode(Object.assign({}, c.query))
`;
    }
    if (validator.body) {
      if (hasProperty("default", validator.body.schema))
        fnLiteral += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(validator.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${composeValidation("body")}
     			}
            }`;
      else
        fnLiteral += `if(body.Check(c.body) === false) {
			${composeValidation("body")}
		}`;
      if (hasTransform(validator.body.schema))
        fnLiteral += `
c.body = body.Decode(c.body)
`;
    }
    if (isNotEmpty(validator.cookie?.schema.properties ?? {})) {
      fnLiteral += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value
`;
      if (hasProperty("default", validator.cookie.schema))
        for (const [key, value2] of Object.entries(exports_value2.Default(validator.cookie.schema, {}))) {
          fnLiteral += `cookieValue['${key}'] = ${typeof value2 === "object" ? JSON.stringify(value2) : value2}
`;
        }
      fnLiteral += `if(cookie.Check(cookieValue) === false) {
				${composeValidation("cookie", "cookieValue")}
			}`;
      if (hasTransform(validator.cookie.schema))
        fnLiteral += `
c.cookie = params.Decode(c.cookie)
`;
    }
  }
  if (hooks?.beforeHandle) {
    const endBeforeHandle = report("beforeHandle", {
      unit: hooks.beforeHandle.length
    });
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      const beforeHandle = hooks.beforeHandle[i];
      const endUnit = report("beforeHandle.unit", {
        name: beforeHandle.name
      });
      const returning = hasReturn(beforeHandle.toString());
      if (beforeHandle.$elysia === "resolve") {
        fnLiteral += isAsync(beforeHandle) ? `Object.assign(c, await beforeHandle[${i}](c));` : `Object.assign(c, beforeHandle[${i}](c));`;
      } else if (!returning) {
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`;
        endUnit();
      } else {
        fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`;
        endUnit();
        fnLiteral += `if(be !== undefined) {
`;
        const endAfterHandle = report("afterHandle", {
          unit: hooks.transform.length
        });
        if (hooks.afterHandle) {
          report("handle", {
            name: isHandleFn ? handler.name : undefined
          })();
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            const returning2 = hasReturn(hooks.afterHandle[i2].toString());
            const endUnit2 = report("afterHandle.unit", {
              name: hooks.afterHandle[i2].name
            });
            fnLiteral += `c.response = be
`;
            if (!returning2) {
              fnLiteral += isAsync(hooks.afterHandle[i2]) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            } else {
              fnLiteral += isAsync(hooks.afterHandle[i2]) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`;
              fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
            }
            endUnit2();
          }
        }
        endAfterHandle();
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        if (hooks.mapResponse.length) {
          fnLiteral += `c.response = be`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i2}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        fnLiteral += `return mapEarlyResponse(be, c.set)}
`;
      }
    }
    endBeforeHandle();
  }
  if (hooks?.afterHandle.length) {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
    else
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
    endHandle();
    const endAfterHandle = report("afterHandle", {
      unit: hooks.afterHandle.length
    });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      const returning = hasReturn(hooks.afterHandle[i].toString());
      const endUnit = report("afterHandle.unit", {
        name: hooks.afterHandle[i].name
      });
      if (!returning) {
        fnLiteral += isAsync(hooks.afterHandle[i]) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`;
        endUnit();
      } else {
        fnLiteral += isAsync(hooks.afterHandle[i]) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`;
        endUnit();
        if (validator.response) {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += composeResponseValidation("af");
          fnLiteral += `c.response = af }`;
        } else {
          fnLiteral += `if(af !== undefined) {`;
          endAfterHandle();
          fnLiteral += `c.response = af}
`;
        }
      }
    }
    endAfterHandle();
    fnLiteral += `r = c.response
`;
    if (validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    if (hooks.mapResponse.length) {
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        fnLiteral += `
mr = onMapResponse[${i}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr
`;
      }
    }
    if (hasSet)
      fnLiteral += `return mapResponse(r, c.set)
`;
    else
      fnLiteral += `return mapCompactResponse(r)
`;
  } else {
    const endHandle = report("handle", {
      name: isHandleFn ? handler.name : undefined
    });
    if (validator.response || hooks.mapResponse.length) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
      endHandle();
      if (validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle")();
      if (hooks.mapResponse.length) {
        fnLiteral += "c.response = r";
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          fnLiteral += `
if(mr === undefined) { 
						mr = onMapResponse[${i}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}
`;
        }
      }
      fnLiteral += encodeCookie;
      if (handler instanceof Response)
        fnLiteral += `return ${handle}.clone()
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(r, c.set)
`;
      else
        fnLiteral += `return mapCompactResponse(r)
`;
    } else {
      if (traceConditions.handle || hasCookie) {
        fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
        endHandle();
        report("afterHandle")();
        if (hooks.mapResponse.length) {
          fnLiteral += "c.response = r";
          for (let i = 0;i < hooks.mapResponse.length; i++) {
            fnLiteral += `
if(mr === undefined) {
							mr = onMapResponse[${i}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}
`;
          }
        }
        fnLiteral += encodeCookie;
        if (hasSet)
          fnLiteral += `return mapResponse(r, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(r)
`;
      } else {
        endHandle();
        const handled = isAsyncHandler ? `await ${handle}` : handle;
        report("afterHandle")();
        if (handler instanceof Response)
          fnLiteral += `return ${handle}.clone()
`;
        else if (hasSet)
          fnLiteral += `return mapResponse(${handled}, c.set)
`;
        else
          fnLiteral += `return mapCompactResponse(${handled})
`;
      }
    }
  }
  if (hasErrorHandler || handleResponse) {
    fnLiteral += `
} catch(error) {`;
    if (!maybeAsync)
      fnLiteral += `return (async () => {`;
    fnLiteral += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const endError = report("error", {
      unit: hooks.error.length
    });
    if (hooks.error.length) {
      fnLiteral += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let i = 0;i < hooks.error.length; i++) {
        const name = `er${i}`;
        const endUnit = report("error.unit", {
          name: hooks.error[i].name
        });
        fnLiteral += `
let ${name} = handleErrors[${i}](c)
`;
        if (isAsync(hooks.error[i]))
          fnLiteral += `if (${name} instanceof Promise) ${name} = await ${name}
`;
        endUnit();
        fnLiteral += `${name} = mapEarlyResponse(${name}, set)
`;
        fnLiteral += `if (${name}) {`;
        fnLiteral += `return ${name} }
`;
      }
    }
    endError();
    fnLiteral += `return handleError(c, error)

`;
    if (!maybeAsync)
      fnLiteral += "})()";
    fnLiteral += "}";
    if (handleResponse || hasTrace) {
      fnLiteral += ` finally { `;
      const endResponse = report("response", {
        unit: hooks.onResponse.length
      });
      fnLiteral += handleResponse;
      endResponse();
      fnLiteral += `}`;
    }
  }
  fnLiteral = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${hooks.onResponse.length ? `const ${hooks.onResponse.map((x, i) => `res${i} = onResponse[${i}]`).join(",")}` : ""}

	return ${maybeAsync ? "async" : ""} function handle(c) {
		${hooks.beforeHandle.length ? "let be" : ""}
		${hooks.afterHandle.length ? "let af" : ""}
		${hooks.mapResponse.length ? "let mr" : ""}

		${schema3 && definitions ? "c.schema = schema; c.defs = definitions;" : ""}
		${fnLiteral}
	}`;
  const createHandler = Function("hooks", fnLiteral);
  return createHandler({
    handler,
    hooks,
    validator,
    handleError,
    utils: {
      mapResponse,
      mapCompactResponse,
      mapEarlyResponse,
      parseQuery: import_fast_querystring.parse
    },
    error: {
      NotFoundError,
      ValidationError,
      InternalServerError
    },
    schema: schema3,
    definitions,
    ERROR_CODE,
    getReporter,
    requestId,
    parseCookie,
    signCookie,
    decodeURIComponent: import_fast_decode_uri_component.default
  });
};
var composeGeneralHandler = (app) => {
  let decoratorsLiteral = "";
  let fnLiteral = "";
  for (const key of Object.keys(app.decorators))
    decoratorsLiteral += `,${key}: app.decorators.${key}`;
  const { router, staticRouter } = app;
  const hasTrace = app.event.trace.length > 0;
  const findDynamicRoute = `
	const route = router.find(request.method, path) ${router.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${app.event.error.length ? `app.handleError(ctx, notFound)` : app.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : `error404.clone()`}

	ctx.params = route.params

	return route.store(ctx)`;
  let switchMap = ``;
  for (const [path, { code, all }] of Object.entries(staticRouter.map))
    switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? `default: break map`}}

`;
  const maybeAsync = app.event.request.some(isAsync);
  fnLiteral += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${app.event.request.length ? `const onRequest = app.event.request` : ""}
	${staticRouter.variables}
	${app.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${maybeAsync ? "async" : ""} function map(request) {
`;
  if (app.event.request.length)
    fnLiteral += `let re`;
  const traceLiteral = app.event.trace.map((x) => x.toString());
  const report = createReport({
    hasTrace,
    hasTraceSet: app.event.trace.some((fn) => {
      const literal3 = fn.toString();
      return isFnUse("set", literal3) || isContextPassToFunction(literal3);
    }),
    condition: {
      request: traceLiteral.some((x) => isFnUse("request", x) || isContextPassToFunction(x))
    },
    addFn: (word) => {
      fnLiteral += word;
    }
  });
  if (app.event.request.length) {
    fnLiteral += `
			${hasTrace ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys(app.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${hasTrace ? ",$$requestId: +id" : ""}
				${decoratorsLiteral}
			}
		`;
    const endReport = report("request", {
      attribute: "ctx",
      unit: app.event.request.length
    });
    fnLiteral += `
 try {
`;
    for (let i = 0;i < app.event.request.length; i++) {
      const fn = app.event.request[i];
      const withReturn = hasReturn(fn.toString());
      const maybeAsync2 = isAsync(fn);
      const endUnit = report("request.unit", {
        name: app.event.request[i].name
      });
      if (withReturn) {
        fnLiteral += `re = mapEarlyResponse(
					${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
					ctx.set
				)
`;
        endUnit();
        if (withReturn)
          fnLiteral += `if(re !== undefined) return re
`;
      } else {
        fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`;
        endUnit();
      }
    }
    fnLiteral += `} catch (error) {
			return app.handleError(ctx, error)
		}`;
    endReport();
    fnLiteral += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else {
    fnLiteral += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${hasTrace ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys(app.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${hasTrace ? ",$$requestId: id" : ""}
			${decoratorsLiteral}
		}`;
    report("request", {
      unit: app.event.request.length,
      attribute: traceLiteral.some((x) => isFnUse("context", x)) || traceLiteral.some((x) => isFnUse("store", x)) || traceLiteral.some((x) => isFnUse("set", x)) ? "ctx" : ""
    })();
  }
  const wsPaths = app.wsPaths;
  const wsRouter = app.wsRouter;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (const [path, index] of Object.entries(wsPaths)) {
      fnLiteral += `
					case '${path}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${index}(ctx)

						break`;
    }
    fnLiteral += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}
`;
  }
  fnLiteral += `
		map: switch(path) {
			${switchMap}

			default:
				break
		}

		${findDynamicRoute}
	}`;
  const handleError = composeErrorHandler(app);
  app.handleError = handleError;
  return Function("data", fnLiteral)({
    app,
    mapEarlyResponse,
    NotFoundError,
    getReporter: () => app.reporter,
    requestId,
    handleError
  });
};
var composeErrorHandler = (app) => {
  let fnLiteral = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${app.event.error.find(isAsync) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let i = 0;i < app.event.error.length; i++) {
    const handler = app.event.error[i];
    const response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)`;
    if (hasReturn(handler.toString()))
      fnLiteral += `r = ${response}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}
`;
    else
      fnLiteral += response + `
`;
  }
  fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`;
  return Function("inject", fnLiteral)({
    app,
    mapResponse,
    ERROR_CODE,
    ELYSIA_RESPONSE
  });
};
var createDynamicHandler = (app) => async (request) => {
  const set2 = {
    cookie: {},
    status: 200,
    headers: {}
  };
  let context;
  if (app.decorators) {
    context = app.decorators;
    context.request = request;
    context.set = set2;
    context.store = app.store;
  } else {
    context = {
      set: set2,
      store: app.store,
      request
    };
  }
  const url = request.url, s = url.indexOf("/", 11), q = url.indexOf("?", s + 1), path = q === -1 ? url.substring(s) : url.substring(s, q);
  try {
    for (let i = 0;i < app.event.request.length; i++) {
      const onRequest = app.event.request[i];
      let response2 = onRequest(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      response2 = mapEarlyResponse(response2, set2);
      if (response2)
        return response2;
    }
    const handler = app.dynamicRouter.find(request.method, path) ?? app.dynamicRouter.find("ALL", path);
    if (!handler)
      throw new NotFoundError;
    const { handle, hooks, validator, content } = handler.store;
    let body;
    if (request.method !== "GET" && request.method !== "HEAD") {
      if (content) {
        switch (content) {
          case "application/json":
            body = await request.json();
            break;
          case "text/plain":
            body = await request.text();
            break;
          case "application/x-www-form-urlencoded":
            body = import_fast_querystring2.parse(await request.text());
            break;
          case "application/octet-stream":
            body = await request.arrayBuffer();
            break;
          case "multipart/form-data":
            body = {};
            const form = await request.formData();
            for (const key of form.keys()) {
              if (body[key])
                continue;
              const value2 = form.getAll(key);
              if (value2.length === 1)
                body[key] = value2[0];
              else
                body[key] = value2;
            }
            break;
        }
      } else {
        let contentType = request.headers.get("content-type");
        if (contentType) {
          const index = contentType.indexOf(";");
          if (index !== -1)
            contentType = contentType.slice(0, index);
          for (let i = 0;i < hooks.parse.length; i++) {
            let temp = hooks.parse[i](context, contentType);
            if (temp instanceof Promise)
              temp = await temp;
            if (temp) {
              body = temp;
              break;
            }
          }
          if (body === undefined) {
            switch (contentType) {
              case "application/json":
                body = await request.json();
                break;
              case "text/plain":
                body = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body = import_fast_querystring2.parse(await request.text());
                break;
              case "application/octet-stream":
                body = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body = {};
                const form = await request.formData();
                for (const key of form.keys()) {
                  if (body[key])
                    continue;
                  const value2 = form.getAll(key);
                  if (value2.length === 1)
                    body[key] = value2[0];
                  else
                    body[key] = value2;
                }
                break;
            }
          }
        }
      }
    }
    context.body = body;
    context.params = handler?.params || undefined;
    context.query = q === -1 ? {} : import_fast_querystring2.parse(url.substring(q + 1));
    context.headers = {};
    for (const [key, value2] of request.headers.entries())
      context.headers[key] = value2;
    const cookieMeta = validator?.cookie?.schema;
    context.cookie = await parseCookie(context.set, context.headers.cookie, cookieMeta ? {
      secret: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined,
      sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined
    } : undefined);
    for (let i = 0;i < hooks.transform.length; i++) {
      const operation = hooks.transform[i](context);
      if (hooks.transform[i].$elysia === "derive") {
        if (operation instanceof Promise)
          Object.assign(context, await operation);
        else
          Object.assign(context, operation);
      } else if (operation instanceof Promise)
        await operation;
    }
    if (validator) {
      if (validator.headers) {
        const _header = {};
        for (const key in request.headers)
          _header[key] = request.headers.get(key);
        if (validator.headers.Check(_header) === false)
          throw new ValidationError("header", validator.headers, _header);
      }
      if (validator.params?.Check(context.params) === false)
        throw new ValidationError("params", validator.params, context.params);
      if (validator.query?.Check(context.query) === false)
        throw new ValidationError("query", validator.query, context.query);
      if (validator.cookie) {
        const cookieValue = {};
        for (const [key, value2] of Object.entries(context.cookie))
          cookieValue[key] = value2.value;
        if (validator.cookie?.Check(cookieValue) === false)
          throw new ValidationError("cookie", validator.cookie, cookieValue);
      }
      if (validator.body?.Check(body) === false)
        throw new ValidationError("body", validator.body, body);
    }
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let response2 = hooks.beforeHandle[i](context);
      if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 !== undefined) {
        context.response = response2;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let newResponse = hooks.afterHandle[i2](context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          if (newResponse)
            response2 = newResponse;
        }
        const result = mapEarlyResponse(response2, context.set);
        if (result)
          return result;
      }
    }
    let response = handle(context);
    if (response instanceof Promise)
      response = await response;
    if (!hooks.afterHandle.length) {
      const responseValidator = validator?.response?.[response.status];
      if (responseValidator?.Check(response) === false)
        throw new ValidationError("response", responseValidator, response);
    } else {
      context.response = response;
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        let newResponse = hooks.afterHandle[i](context);
        if (newResponse instanceof Promise)
          newResponse = await newResponse;
        const result = mapEarlyResponse(newResponse, context.set);
        if (result !== undefined) {
          const responseValidator = validator?.response?.[response.status];
          if (responseValidator?.Check(result) === false)
            throw new ValidationError("response", responseValidator, result);
          return result;
        }
      }
    }
    if (context.set.cookie && cookieMeta?.sign) {
      const secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (cookieMeta.sign === true)
        for (const [key, cookie] of Object.entries(context.set.cookie))
          context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
      else
        for (const name of cookieMeta.sign) {
          if (!(name in cookieMeta.properties))
            continue;
          if (context.set.cookie[name]?.value) {
            context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
          }
        }
    }
    return mapResponse(response, context.set);
  } catch (error22) {
    if (error22.status)
      set2.status = error22.status;
    return app.handleError(context, error22);
  } finally {
    for (const onResponse of app.event.onResponse)
      await onResponse(context);
  }
};
var createDynamicErrorHandler = (app) => async (context, error22) => {
  const errorContext = Object.assign(context, { error: error22, code: error22.code });
  errorContext.set = context.set;
  for (let i = 0;i < app.event.error.length; i++) {
    let response = app.event.error[i](errorContext);
    if (response instanceof Promise)
      response = await response;
    if (response !== undefined && response !== null)
      return mapResponse(response, context.set);
  }
  return new Response(typeof error22.cause === "string" ? error22.cause : error22.message, {
    headers: context.set.headers,
    status: error22.status ?? 500
  });
};
var t = Object.assign({}, Type);
try {
  TypeSystem.Format("email", (value2) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test(value2));
  TypeSystem.Format("uuid", (value2) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(value2));
  TypeSystem.Format("date", (value2) => !Number.isNaN(new Date(value2).getTime()));
  TypeSystem.Format("date-time", (value2) => !Number.isNaN(new Date(value2).getTime()));
} catch {}
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value2) => {
  if (!(value2 instanceof Blob))
    return false;
  if (options.minSize && value2.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value2.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value2.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value2.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var Files = TypeSystem.Type("Files", (options, value2) => {
  if (!Array.isArray(value2))
    return validateFile(options, value2);
  if (options.minItems && value2.length < options.minItems)
    return false;
  if (options.maxItems && value2.length > options.maxItems)
    return false;
  for (let i = 0;i < value2.length; i++)
    if (!validateFile(options, value2[i]))
      return false;
  return true;
});
exports_format.Set("numeric", (value2) => !!value2 && !isNaN(+value2));
exports_format.Set("boolean", (value2) => value2 === "true" || value2 === "false");
exports_format.Set("ObjectString", (value2) => {
  let start = value2.charCodeAt(0);
  if (start === 9 || start === 10 || start === 32)
    start = value2.trimStart().charCodeAt(0);
  if (start !== 123 && start !== 91)
    return false;
  try {
    JSON.parse(value2);
    return true;
  } catch {
    return false;
  }
});
var ElysiaType = {
  Numeric: (property) => {
    const schema3 = Type.Number(property);
    return t.Transform(t.Union([
      t.String({
        format: "numeric",
        default: 0
      }),
      t.Number(property)
    ], property)).Decode((value2) => {
      const number3 = +value2;
      if (isNaN(number3))
        return value2;
      if (property && !exports_value2.Check(schema3, number3))
        throw new ValidationError("property", schema3, number3);
      return number3;
    }).Encode((value2) => value2);
  },
  BooleanString: (property) => {
    const schema3 = Type.Boolean(property);
    return t.Transform(t.Union([
      t.String({
        format: "boolean",
        default: false
      }),
      t.Boolean(property)
    ], property)).Decode((value2) => {
      if (typeof value2 === "string")
        return value2 === "true";
      if (property && !exports_value2.Check(schema3, value2))
        throw new ValidationError("property", schema3, value2);
      return value2;
    }).Encode((value2) => value2);
  },
  ObjectString: (properties, options) => t.Transform(t.Union([
    t.String({
      format: "ObjectString",
      default: ""
    }),
    t.Object(properties, options)
  ], options)).Decode((value2) => {
    if (typeof value2 === "string")
      try {
        return JSON.parse(value2);
      } catch {
        return value2;
      }
    return value2;
  }).Encode((value2) => JSON.stringify(value2)),
  File: TypeSystem.Type("File", validateFile),
  Files: (options = {}) => t.Transform(t.Union([Files(options)])).Decode((value2) => {
    if (Array.isArray(value2))
      return value2;
    return [value2];
  }).Encode((value2) => value2),
  Nullable: (schema3) => t.Union([t.Null(), schema3]),
  MaybeEmpty: (schema3) => t.Union([t.Null(), t.Undefined(), schema3]),
  Cookie: (properties, options) => t.Object(properties, options)
};
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.Numeric = ElysiaType.Numeric;
t.File = (arg = {}) => ElysiaType.File({
  default: "File",
  ...arg,
  extension: arg?.type,
  type: "string",
  format: "binary"
});
t.Files = (arg = {}) => ElysiaType.Files({
  ...arg,
  elysiaMeta: "Files",
  default: "Files",
  extension: arg?.type,
  type: "array",
  items: {
    ...arg,
    default: "Files",
    type: "string",
    format: "binary"
  }
});
t.Nullable = (schema3) => ElysiaType.Nullable(schema3);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
var Elysia = class _Elysia {
  constructor(config) {
    this.dependencies = {};
    this.store = {};
    this.decorators = {};
    this.definitions = {
      type: {},
      error: {}
    };
    this.schema = {};
    this.macros = [];
    this.event = {
      start: [],
      request: [],
      parse: [],
      transform: [],
      beforeHandle: [],
      afterHandle: [],
      mapResponse: [],
      onResponse: [],
      trace: [],
      error: [],
      stop: []
    };
    this.reporter = new eventemitter3_default;
    this.server = null;
    this.validator = null;
    this.router = new Memoirist;
    this.wsRouter = new Memoirist;
    this.routes = [];
    this.staticRouter = {
      handlers: [],
      variables: "",
      map: {},
      all: ""
    };
    this.wsPaths = {};
    this.dynamicRouter = new Memoirist;
    this.lazyLoadModules = [];
    this.path = "";
    this.stack = undefined;
    this.handle = async (request) => this.fetch(request);
    this.fetch = (request) => {
      if (false)
        ;
      return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
    };
    this.handleError = async (context, error22) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error22);
    this.outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", {
      status: error22?.status ?? 500
    });
    this.listen = (options, callback) => {
      if (typeof Bun === "undefined")
        throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
      this.compile();
      if (typeof options === "string") {
        options = +options.trim();
        if (Number.isNaN(options))
          throw new Error("Port must be a numeric value");
      }
      const fetch = this.fetch;
      const serve = typeof options === "object" ? {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        ...options || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        fetch,
        error: this.outerErrorHandler
      } : {
        development: !isProduction,
        reusePort: true,
        ...this.config.serve || {},
        websocket: {
          ...this.config.websocket || {},
          ...websocket || {}
        },
        port: options,
        fetch,
        error: this.outerErrorHandler
      };
      this.server = Bun?.serve(serve);
      if (this.event.start.length)
        for (let i = 0;i < this.event.start.length; i++)
          this.event.start[i](this);
      if (callback)
        callback(this.server);
      process.on("beforeExit", () => {
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i](this);
      });
      Promise.all(this.lazyLoadModules).then(() => {
        Bun?.gc(false);
      });
      return this;
    };
    this.stop = async () => {
      if (!this.server)
        throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
      this.server.stop();
      if (this.event.stop.length)
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i](this);
    };
    this.config = {
      forceErrorEncapsulation: true,
      prefix: "",
      aot: true,
      strictPath: false,
      scoped: false,
      cookie: {},
      analytic: false,
      ...config || {},
      seed: config?.seed === undefined ? "" : config?.seed
    };
    if (config?.analytic && (config?.name || config?.seed !== undefined))
      this.stack = new Error().stack;
  }
  getServer() {
    return this.server;
  }
  add(method, paths, handle, localHook, { allowMeta = false, skipPrefix = false } = {
    allowMeta: false,
    skipPrefix: false
  }) {
    if (typeof paths === "string")
      paths = [paths];
    for (let path of paths) {
      path = path === "" ? path : path.charCodeAt(0) === 47 ? path : `/${path}`;
      if (this.config.prefix && !skipPrefix && !this.config.scoped)
        path = this.config.prefix + path;
      if (localHook?.type)
        switch (localHook.type) {
          case "text":
            localHook.type = "text/plain";
            break;
          case "json":
            localHook.type = "application/json";
            break;
          case "formdata":
            localHook.type = "multipart/form-data";
            break;
          case "urlencoded":
            localHook.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            localHook.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const models = this.definitions.type;
      let cookieValidator = getSchemaValidator(localHook?.cookie ?? this.validator?.cookie, {
        dynamic: !this.config.aot,
        models,
        additionalProperties: true
      });
      if (isNotEmpty(this.config.cookie ?? {})) {
        if (cookieValidator) {
          cookieValidator.schema = mergeCookie(cookieValidator.schema, this.config.cookie ?? {});
        } else {
          cookieValidator = getSchemaValidator(t.Cookie({}, this.config.cookie), {
            dynamic: !this.config.aot,
            models,
            additionalProperties: true
          });
        }
      }
      const validator = {
        body: getSchemaValidator(localHook?.body ?? this.validator?.body, {
          dynamic: !this.config.aot,
          models
        }),
        headers: getSchemaValidator(localHook?.headers ?? this.validator?.headers, {
          dynamic: !this.config.aot,
          models,
          additionalProperties: true
        }),
        params: getSchemaValidator(localHook?.params ?? this.validator?.params, {
          dynamic: !this.config.aot,
          models
        }),
        query: getSchemaValidator(localHook?.query ?? this.validator?.query, {
          dynamic: !this.config.aot,
          models
        }),
        cookie: cookieValidator,
        response: getResponseSchemaValidator(localHook?.response ?? this.validator?.response, {
          dynamic: !this.config.aot,
          models
        })
      };
      const globalHook = this.event;
      const loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      if (this.macros.length) {
        const createManager = (stackName) => (type3, fn) => {
          if (typeof type3 === "function" || Array.isArray(type3)) {
            if (!localHook[stackName])
              localHook[stackName] = [];
            if (typeof localHook[stackName] === "function")
              localHook[stackName] = [localHook[stackName]];
            if (Array.isArray(type3))
              localHook[stackName] = localHook[stackName].concat(type3);
            else
              localHook[stackName].push(type3);
            return;
          }
          const { insert = "after", stack = "local" } = type3;
          if (stack === "global") {
            if (!Array.isArray(fn)) {
              if (insert === "before") {
                globalHook[stackName].unshift(fn);
              } else {
                globalHook[stackName].push(fn);
              }
            } else {
              if (insert === "before") {
                globalHook[stackName] = fn.concat(globalHook[stackName]);
              } else {
                globalHook[stackName] = globalHook[stackName].concat(fn);
              }
            }
            return;
          } else {
            if (!localHook[stackName])
              localHook[stackName] = [];
            if (typeof localHook[stackName] === "function")
              localHook[stackName] = [localHook[stackName]];
            if (!Array.isArray(fn)) {
              if (insert === "before") {
                localHook[stackName].unshift(fn);
              } else {
                localHook[stackName].push(fn);
              }
            } else {
              if (insert === "before") {
                localHook[stackName] = fn.concat(localHook[stackName]);
              } else {
                localHook[stackName] = localHook[stackName].concat(fn);
              }
            }
            return;
          }
        };
        const manager = {
          events: {
            global: globalHook,
            local: localHook
          },
          onParse: createManager("parse"),
          onTransform: createManager("transform"),
          onBeforeHandle: createManager("beforeHandle"),
          onAfterHandle: createManager("afterHandle"),
          onResponse: createManager("onResponse"),
          onError: createManager("error")
        };
        for (const macro of this.macros)
          traceBackMacro(macro(manager), localHook);
      }
      const hooks = mergeHook(globalHook, localHook);
      const isFn = typeof handle === "function";
      if (this.config.aot === false) {
        this.dynamicRouter.add(method, path, {
          validator,
          hooks,
          content: localHook?.type,
          handle
        });
        if (this.config.strictPath === false) {
          this.dynamicRouter.add(method, loosePath, {
            validator,
            hooks,
            content: localHook?.type,
            handle
          });
        }
        this.routes.push({
          method,
          path,
          composed: null,
          handler: handle,
          hooks
        });
        return;
      }
      const mainHandler = composeHandler({
        path,
        method,
        hooks,
        validator,
        handler: handle,
        handleError: this.handleError,
        onRequest: this.event.request,
        config: this.config,
        definitions: allowMeta ? this.definitions.type : undefined,
        schema: allowMeta ? this.schema : undefined,
        getReporter: () => this.reporter,
        setHeader: this.setHeaders
      });
      if (!isFn) {
        const context = Object.assign({
          headers: {},
          query: {},
          params: {},
          body: undefined,
          request: new Request(`http://localhost${path}`),
          store: this.store,
          path,
          set: {
            headers: this.setHeaders ?? {},
            status: 200
          }
        }, this.decorators);
        let response;
        for (const onRequest of Object.values(hooks.request)) {
          try {
            const inner = mapEarlyResponse(onRequest(context), context.set);
            if (inner !== undefined) {
              response = inner;
              break;
            }
          } catch (error22) {
            response = this.handleError(context, error22);
            break;
          }
        }
        if (response)
          mainHandler.response = response;
        else {
          try {
            mainHandler.response = mainHandler(context);
          } catch (error22) {
            mainHandler.response = this.handleError(context, error22);
          }
        }
      }
      const existingRouteIndex = this.routes.findIndex((route) => route.path === path && route.method === method);
      if (existingRouteIndex !== -1) {
        this.routes.splice(existingRouteIndex, 1);
      }
      this.routes.push({
        method,
        path,
        composed: mainHandler,
        handler: handle,
        hooks
      });
      if (method === "$INTERNALWS") {
        const loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
        if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
          const index = this.staticRouter.handlers.length;
          this.staticRouter.handlers.push(mainHandler);
          if (mainHandler.response instanceof Response)
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response
`;
          else
            this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
          this.wsPaths[path] = index;
          if (loose)
            this.wsPaths[loose] = index;
        } else {
          this.wsRouter.add("ws", path, mainHandler);
          if (loose)
            this.wsRouter.add("ws", loose, mainHandler);
        }
        return;
      }
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        const index = this.staticRouter.handlers.length;
        this.staticRouter.handlers.push(mainHandler);
        if (mainHandler.response instanceof Response)
          this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}].response
`;
        else
          this.staticRouter.variables += `const st${index} = staticRouter.handlers[${index}]
`;
        if (!this.staticRouter.map[path])
          this.staticRouter.map[path] = {
            code: ""
          };
        if (method === "ALL")
          this.staticRouter.map[path].all = `default: return st${index}(ctx)
`;
        else {
          if (mainHandler.response instanceof Response)
            this.staticRouter.map[path].code = `case '${method}': return st${index}.clone()
${this.staticRouter.map[path].code}`;
          else
            this.staticRouter.map[path].code = `case '${method}': return st${index}(ctx)
${this.staticRouter.map[path].code}`;
        }
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[loosePath])
            this.staticRouter.map[loosePath] = {
              code: ""
            };
          if (method === "ALL")
            this.staticRouter.map[loosePath].all = `default: return st${index}(ctx)
`;
          else {
            if (mainHandler.response instanceof Response)
              this.staticRouter.map[loosePath].code = `case '${method}': return st${index}.clone()
${this.staticRouter.map[loosePath].code}`;
            else
              this.staticRouter.map[loosePath].code = `case '${method}': return st${index}(ctx)
${this.staticRouter.map[loosePath].code}`;
          }
        }
      } else {
        this.router.add(method, path, mainHandler);
        if (!this.config.strictPath)
          this.router.add(method, path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/", mainHandler);
      }
    }
  }
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    this.setHeaders = mergeDeep(this.setHeaders, header);
    return this;
  }
  onStart(handler) {
    this.on("start", handler);
    return this;
  }
  onRequest(handler) {
    this.on("request", handler);
    return this;
  }
  onParse(parser) {
    this.on("parse", parser);
    return this;
  }
  onTransform(handler) {
    this.on("transform", handler);
    return this;
  }
  resolve(resolver2) {
    resolver2.$elysia = "resolve";
    return this.onBeforeHandle(resolver2);
  }
  onBeforeHandle(handler) {
    this.on("beforeHandle", handler);
    return this;
  }
  onAfterHandle(handler) {
    this.on("afterHandle", handler);
    return this;
  }
  mapResponse(handler) {
    this.on("mapResponse", handler);
    return this;
  }
  onResponse(handler) {
    this.on("response", handler);
    return this;
  }
  trace(handler) {
    this.reporter.on("event", createTraceListener(() => this.reporter, this.event.trace.length, handler));
    this.on("trace", handler);
    return this;
  }
  error(name, error22) {
    switch (typeof name) {
      case "string":
        error22.prototype[ERROR_CODE] = name;
        this.definitions.error[name] = error22;
        return this;
      case "function":
        this.definitions.error = name(this.definitions.error);
        return this;
    }
    for (const [code, error3] of Object.entries(name)) {
      error3.prototype[ERROR_CODE] = code;
      this.definitions.error[code] = error3;
    }
    return this;
  }
  onError(handler) {
    this.on("error", handler);
    return this;
  }
  onStop(handler) {
    this.on("stop", handler);
    return this;
  }
  on(type3, handlers) {
    for (let handler of Array.isArray(handlers) ? handlers : [handlers]) {
      handler = asGlobal(handler);
      switch (type3) {
        case "start":
          this.event.start.push(handler);
          break;
        case "request":
          this.event.request.push(handler);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, handler);
          break;
        case "transform":
          this.event.transform.push(handler);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(handler);
          break;
        case "afterHandle":
          this.event.afterHandle.push(handler);
          break;
        case "mapResponse":
          this.event.mapResponse.push(handler);
          break;
        case "response":
          this.event.onResponse.push(handler);
          break;
        case "trace":
          this.event.trace.push(handler);
          break;
        case "error":
          this.event.error.push(handler);
          break;
        case "stop":
          this.event.stop.push(handler);
          break;
      }
    }
    return this;
  }
  group(prefix, schemaOrRun, run) {
    const instance = new _Elysia({
      ...this.config || {},
      prefix: ""
    });
    instance.store = this.store;
    instance.definitions = this.definitions;
    instance.getServer = () => this.server;
    const isSchema = typeof schemaOrRun === "object";
    const sandbox = (isSchema ? run : schemaOrRun)(instance);
    this.decorators = mergeDeep(this.decorators, instance.decorators);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.routes).forEach(({ method, path, handler, hooks }) => {
      path = (isSchema ? "" : this.config.prefix) + prefix + path;
      if (isSchema) {
        const hook = schemaOrRun;
        const localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, {
          ...localHook || {},
          error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
            ...localHook.error || {},
            ...sandbox.event.error || {}
          ] : [
            localHook.error,
            ...sandbox.event.error || {}
          ]
        }));
      } else {
        this.add(method, path, handler, mergeHook(hooks, {
          error: sandbox.event.error
        }), {
          skipPrefix: true
        });
      }
    });
    return this;
  }
  guard(hook, run) {
    if (!run) {
      this.event = mergeLifeCycle(this.event, hook);
      this.validator = {
        body: hook.body,
        headers: hook.headers,
        params: hook.params,
        query: hook.query,
        response: hook.response
      };
      return this;
    }
    const instance = new _Elysia({
      ...this.config || {},
      prefix: ""
    });
    instance.store = this.store;
    instance.definitions = this.definitions;
    const sandbox = run(instance);
    this.decorators = mergeDeep(this.decorators, instance.decorators);
    if (sandbox.event.request.length)
      this.event.request = [
        ...this.event.request || [],
        ...sandbox.event.request || []
      ];
    if (sandbox.event.onResponse.length)
      this.event.onResponse = [
        ...this.event.onResponse || [],
        ...sandbox.event.onResponse || []
      ];
    this.model(sandbox.definitions.type);
    Object.values(instance.routes).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, {
        ...localHook || {},
        error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [
          ...localHook.error || {},
          ...sandbox.event.error || []
        ] : [localHook.error, ...sandbox.event.error || []]
      }));
    });
    return this;
  }
  use(plugin) {
    if (plugin instanceof Promise) {
      this.lazyLoadModules.push(plugin.then((plugin2) => {
        if (typeof plugin2 === "function") {
          return plugin2(this);
        }
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        return this._use(plugin2);
      }).then((x) => x.compile()));
      return this;
    } else
      return this._use(plugin);
    return this;
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      const instance = plugin(this);
      if (instance instanceof Promise) {
        this.lazyLoadModules.push(instance.then((plugin2) => {
          if (plugin2 instanceof _Elysia) {
            this.compile();
            for (const {
              method,
              path,
              handler,
              hooks
            } of Object.values(plugin2.routes)) {
              this.add(method, path, handler, mergeHook(hooks, {
                error: plugin2.event.error
              }));
            }
            return plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile()));
        return this;
      }
      return instance;
    }
    const { name, seed } = plugin.config;
    plugin.getServer = () => this.getServer();
    this.headers(plugin.setHeaders);
    const isScoped = plugin.config.scoped;
    if (isScoped) {
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.stack,
          routes: plugin.routes,
          decorators: plugin.decorators,
          store: plugin.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x.$elysia === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x.$elysia === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        });
      }
      plugin.model(this.definitions.type);
      plugin.error(this.definitions.error);
      plugin.macros = [...this.macros || [], ...plugin.macros || []];
      plugin.onRequest((context) => {
        Object.assign(context, this.decorators);
        Object.assign(context.store, this.store);
      });
      if (plugin.event.trace.length)
        plugin.event.trace.push(...plugin.event.trace);
      if (isScoped && !plugin.config.prefix)
        console.warn("When using scoped plugins it is recommended to use a prefix, else routing may not work correctly for the second scoped instance");
      if (plugin.event.error.length)
        plugin.event.error.push(...this.event.error);
      if (plugin.config.aot)
        plugin.compile();
      let instance;
      if (isScoped && plugin.config.prefix) {
        instance = this.mount(plugin.config.prefix + "/", plugin.fetch);
        for (const route of plugin.routes)
          this.routes.push({
            ...route,
            path: `${plugin.config.prefix}${route.path}`,
            hooks: mergeHook(route.hooks, {
              error: this.event.error
            })
          });
      } else {
        instance = this.mount(plugin.fetch);
        if (instance.routes.length)
          this.routes.push(...instance.routes);
      }
      return this;
    } else {
      plugin.reporter = this.reporter;
      for (const trace of plugin.event.trace)
        this.trace(trace);
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          this.macros.push(...plugin.macros || []);
        const macroHashes = [];
        for (let i = 0;i < this.macros.length; i++) {
          const macro = this.macros[i];
          if (macroHashes.includes(macro.$elysiaChecksum)) {
            this.macros.splice(i, 1);
            i--;
          }
          macroHashes.push(macro.$elysiaChecksum);
        }
      }
    }
    this.decorate(plugin.decorators);
    this.state(plugin.store);
    this.model(plugin.definitions.type);
    this.error(plugin.definitions.error);
    for (const { method, path, handler, hooks } of Object.values(plugin.routes)) {
      this.add(method, path, handler, mergeHook(hooks, {
        error: plugin.event.error
      }));
    }
    if (!isScoped)
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        const current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies
        } : {
          name: plugin.config.name,
          seed: plugin.config.seed,
          checksum: current,
          dependencies: plugin.dependencies,
          stack: plugin.stack,
          routes: plugin.routes,
          decorators: plugin.decorators,
          store: plugin.store,
          type: plugin.definitions.type,
          error: plugin.definitions.error,
          derive: plugin.event.transform.filter((x) => x?.$elysia === "derive").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          })),
          resolve: plugin.event.transform.filter((x) => x?.$elysia === "resolve").map((x) => ({
            fn: x.toString(),
            stack: new Error().stack ?? ""
          }))
        });
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
      } else {
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
      }
    return this;
  }
  macro(macro) {
    macro.$elysiaChecksum = checksum(JSON.stringify({
      name: this.config.name,
      seed: this.config.seed,
      content: macro.toString()
    }));
    this.macros.push(macro);
    return this;
  }
  mount(path, handle) {
    if (path instanceof _Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      const run = typeof path === "function" ? path : path instanceof _Elysia ? path.compile().fetch : handle instanceof _Elysia ? handle.compile().fetch : handle;
      const handler2 = async ({ request, path: path2 }) => run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
      this.all("/", handler2, {
        type: "none"
      });
      this.all("/*", handler2, {
        type: "none"
      });
      return this;
    }
    const length = path.length;
    if (handle instanceof _Elysia)
      handle = handle.compile().fetch;
    const handler = async ({ request, path: path2 }) => handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
    this.all(path, handler, {
      type: "none"
    });
    this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, {
      type: "none"
    });
    return this;
  }
  get(path, handler, hook) {
    this.add("GET", path, handler, hook);
    return this;
  }
  post(path, handler, hook) {
    this.add("POST", path, handler, hook);
    return this;
  }
  put(path, handler, hook) {
    this.add("PUT", path, handler, hook);
    return this;
  }
  patch(path, handler, hook) {
    this.add("PATCH", path, handler, hook);
    return this;
  }
  delete(path, handler, hook) {
    this.add("DELETE", path, handler, hook);
    return this;
  }
  options(path, handler, hook) {
    this.add("OPTIONS", path, handler, hook);
    return this;
  }
  all(path, handler, hook) {
    this.add("ALL", path, handler, hook);
    return this;
  }
  head(path, handler, hook) {
    this.add("HEAD", path, handler, hook);
    return this;
  }
  connect(path, handler, hook) {
    this.add("CONNECT", path, handler, hook);
    return this;
  }
  ws(path, options) {
    const transform4 = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined;
    let server = null;
    const validateMessage = getSchemaValidator(options?.body, {
      models: this.definitions.type
    });
    const validateResponse = getSchemaValidator(options?.response, {
      models: this.definitions.type
    });
    const parseMessage = (message) => {
      if (typeof message === "string") {
        const start = message?.charCodeAt(0);
        if (start === 47 || start === 123)
          try {
            message = JSON.parse(message);
          } catch {}
        else if (isNumericString(message))
          message = +message;
      }
      if (transform4?.length)
        for (let i = 0;i < transform4.length; i++) {
          const temp = transform4[i](message);
          if (temp !== undefined)
            message = temp;
        }
      return message;
    };
    this.route("$INTERNALWS", path, (context) => {
      const { set: set2, path: path2, qi, headers, query, params } = context;
      if (server === null)
        server = this.getServer();
      if (server?.upgrade(context.request, {
        headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade,
        data: {
          validator: validateResponse,
          open(ws) {
            options.open?.(new ElysiaWS(ws, context));
          },
          message: (ws, msg) => {
            const message = parseMessage(msg);
            if (validateMessage?.Check(message) === false)
              return void ws.send(new ValidationError("message", validateMessage, message).message);
            options.message?.(new ElysiaWS(ws, context), message);
          },
          drain(ws) {
            options.drain?.(new ElysiaWS(ws, context));
          },
          close(ws, code, reason) {
            options.close?.(new ElysiaWS(ws, context), code, reason);
          }
        }
      }))
        return;
      set2.status = 400;
      return "Expected a websocket connection";
    }, {
      beforeHandle: options.beforeHandle,
      transform: options.transform,
      headers: options.headers,
      params: options.params,
      query: options.query
    });
    return this;
  }
  route(method, path, handler, {
    config,
    ...hook
  } = {
    config: {
      allowMeta: false
    }
  }) {
    this.add(method, path, handler, hook, config);
    return this;
  }
  state(name, value2) {
    switch (typeof name) {
      case "object":
        this.store = mergeDeep(this.store, name);
        return this;
      case "function":
        this.store = name(this.store);
        return this;
    }
    if (!(name in this.store)) {
      this.store[name] = value2;
    }
    return this;
  }
  decorate(name, value2) {
    switch (typeof name) {
      case "object":
        this.decorators = mergeDeep(this.decorators, name);
        return this;
      case "function":
        this.decorators = name(this.decorators);
        return this;
    }
    if (!(name in this.decorators))
      this.decorators[name] = value2;
    return this;
  }
  derive(transform4) {
    transform4.$elysia = "derive";
    return this.onTransform(transform4);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        Object.entries(name).forEach(([key, value2]) => {
          if (!(key in this.definitions.type))
            this.definitions.type[key] = value2;
        });
        return this;
      case "function":
        this.definitions.type = name(this.definitions.type);
        return this;
    }
    this.definitions.type[name] = model;
    return this;
  }
  mapDerive(mapper) {
    mapper.$elysia = "derive";
    return this.onTransform(mapper);
  }
  affix(base, type3, word) {
    if (word === "")
      return this;
    const delimieter = ["_", "-", " "];
    const capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1);
    const joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix);
    const remap = (type22) => {
      const store = {};
      switch (type22) {
        case "decorator":
          for (const key in this.decorators)
            store[joinKey(word, key)] = this.decorators[key];
          this.decorators = store;
          break;
        case "state":
          for (const key in this.store)
            store[joinKey(word, key)] = this.store[key];
          this.store = store;
          break;
        case "model":
          for (const key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (const key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    };
    const types = Array.isArray(type3) ? type3 : [type3];
    for (const type22 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type22);
    return this;
  }
  prefix(type3, word) {
    return this.affix("prefix", type3, word);
  }
  suffix(type3, word) {
    return this.affix("suffix", type3, word);
  }
  compile() {
    this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this);
    if (typeof this.server?.reload === "function")
      this.server.reload({
        ...this.server || {},
        fetch: this.fetch
      });
    return this;
  }
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
};

// src/config/database.ts
import { readFileSync } from "node:fs";

// node_modules/pg/esm/index.mjs
var import_lib = __toESM(require_lib3(), 1);
var Client = import_lib.default.Client;
var Pool = import_lib.default.Pool;
var Connection = import_lib.default.Connection;
var types = import_lib.default.types;
var Query = import_lib.default.Query;
var DatabaseError = import_lib.default.DatabaseError;
var escapeIdentifier = import_lib.default.escapeIdentifier;
var escapeLiteral = import_lib.default.escapeLiteral;
var Result = import_lib.default.Result;
var TypeOverrides = import_lib.default.TypeOverrides;
var defaults = import_lib.default.defaults;

// src/config/database.ts
var databaseUrl = process.env.DATABASE_URL || "postgres://postgres:postgres@localhost:5432/payments";
var pool = new Pool({
  connectionString: databaseUrl,
  max: 20,
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000
});
async function testConnection() {
  try {
    const client = await pool.connect();
    console.log("✅ Conexión a PostgreSQL establecida correctamente");
    client.release();
  } catch (err) {
    console.error("❌ Error al conectar a PostgreSQL:", err);
  }
}
async function query(text, params = []) {
  try {
    const start = Date.now();
    const res = await pool.query(text, params);
    const duration = Date.now() - start;
    if (duration > 100) {
      console.log("⏱️ Query lento:", { text, duration, rows: res.rowCount });
    }
    return res;
  } catch (err) {
    console.error("❌ Error ejecutando query:", err);
    throw err;
  }
}
async function migrateDB() {
  try {
    const tables = await pool.query("SELECT table_name FROM information_schema.tables WHERE table_schema = $1", ["public"]);
    if (tables.rowCount === 0) {
      const schema3 = readFileSync("schema.sql", "utf8");
      await pool.query(schema3);
    }
    console.log("✅ Base de datos inicializada correctamente");
  } catch (err) {
    console.error("❌ Error al inicializar la base de datos:", err);
    throw err;
  }
}
function generateApiKey() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  const length = 40;
  for (let i = 0;i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// src/services/monitor.service.ts
var import_cron = __toESM(require_dist2(), 1);

// src/services/qr.service.ts
var import_qrcode = __toESM(require_server(), 1);
var import_date_fns = __toESM(require_date_fns(), 1);

// src/services/crypto.service.ts
import crypto2 from "crypto";

class CryptoService {
  algorithm = "aes-256-cbc";
  key;
  iv;
  constructor(encryptionKey) {
    this.key = crypto2.createHash("sha256").update(String(encryptionKey)).digest();
    this.iv = Buffer.alloc(16, 0);
  }
  encrypt(text, customKey) {
    try {
      const key = customKey ? crypto2.createHash("sha256").update(String(customKey)).digest() : this.key;
      const cipher = crypto2.createCipheriv(this.algorithm, key, this.iv);
      let encrypted = cipher.update(text, "utf8", "base64");
      encrypted += cipher.final("base64");
      return encrypted;
    } catch (error3) {
      console.error("Error en encriptación:", error3);
      throw new Error("Error en proceso de encriptación");
    }
  }
  decrypt(encryptedText, customKey) {
    try {
      const key = customKey ? crypto2.createHash("sha256").update(String(customKey)).digest() : this.key;
      const decipher = crypto2.createDecipheriv(this.algorithm, key, this.iv);
      let decrypted = decipher.update(encryptedText, "base64", "utf8");
      decrypted += decipher.final("utf8");
      return decrypted;
    } catch (error3) {
      console.error("Error en desencriptación:", error3);
      throw new Error("Error en proceso de desencriptación");
    }
  }
}
var cryptoService = new CryptoService(process.env.CRYPTO_KEY || "default-encryption-key");
var crypto_service_default = cryptoService;

// node_modules/node-fetch/src/index.js
import http2 from "node:http";
import https from "node:https";
import zlib from "node:zlib";
import Stream2, { PassThrough as PassThrough2, pipeline as pump } from "node:stream";
import { Buffer as Buffer3 } from "node:buffer";

// node_modules/data-uri-to-buffer/dist/index.js
function dataUriToBuffer(uri) {
  if (!/^data:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri = uri.replace(/\r?\n/g, "");
  const firstComma = uri.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri.substring(5, firstComma).split(";");
  let charset = "";
  let base64 = false;
  const type3 = meta[0] || "text/plain";
  let typeFull = type3;
  for (let i = 1;i < meta.length; i++) {
    if (meta[i] === "base64") {
      base64 = true;
    } else if (meta[i]) {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset.length) {
    typeFull += ";charset=US-ASCII";
    charset = "US-ASCII";
  }
  const encoding = base64 ? "base64" : "ascii";
  const data = unescape(uri.substring(firstComma + 1));
  const buffer = Buffer.from(data, encoding);
  buffer.type = type3;
  buffer.typeFull = typeFull;
  buffer.charset = charset;
  return buffer;
}
var dist_default = dataUriToBuffer;

// node_modules/node-fetch/src/body.js
init_fetch_blob();
init_esm_min();
import Stream, { PassThrough } from "node:stream";
import { types as types2, deprecate, promisify } from "node:util";
import { Buffer as Buffer2 } from "node:buffer";

// node_modules/node-fetch/src/errors/base.js
class FetchBaseError extends Error {
  constructor(message, type3) {
    super(message);
    Error.captureStackTrace(this, this.constructor);
    this.type = type3;
  }
  get name() {
    return this.constructor.name;
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
}

// node_modules/node-fetch/src/errors/fetch-error.js
class FetchError extends FetchBaseError {
  constructor(message, type3, systemError) {
    super(message, type3);
    if (systemError) {
      this.code = this.errno = systemError.code;
      this.erroredSysCall = systemError.syscall;
    }
  }
}

// node_modules/node-fetch/src/utils/is.js
var NAME = Symbol.toStringTag;
var isURLSearchParameters = (object3) => {
  return typeof object3 === "object" && typeof object3.append === "function" && typeof object3.delete === "function" && typeof object3.get === "function" && typeof object3.getAll === "function" && typeof object3.has === "function" && typeof object3.set === "function" && typeof object3.sort === "function" && object3[NAME] === "URLSearchParams";
};
var isBlob = (object3) => {
  return object3 && typeof object3 === "object" && typeof object3.arrayBuffer === "function" && typeof object3.type === "string" && typeof object3.stream === "function" && typeof object3.constructor === "function" && /^(Blob|File)$/.test(object3[NAME]);
};
var isAbortSignal = (object3) => {
  return typeof object3 === "object" && (object3[NAME] === "AbortSignal" || object3[NAME] === "EventTarget");
};
var isDomainOrSubdomain = (destination, original) => {
  const orig = new URL(original).hostname;
  const dest = new URL(destination).hostname;
  return orig === dest || orig.endsWith(`.${dest}`);
};
var isSameProtocol = (destination, original) => {
  const orig = new URL(original).protocol;
  const dest = new URL(destination).protocol;
  return orig === dest;
};

// node_modules/node-fetch/src/body.js
var pipeline = promisify(Stream.pipeline);
var INTERNALS = Symbol("Body internals");

class Body {
  constructor(body, {
    size = 0
  } = {}) {
    let boundary = null;
    if (body === null) {
      body = null;
    } else if (isURLSearchParameters(body)) {
      body = Buffer2.from(body.toString());
    } else if (isBlob(body)) {} else if (Buffer2.isBuffer(body)) {} else if (types2.isAnyArrayBuffer(body)) {
      body = Buffer2.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer2.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream) {} else if (body instanceof FormData) {
      body = formDataToBlob(body);
      boundary = body.type.split("=")[1];
    } else {
      body = Buffer2.from(String(body));
    }
    let stream = body;
    if (Buffer2.isBuffer(body)) {
      stream = Stream.Readable.from(body);
    } else if (isBlob(body)) {
      stream = Stream.Readable.from(body.stream());
    }
    this[INTERNALS] = {
      body,
      stream,
      boundary,
      disturbed: false,
      error: null
    };
    this.size = size;
    if (body instanceof Stream) {
      body.on("error", (error_) => {
        const error3 = error_ instanceof FetchBaseError ? error_ : new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, "system", error_);
        this[INTERNALS].error = error3;
      });
    }
  }
  get body() {
    return this[INTERNALS].stream;
  }
  get bodyUsed() {
    return this[INTERNALS].disturbed;
  }
  async arrayBuffer() {
    const { buffer, byteOffset, byteLength } = await consumeBody(this);
    return buffer.slice(byteOffset, byteOffset + byteLength);
  }
  async formData() {
    const ct = this.headers.get("content-type");
    if (ct.startsWith("application/x-www-form-urlencoded")) {
      const formData = new FormData;
      const parameters3 = new URLSearchParams(await this.text());
      for (const [name, value2] of parameters3) {
        formData.append(name, value2);
      }
      return formData;
    }
    const { toFormData: toFormData2 } = await Promise.resolve().then(() => (init_multipart_parser(), exports_multipart_parser));
    return toFormData2(this.body, ct);
  }
  async blob() {
    const ct = this.headers && this.headers.get("content-type") || this[INTERNALS].body && this[INTERNALS].body.type || "";
    const buf = await this.arrayBuffer();
    return new fetch_blob_default([buf], {
      type: ct
    });
  }
  async json() {
    const text = await this.text();
    return JSON.parse(text);
  }
  async text() {
    const buffer = await consumeBody(this);
    return new TextDecoder().decode(buffer);
  }
  buffer() {
    return consumeBody(this);
  }
}
Body.prototype.buffer = deprecate(Body.prototype.buffer, "Please use 'response.arrayBuffer()' instead of 'response.buffer()'", "node-fetch#buffer");
Object.defineProperties(Body.prototype, {
  body: { enumerable: true },
  bodyUsed: { enumerable: true },
  arrayBuffer: { enumerable: true },
  blob: { enumerable: true },
  json: { enumerable: true },
  text: { enumerable: true },
  data: { get: deprecate(() => {}, "data doesn't exist, use json(), text(), arrayBuffer(), or body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (response)") }
});
async function consumeBody(data) {
  if (data[INTERNALS].disturbed) {
    throw new TypeError(`body used already for: ${data.url}`);
  }
  data[INTERNALS].disturbed = true;
  if (data[INTERNALS].error) {
    throw data[INTERNALS].error;
  }
  const { body } = data;
  if (body === null) {
    return Buffer2.alloc(0);
  }
  if (!(body instanceof Stream)) {
    return Buffer2.alloc(0);
  }
  const accum = [];
  let accumBytes = 0;
  try {
    for await (const chunk of body) {
      if (data.size > 0 && accumBytes + chunk.length > data.size) {
        const error3 = new FetchError(`content size at ${data.url} over limit: ${data.size}`, "max-size");
        body.destroy(error3);
        throw error3;
      }
      accumBytes += chunk.length;
      accum.push(chunk);
    }
  } catch (error3) {
    const error_ = error3 instanceof FetchBaseError ? error3 : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error3.message}`, "system", error3);
    throw error_;
  }
  if (body.readableEnded === true || body._readableState.ended === true) {
    try {
      if (accum.every((c) => typeof c === "string")) {
        return Buffer2.from(accum.join(""));
      }
      return Buffer2.concat(accum, accumBytes);
    } catch (error3) {
      throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error3.message}`, "system", error3);
    }
  } else {
    throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  }
}
var clone4 = (instance, highWaterMark) => {
  let p1;
  let p2;
  let { body } = instance[INTERNALS];
  if (instance.bodyUsed) {
    throw new Error("cannot clone body after it is used");
  }
  if (body instanceof Stream && typeof body.getBoundary !== "function") {
    p1 = new PassThrough({ highWaterMark });
    p2 = new PassThrough({ highWaterMark });
    body.pipe(p1);
    body.pipe(p2);
    instance[INTERNALS].stream = p1;
    body = p2;
  }
  return body;
};
var getNonSpecFormDataBoundary = deprecate((body) => body.getBoundary(), "form-data doesn't follow the spec and requires special treatment. Use alternative package", "https://github.com/node-fetch/node-fetch/issues/1167");
var extractContentType = (body, request) => {
  if (body === null) {
    return null;
  }
  if (typeof body === "string") {
    return "text/plain;charset=UTF-8";
  }
  if (isURLSearchParameters(body)) {
    return "application/x-www-form-urlencoded;charset=UTF-8";
  }
  if (isBlob(body)) {
    return body.type || null;
  }
  if (Buffer2.isBuffer(body) || types2.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
    return null;
  }
  if (body instanceof FormData) {
    return `multipart/form-data; boundary=${request[INTERNALS].boundary}`;
  }
  if (body && typeof body.getBoundary === "function") {
    return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  }
  if (body instanceof Stream) {
    return null;
  }
  return "text/plain;charset=UTF-8";
};
var getTotalBytes = (request) => {
  const { body } = request[INTERNALS];
  if (body === null) {
    return 0;
  }
  if (isBlob(body)) {
    return body.size;
  }
  if (Buffer2.isBuffer(body)) {
    return body.length;
  }
  if (body && typeof body.getLengthSync === "function") {
    return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  }
  return null;
};
var writeToStream = async (dest, { body }) => {
  if (body === null) {
    dest.end();
  } else {
    await pipeline(body, dest);
  }
};

// node_modules/node-fetch/src/headers.js
import { types as types3 } from "node:util";
import http from "node:http";
var validateHeaderName = typeof http.validateHeaderName === "function" ? http.validateHeaderName : (name) => {
  if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
    const error3 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
    Object.defineProperty(error3, "code", { value: "ERR_INVALID_HTTP_TOKEN" });
    throw error3;
  }
};
var validateHeaderValue = typeof http.validateHeaderValue === "function" ? http.validateHeaderValue : (name, value2) => {
  if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value2)) {
    const error3 = new TypeError(`Invalid character in header content ["${name}"]`);
    Object.defineProperty(error3, "code", { value: "ERR_INVALID_CHAR" });
    throw error3;
  }
};

class Headers2 extends URLSearchParams {
  constructor(init) {
    let result = [];
    if (init instanceof Headers2) {
      const raw = init.raw();
      for (const [name, values] of Object.entries(raw)) {
        result.push(...values.map((value2) => [name, value2]));
      }
    } else if (init == null) {} else if (typeof init === "object" && !types3.isBoxedPrimitive(init)) {
      const method = init[Symbol.iterator];
      if (method == null) {
        result.push(...Object.entries(init));
      } else {
        if (typeof method !== "function") {
          throw new TypeError("Header pairs must be iterable");
        }
        result = [...init].map((pair) => {
          if (typeof pair !== "object" || types3.isBoxedPrimitive(pair)) {
            throw new TypeError("Each header pair must be an iterable object");
          }
          return [...pair];
        }).map((pair) => {
          if (pair.length !== 2) {
            throw new TypeError("Each header pair must be a name/value tuple");
          }
          return [...pair];
        });
      }
    } else {
      throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");
    }
    result = result.length > 0 ? result.map(([name, value2]) => {
      validateHeaderName(name);
      validateHeaderValue(name, String(value2));
      return [String(name).toLowerCase(), String(value2)];
    }) : undefined;
    super(result);
    return new Proxy(this, {
      get(target, p, receiver) {
        switch (p) {
          case "append":
          case "set":
            return (name, value2) => {
              validateHeaderName(name);
              validateHeaderValue(name, String(value2));
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase(), String(value2));
            };
          case "delete":
          case "has":
          case "getAll":
            return (name) => {
              validateHeaderName(name);
              return URLSearchParams.prototype[p].call(target, String(name).toLowerCase());
            };
          case "keys":
            return () => {
              target.sort();
              return new Set(URLSearchParams.prototype.keys.call(target)).keys();
            };
          default:
            return Reflect.get(target, p, receiver);
        }
      }
    });
  }
  get [Symbol.toStringTag]() {
    return this.constructor.name;
  }
  toString() {
    return Object.prototype.toString.call(this);
  }
  get(name) {
    const values = this.getAll(name);
    if (values.length === 0) {
      return null;
    }
    let value2 = values.join(", ");
    if (/^content-encoding$/i.test(name)) {
      value2 = value2.toLowerCase();
    }
    return value2;
  }
  forEach(callback, thisArg = undefined) {
    for (const name of this.keys()) {
      Reflect.apply(callback, thisArg, [this.get(name), name, this]);
    }
  }
  *values() {
    for (const name of this.keys()) {
      yield this.get(name);
    }
  }
  *entries() {
    for (const name of this.keys()) {
      yield [name, this.get(name)];
    }
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  raw() {
    return [...this.keys()].reduce((result, key) => {
      result[key] = this.getAll(key);
      return result;
    }, {});
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return [...this.keys()].reduce((result, key) => {
      const values = this.getAll(key);
      if (key === "host") {
        result[key] = values[0];
      } else {
        result[key] = values.length > 1 ? values : values[0];
      }
      return result;
    }, {});
  }
}
Object.defineProperties(Headers2.prototype, ["get", "entries", "forEach", "values"].reduce((result, property) => {
  result[property] = { enumerable: true };
  return result;
}, {}));
function fromRawHeaders(headers = []) {
  return new Headers2(headers.reduce((result, value2, index, array3) => {
    if (index % 2 === 0) {
      result.push(array3.slice(index, index + 2));
    }
    return result;
  }, []).filter(([name, value2]) => {
    try {
      validateHeaderName(name);
      validateHeaderValue(name, String(value2));
      return true;
    } catch {
      return false;
    }
  }));
}

// node_modules/node-fetch/src/utils/is-redirect.js
var redirectStatus = new Set([301, 302, 303, 307, 308]);
var isRedirect = (code) => {
  return redirectStatus.has(code);
};

// node_modules/node-fetch/src/response.js
var INTERNALS2 = Symbol("Response internals");

class Response2 extends Body {
  constructor(body = null, options = {}) {
    super(body, options);
    const status = options.status != null ? options.status : 200;
    const headers = new Headers2(options.headers);
    if (body !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(body, this);
      if (contentType) {
        headers.append("Content-Type", contentType);
      }
    }
    this[INTERNALS2] = {
      type: "default",
      url: options.url,
      status,
      statusText: options.statusText || "",
      headers,
      counter: options.counter,
      highWaterMark: options.highWaterMark
    };
  }
  get type() {
    return this[INTERNALS2].type;
  }
  get url() {
    return this[INTERNALS2].url || "";
  }
  get status() {
    return this[INTERNALS2].status;
  }
  get ok() {
    return this[INTERNALS2].status >= 200 && this[INTERNALS2].status < 300;
  }
  get redirected() {
    return this[INTERNALS2].counter > 0;
  }
  get statusText() {
    return this[INTERNALS2].statusText;
  }
  get headers() {
    return this[INTERNALS2].headers;
  }
  get highWaterMark() {
    return this[INTERNALS2].highWaterMark;
  }
  clone() {
    return new Response2(clone4(this, this.highWaterMark), {
      type: this.type,
      url: this.url,
      status: this.status,
      statusText: this.statusText,
      headers: this.headers,
      ok: this.ok,
      redirected: this.redirected,
      size: this.size,
      highWaterMark: this.highWaterMark
    });
  }
  static redirect(url, status = 302) {
    if (!isRedirect(status)) {
      throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
    }
    return new Response2(null, {
      headers: {
        location: new URL(url).toString()
      },
      status
    });
  }
  static error() {
    const response = new Response2(null, { status: 0, statusText: "" });
    response[INTERNALS2].type = "error";
    return response;
  }
  static json(data = undefined, init = {}) {
    const body = JSON.stringify(data);
    if (body === undefined) {
      throw new TypeError("data is not JSON serializable");
    }
    const headers = new Headers2(init && init.headers);
    if (!headers.has("content-type")) {
      headers.set("content-type", "application/json");
    }
    return new Response2(body, {
      ...init,
      headers
    });
  }
  get [Symbol.toStringTag]() {
    return "Response";
  }
}
Object.defineProperties(Response2.prototype, {
  type: { enumerable: true },
  url: { enumerable: true },
  status: { enumerable: true },
  ok: { enumerable: true },
  redirected: { enumerable: true },
  statusText: { enumerable: true },
  headers: { enumerable: true },
  clone: { enumerable: true }
});

// node_modules/node-fetch/src/request.js
import { format as formatUrl } from "node:url";
import { deprecate as deprecate2 } from "node:util";

// node_modules/node-fetch/src/utils/get-search.js
var getSearch = (parsedURL) => {
  if (parsedURL.search) {
    return parsedURL.search;
  }
  const lastOffset = parsedURL.href.length - 1;
  const hash3 = parsedURL.hash || (parsedURL.href[lastOffset] === "#" ? "#" : "");
  return parsedURL.href[lastOffset - hash3.length] === "?" ? "?" : "";
};

// node_modules/node-fetch/src/utils/referrer.js
import { isIP } from "node:net";
function stripURLForUseAsAReferrer(url, originOnly = false) {
  if (url == null) {
    return "no-referrer";
  }
  url = new URL(url);
  if (/^(about|blob|data):$/.test(url.protocol)) {
    return "no-referrer";
  }
  url.username = "";
  url.password = "";
  url.hash = "";
  if (originOnly) {
    url.pathname = "";
    url.search = "";
  }
  return url;
}
var ReferrerPolicy = new Set([
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
]);
var DEFAULT_REFERRER_POLICY = "strict-origin-when-cross-origin";
function validateReferrerPolicy(referrerPolicy) {
  if (!ReferrerPolicy.has(referrerPolicy)) {
    throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  }
  return referrerPolicy;
}
function isOriginPotentiallyTrustworthy(url) {
  if (/^(http|ws)s:$/.test(url.protocol)) {
    return true;
  }
  const hostIp = url.host.replace(/(^\[)|(]$)/g, "");
  const hostIPVersion = isIP(hostIp);
  if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
    return true;
  }
  if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
    return true;
  }
  if (url.host === "localhost" || url.host.endsWith(".localhost")) {
    return false;
  }
  if (url.protocol === "file:") {
    return true;
  }
  return false;
}
function isUrlPotentiallyTrustworthy(url) {
  if (/^about:(blank|srcdoc)$/.test(url)) {
    return true;
  }
  if (url.protocol === "data:") {
    return true;
  }
  if (/^(blob|filesystem):$/.test(url.protocol)) {
    return true;
  }
  return isOriginPotentiallyTrustworthy(url);
}
function determineRequestsReferrer(request, { referrerURLCallback, referrerOriginCallback } = {}) {
  if (request.referrer === "no-referrer" || request.referrerPolicy === "") {
    return null;
  }
  const policy2 = request.referrerPolicy;
  if (request.referrer === "about:client") {
    return "no-referrer";
  }
  const referrerSource = request.referrer;
  let referrerURL = stripURLForUseAsAReferrer(referrerSource);
  let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);
  if (referrerURL.toString().length > 4096) {
    referrerURL = referrerOrigin;
  }
  if (referrerURLCallback) {
    referrerURL = referrerURLCallback(referrerURL);
  }
  if (referrerOriginCallback) {
    referrerOrigin = referrerOriginCallback(referrerOrigin);
  }
  const currentURL = new URL(request.url);
  switch (policy2) {
    case "no-referrer":
      return "no-referrer";
    case "origin":
      return referrerOrigin;
    case "unsafe-url":
      return referrerURL;
    case "strict-origin":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin.toString();
    case "strict-origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerOrigin;
    case "same-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return "no-referrer";
    case "origin-when-cross-origin":
      if (referrerURL.origin === currentURL.origin) {
        return referrerURL;
      }
      return referrerOrigin;
    case "no-referrer-when-downgrade":
      if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
        return "no-referrer";
      }
      return referrerURL;
    default:
      throw new TypeError(`Invalid referrerPolicy: ${policy2}`);
  }
}
function parseReferrerPolicyFromHeader(headers) {
  const policyTokens = (headers.get("referrer-policy") || "").split(/[,\s]+/);
  let policy2 = "";
  for (const token of policyTokens) {
    if (token && ReferrerPolicy.has(token)) {
      policy2 = token;
    }
  }
  return policy2;
}

// node_modules/node-fetch/src/request.js
var INTERNALS3 = Symbol("Request internals");
var isRequest = (object3) => {
  return typeof object3 === "object" && typeof object3[INTERNALS3] === "object";
};
var doBadDataWarn = deprecate2(() => {}, ".data is not a valid RequestInit property, use .body instead", "https://github.com/node-fetch/node-fetch/issues/1000 (request)");

class Request2 extends Body {
  constructor(input, init = {}) {
    let parsedURL;
    if (isRequest(input)) {
      parsedURL = new URL(input.url);
    } else {
      parsedURL = new URL(input);
      input = {};
    }
    if (parsedURL.username !== "" || parsedURL.password !== "") {
      throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
    }
    let method = init.method || input.method || "GET";
    if (/^(delete|get|head|options|post|put)$/i.test(method)) {
      method = method.toUpperCase();
    }
    if (!isRequest(init) && "data" in init) {
      doBadDataWarn();
    }
    if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
      throw new TypeError("Request with GET/HEAD method cannot have body");
    }
    const inputBody = init.body ? init.body : isRequest(input) && input.body !== null ? clone4(input) : null;
    super(inputBody, {
      size: init.size || input.size || 0
    });
    const headers = new Headers2(init.headers || input.headers || {});
    if (inputBody !== null && !headers.has("Content-Type")) {
      const contentType = extractContentType(inputBody, this);
      if (contentType) {
        headers.set("Content-Type", contentType);
      }
    }
    let signal = isRequest(input) ? input.signal : null;
    if ("signal" in init) {
      signal = init.signal;
    }
    if (signal != null && !isAbortSignal(signal)) {
      throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");
    }
    let referrer = init.referrer == null ? input.referrer : init.referrer;
    if (referrer === "") {
      referrer = "no-referrer";
    } else if (referrer) {
      const parsedReferrer = new URL(referrer);
      referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? "client" : parsedReferrer;
    } else {
      referrer = undefined;
    }
    this[INTERNALS3] = {
      method,
      redirect: init.redirect || input.redirect || "follow",
      headers,
      parsedURL,
      signal,
      referrer
    };
    this.follow = init.follow === undefined ? input.follow === undefined ? 20 : input.follow : init.follow;
    this.compress = init.compress === undefined ? input.compress === undefined ? true : input.compress : init.compress;
    this.counter = init.counter || input.counter || 0;
    this.agent = init.agent || input.agent;
    this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
    this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;
    this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || "";
  }
  get method() {
    return this[INTERNALS3].method;
  }
  get url() {
    return formatUrl(this[INTERNALS3].parsedURL);
  }
  get headers() {
    return this[INTERNALS3].headers;
  }
  get redirect() {
    return this[INTERNALS3].redirect;
  }
  get signal() {
    return this[INTERNALS3].signal;
  }
  get referrer() {
    if (this[INTERNALS3].referrer === "no-referrer") {
      return "";
    }
    if (this[INTERNALS3].referrer === "client") {
      return "about:client";
    }
    if (this[INTERNALS3].referrer) {
      return this[INTERNALS3].referrer.toString();
    }
    return;
  }
  get referrerPolicy() {
    return this[INTERNALS3].referrerPolicy;
  }
  set referrerPolicy(referrerPolicy) {
    this[INTERNALS3].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  }
  clone() {
    return new Request2(this);
  }
  get [Symbol.toStringTag]() {
    return "Request";
  }
}
Object.defineProperties(Request2.prototype, {
  method: { enumerable: true },
  url: { enumerable: true },
  headers: { enumerable: true },
  redirect: { enumerable: true },
  clone: { enumerable: true },
  signal: { enumerable: true },
  referrer: { enumerable: true },
  referrerPolicy: { enumerable: true }
});
var getNodeRequestOptions = (request) => {
  const { parsedURL } = request[INTERNALS3];
  const headers = new Headers2(request[INTERNALS3].headers);
  if (!headers.has("Accept")) {
    headers.set("Accept", "*/*");
  }
  let contentLengthValue = null;
  if (request.body === null && /^(post|put)$/i.test(request.method)) {
    contentLengthValue = "0";
  }
  if (request.body !== null) {
    const totalBytes = getTotalBytes(request);
    if (typeof totalBytes === "number" && !Number.isNaN(totalBytes)) {
      contentLengthValue = String(totalBytes);
    }
  }
  if (contentLengthValue) {
    headers.set("Content-Length", contentLengthValue);
  }
  if (request.referrerPolicy === "") {
    request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  }
  if (request.referrer && request.referrer !== "no-referrer") {
    request[INTERNALS3].referrer = determineRequestsReferrer(request);
  } else {
    request[INTERNALS3].referrer = "no-referrer";
  }
  if (request[INTERNALS3].referrer instanceof URL) {
    headers.set("Referer", request.referrer);
  }
  if (!headers.has("User-Agent")) {
    headers.set("User-Agent", "node-fetch");
  }
  if (request.compress && !headers.has("Accept-Encoding")) {
    headers.set("Accept-Encoding", "gzip, deflate, br");
  }
  let { agent } = request;
  if (typeof agent === "function") {
    agent = agent(parsedURL);
  }
  const search = getSearch(parsedURL);
  const options = {
    path: parsedURL.pathname + search,
    method: request.method,
    headers: headers[Symbol.for("nodejs.util.inspect.custom")](),
    insecureHTTPParser: request.insecureHTTPParser,
    agent
  };
  return {
    parsedURL,
    options
  };
};

// node_modules/node-fetch/src/errors/abort-error.js
class AbortError extends FetchBaseError {
  constructor(message, type3 = "aborted") {
    super(message, type3);
  }
}

// node_modules/node-fetch/src/index.js
init_esm_min();
init_from();
var supportedSchemas = new Set(["data:", "http:", "https:"]);
async function fetch(url, options_) {
  return new Promise((resolve, reject) => {
    const request = new Request2(url, options_);
    const { parsedURL, options } = getNodeRequestOptions(request);
    if (!supportedSchemas.has(parsedURL.protocol)) {
      throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, "")}" is not supported.`);
    }
    if (parsedURL.protocol === "data:") {
      const data = dist_default(request.url);
      const response2 = new Response2(data, { headers: { "Content-Type": data.typeFull } });
      resolve(response2);
      return;
    }
    const send = (parsedURL.protocol === "https:" ? https : http2).request;
    const { signal } = request;
    let response = null;
    const abort = () => {
      const error3 = new AbortError("The operation was aborted.");
      reject(error3);
      if (request.body && request.body instanceof Stream2.Readable) {
        request.body.destroy(error3);
      }
      if (!response || !response.body) {
        return;
      }
      response.body.emit("error", error3);
    };
    if (signal && signal.aborted) {
      abort();
      return;
    }
    const abortAndFinalize = () => {
      abort();
      finalize();
    };
    const request_ = send(parsedURL.toString(), options);
    if (signal) {
      signal.addEventListener("abort", abortAndFinalize);
    }
    const finalize = () => {
      request_.abort();
      if (signal) {
        signal.removeEventListener("abort", abortAndFinalize);
      }
    };
    request_.on("error", (error3) => {
      reject(new FetchError(`request to ${request.url} failed, reason: ${error3.message}`, "system", error3));
      finalize();
    });
    fixResponseChunkedTransferBadEnding(request_, (error3) => {
      if (response && response.body) {
        response.body.destroy(error3);
      }
    });
    if (process.version < "v14") {
      request_.on("socket", (s2) => {
        let endedWithEventsCount;
        s2.prependListener("end", () => {
          endedWithEventsCount = s2._eventsCount;
        });
        s2.prependListener("close", (hadError) => {
          if (response && endedWithEventsCount < s2._eventsCount && !hadError) {
            const error3 = new Error("Premature close");
            error3.code = "ERR_STREAM_PREMATURE_CLOSE";
            response.body.emit("error", error3);
          }
        });
      });
    }
    request_.on("response", (response_) => {
      request_.setTimeout(0);
      const headers = fromRawHeaders(response_.rawHeaders);
      if (isRedirect(response_.statusCode)) {
        const location = headers.get("Location");
        let locationURL = null;
        try {
          locationURL = location === null ? null : new URL(location, request.url);
        } catch {
          if (request.redirect !== "manual") {
            reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
            finalize();
            return;
          }
        }
        switch (request.redirect) {
          case "error":
            reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
            finalize();
            return;
          case "manual":
            break;
          case "follow": {
            if (locationURL === null) {
              break;
            }
            if (request.counter >= request.follow) {
              reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
              finalize();
              return;
            }
            const requestOptions = {
              headers: new Headers2(request.headers),
              follow: request.follow,
              counter: request.counter + 1,
              agent: request.agent,
              compress: request.compress,
              method: request.method,
              body: clone4(request),
              signal: request.signal,
              size: request.size,
              referrer: request.referrer,
              referrerPolicy: request.referrerPolicy
            };
            if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
              for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                requestOptions.headers.delete(name);
              }
            }
            if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream2.Readable) {
              reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
              finalize();
              return;
            }
            if (response_.statusCode === 303 || (response_.statusCode === 301 || response_.statusCode === 302) && request.method === "POST") {
              requestOptions.method = "GET";
              requestOptions.body = undefined;
              requestOptions.headers.delete("content-length");
            }
            const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
            if (responseReferrerPolicy) {
              requestOptions.referrerPolicy = responseReferrerPolicy;
            }
            resolve(fetch(new Request2(locationURL, requestOptions)));
            finalize();
            return;
          }
          default:
            return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
        }
      }
      if (signal) {
        response_.once("end", () => {
          signal.removeEventListener("abort", abortAndFinalize);
        });
      }
      let body = pump(response_, new PassThrough2, (error3) => {
        if (error3) {
          reject(error3);
        }
      });
      if (process.version < "v12.10") {
        response_.on("aborted", abortAndFinalize);
      }
      const responseOptions = {
        url: request.url,
        status: response_.statusCode,
        statusText: response_.statusMessage,
        headers,
        size: request.size,
        counter: request.counter,
        highWaterMark: request.highWaterMark
      };
      const codings = headers.get("Content-Encoding");
      if (!request.compress || request.method === "HEAD" || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
        response = new Response2(body, responseOptions);
        resolve(response);
        return;
      }
      const zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };
      if (codings === "gzip" || codings === "x-gzip") {
        body = pump(body, zlib.createGunzip(zlibOptions), (error3) => {
          if (error3) {
            reject(error3);
          }
        });
        response = new Response2(body, responseOptions);
        resolve(response);
        return;
      }
      if (codings === "deflate" || codings === "x-deflate") {
        const raw = pump(response_, new PassThrough2, (error3) => {
          if (error3) {
            reject(error3);
          }
        });
        raw.once("data", (chunk) => {
          if ((chunk[0] & 15) === 8) {
            body = pump(body, zlib.createInflate(), (error3) => {
              if (error3) {
                reject(error3);
              }
            });
          } else {
            body = pump(body, zlib.createInflateRaw(), (error3) => {
              if (error3) {
                reject(error3);
              }
            });
          }
          response = new Response2(body, responseOptions);
          resolve(response);
        });
        raw.once("end", () => {
          if (!response) {
            response = new Response2(body, responseOptions);
            resolve(response);
          }
        });
        return;
      }
      if (codings === "br") {
        body = pump(body, zlib.createBrotliDecompress(), (error3) => {
          if (error3) {
            reject(error3);
          }
        });
        response = new Response2(body, responseOptions);
        resolve(response);
        return;
      }
      response = new Response2(body, responseOptions);
      resolve(response);
    });
    writeToStream(request_, request).catch(reject);
  });
}
function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  const LAST_CHUNK = Buffer3.from(`0\r
\r
`);
  let isChunkedTransfer = false;
  let properLastChunkReceived = false;
  let previousChunk;
  request.on("response", (response) => {
    const { headers } = response;
    isChunkedTransfer = headers["transfer-encoding"] === "chunked" && !headers["content-length"];
  });
  request.on("socket", (socket) => {
    const onSocketClose = () => {
      if (isChunkedTransfer && !properLastChunkReceived) {
        const error3 = new Error("Premature close");
        error3.code = "ERR_STREAM_PREMATURE_CLOSE";
        errorCallback(error3);
      }
    };
    const onData = (buf) => {
      properLastChunkReceived = Buffer3.compare(buf.slice(-5), LAST_CHUNK) === 0;
      if (!properLastChunkReceived && previousChunk) {
        properLastChunkReceived = Buffer3.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 && Buffer3.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0;
      }
      previousChunk = buf;
    };
    socket.prependListener("close", onSocketClose);
    socket.on("data", onData);
    request.on("close", () => {
      socket.removeListener("close", onSocketClose);
      socket.removeListener("data", onData);
    });
  });
}

// src/banks/baneco.api.ts
class BanecoApi {
  apiBaseUrl;
  aesKey;
  constructor(apiBaseUrl, aesKey) {
    this.apiBaseUrl = apiBaseUrl.endsWith("/") ? apiBaseUrl : `${apiBaseUrl}/`;
    this.aesKey = aesKey;
  }
  async encryptText(text, aesKey) {
    const key = aesKey || this.aesKey;
    const url = `${this.apiBaseUrl}api/authentication/encrypt?text=${encodeURIComponent(text)}&aesKey=${key}`;
    try {
      const res = await fetch(url);
      if (!res.ok) {
        throw new Error(`Error al encriptar texto: ${await res.text() || "Error desconocido"}`);
      }
      const data = await res.json();
      console.log(data);
      return data;
    } catch (error3) {
      console.error("Error en encriptación Baneco:", error3);
      throw error3;
    }
  }
  async getToken(username, passwordPlain) {
    try {
      const encryptedPassword = "zJDKXV7e4eGwVsMaoko3X26URZsqOnS8+GrN7IpMACo=";
      const url = `${this.apiBaseUrl}api/authentication/authenticate`;
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ userName: username, password: encryptedPassword })
      });
      const data = await res.json();
      if (data.responseCode !== 0) {
        throw new Error(`Error de autenticación: ${data.message}`);
      }
      return data.token;
    } catch (error3) {
      console.error("Error obteniendo token Baneco:", error3);
      throw error3;
    }
  }
  async generateQr(token, transactionId, accountNumber, amount, options = {}) {
    try {
      const encryptedAccount = "BOKX0peo3gNrcyilUO5PhycenJ8Q9enImYSXtJL0ukg=";
      const payload = {
        transactionId,
        accountCredit: encryptedAccount,
        currency: options.currency || "BOB",
        amount,
        description: options.description || "Pago QR",
        dueDate: options.dueDate || "2025-12-31",
        singleUse: options.singleUse !== undefined ? options.singleUse : true,
        modifyAmount: options.modifyAmount !== undefined ? options.modifyAmount : false,
        branchCode: options.branchCode || "E0001"
      };
      const res = await fetch(`${this.apiBaseUrl}api/qrsimple/generateQR`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify(payload)
      });
      if (!res.ok) {
        throw new Error(`Error generando QR: ${await res.text() || "Error desconocido"}`);
      }
      const data = await res.json();
      if (data.responseCode !== 0) {
        throw new Error(`Error generando QR: ${data.message}`);
      }
      return data;
    } catch (error3) {
      console.error("Error generando QR Baneco:", error3);
      throw error3;
    }
  }
  async cancelQr(token, qrId) {
    try {
      const res = await fetch(`${this.apiBaseUrl}api/qrsimple/cancelQR`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`
        },
        body: JSON.stringify({ qrId })
      });
      if (!res.ok) {
        throw new Error(`Error cancelando QR: ${await res.text() || "Error desconocido"}`);
      }
      const data = await res.json();
      if (data.responseCode !== 0) {
        throw new Error(`Error cancelando QR: ${data.message}`);
      }
      return data;
    } catch (error3) {
      console.error("Error cancelando QR Baneco:", error3);
      throw error3;
    }
  }
  async getQrStatus(token, qrId) {
    try {
      const res = await fetch(`${this.apiBaseUrl}api/qrsimple/v2/statusQR/${qrId}`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`
        }
      });
      if (!res.ok) {
        throw new Error(`Error consultando estado QR: ${await res.text() || "Error desconocido"}`);
      }
      const data = await res.json();
      if (data.responseCode !== 0) {
        throw new Error(`Error consultando estado QR: ${data.message}`);
      }
      return data;
    } catch (error3) {
      console.error("Error consultando estado QR Baneco:", error3);
      throw error3;
    }
  }
  async getPaidQrsByDate(token, dateStr) {
    try {
      const res = await fetch(`${this.apiBaseUrl}api/qrsimple/v2/paidQR/${dateStr}`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${token}`
        }
      });
      const data = await res.json();
      if (!res.ok) {
        throw new Error(`Error consultando QRs pagados: ${await res.text() || "Error desconocido"}`);
      }
      if (data.responseCode !== 0) {
        throw new Error(`Error consultando QRs pagados: ${data.message}`);
      }
      return data.paymentList || [];
    } catch (error3) {
      console.error("Error consultando QRs pagados Baneco:", error3);
      throw error3;
    }
  }
}
var baneco_api_default = BanecoApi;

// src/services/qr.service.ts
var BANCO_ECONOMICO_CODE = "1016";
var BANCO_BNB_CODE = "1020";
var BANCO_VISA_CODE = "1025";

class QrService {
  cryptoService;
  constructor() {
    this.cryptoService = new CryptoService(process.env.CRYPTO_KEY || "default-encryption-key");
  }
  async getBankConfig(companyId, bankCode) {
    try {
      const configQuery = await query(`
        SELECT 
          cbc.account_number as "accountNumber", 
          cbc.encryption_key as "encryptionKey",
          cbc.account_username as "accountUsername",
          cbc.account_password as "accountPassword",
          cbc.merchant_id as "merchantId",
          cbc.environment as "environment",
          b.test_api_url as "testApiUrl",
          b.prod_api_url as "prodApiUrl",
          b.encryption_key as "bankEncryptionKey"
        FROM company_bank_configs cbc
        JOIN banks b ON cbc.bank_id = b.id
        WHERE cbc.company_id = $1 
          AND b.code = $2 
          AND cbc.status = 'ACTIVE'
          AND b.status = 'ACTIVE'
          AND cbc.deleted_at IS NULL
          AND b.deleted_at IS NULL
      `, [companyId, bankCode]);
      if (configQuery.rowCount === 0) {
        throw new Error("No existe configuración activa de Banco Económico para esta empresa");
      }
      const config = configQuery.rows[0];
      const accountNumber = config.accountNumber;
      const username = config.accountUsername;
      const password = config.accountPassword;
      const merchantId = config.merchantId;
      const aesKey = config.encryptionKey || config.bankEncryptionKey || "6F09E3167E1D40829207B01041A65B12";
      const apiBaseUrl = config.environment === 2 ? config.testApiUrl : config.prodApiUrl;
      if (!username || !password) {
        throw new Error("Credenciales de Banco Económico no configuradas");
      }
      return {
        username,
        password,
        accountNumber,
        apiBaseUrl,
        aesKey,
        merchantId
      };
    } catch (error3) {
      console.error("Error obteniendo configuración Baneco:", error3);
      throw error3;
    }
  }
  async generateQR(companyId, qrData, userId, bankId) {
    console.log({ companyId, bankId, qrData, userId });
    try {
      const currency = "BOB";
      const branchCode = "E0001";
      const configCheck = await query(`
        SELECT 
          cbc.account_number as "accountNumber", 
          cbc.encryption_key as "aesKey"  ,
          b.test_api_url as "testApiUrl", 
          b.prod_api_url as "prodApiUrl",
          b.code as "bankCode",
          b.name as "bankName",
          c.name as "companyName"
        FROM company_bank_configs cbc
        JOIN banks b ON cbc.bank_id = b.id
        JOIN companies c ON cbc.company_id = c.id
        WHERE cbc.company_id = $1
          AND ($2::INTEGER IS NULL OR cbc.bank_id = $2::INTEGER)
          AND cbc.status = 'ACTIVE'
          AND cbc.deleted_at IS NULL
          AND b.deleted_at IS NULL
      `, [companyId, bankId ?? null]);
      if (configCheck.rowCount === 0) {
        await logActivity("QR_GENERATE_ERROR", {
          companyId,
          bankId,
          error: "No bank configuration found"
        }, "ERROR", companyId, userId);
        return {
          responseCode: 1,
          message: "No existe configuración activa del banco seleccionado para esta empresa"
        };
      }
      const bankConfig = configCheck.rows[0];
      console.log({ bankCode: bankConfig.bankCode, BANCO_ECONOMICO_CODE });
      if (bankConfig.bankCode === BANCO_ECONOMICO_CODE) {
        try {
          const config = await this.getBankConfig(companyId, bankConfig.bankCode);
          const banecoApi = new baneco_api_default(config.apiBaseUrl, config.aesKey);
          const token = await banecoApi.getToken(config.username, config.password);
          const qrResult = await banecoApi.generateQr(token, qrData.transactionId, config.accountNumber, qrData.amount, {
            description: qrData.description,
            dueDate: qrData.dueDate,
            singleUse: qrData.singleUse,
            modifyAmount: qrData.modifyAmount,
            branchCode,
            currency
          });
          await query(`
            INSERT INTO qr_codes (
              qr_id,
              transaction_id,
              account_credit,
              company_id,
              bank_id,
              currency,
              amount,
              description,
              due_date,
              single_use,
              modify_amount,
              branch_code,
              qr_image,
              status
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
          `, [
            qrResult.qrId,
            qrData.transactionId,
            crypto_service_default.encrypt(config.accountNumber),
            companyId,
            bankId,
            "BOB",
            qrData.amount,
            qrData.description || "Pago QR",
            qrData.dueDate ? new Date(qrData.dueDate) : new Date("2025-12-31"),
            qrData.singleUse !== undefined ? qrData.singleUse : true,
            qrData.modifyAmount !== undefined ? qrData.modifyAmount : false,
            branchCode,
            qrResult.qrImage,
            "ACTIVE"
          ]);
          await logActivity("QR_GENERATED", {
            qrId: qrResult.qrId,
            transactionId: qrData.transactionId,
            amount: qrData.amount,
            bankCode: BANCO_ECONOMICO_CODE
          }, "SUCCESS", companyId, userId);
          return {
            qrId: qrResult.qrId,
            qrImage: qrResult.qrImage,
            responseCode: 0,
            message: "QR generado exitosamente"
          };
        } catch (error3) {
          console.error("Error generando QR Baneco:", error3);
          await logActivity("QR_GENERATE_ERROR", {
            error: error3 instanceof Error ? error3.message : "Error desconocido",
            transactionId: qrData.transactionId
          }, "ERROR", companyId, userId);
          return {
            responseCode: 1,
            message: error3 instanceof Error ? error3.message : "Error generando QR"
          };
        }
      }
      if (bankConfig.bankCode === BANCO_BNB_CODE) {
        await logActivity("QR_GENERATE_ERROR", {
          companyId,
          bankId,
          bankName: bankConfig.bankName,
          error: "Banco BNB no implementado"
        }, "ERROR", companyId, userId);
        return {
          responseCode: 2,
          message: "Banco BNB no implementado. Por favor contacte al administrador."
        };
      }
      if (bankConfig.bankCode === BANCO_VISA_CODE) {
        await logActivity("QR_GENERATE_ERROR", {
          companyId,
          bankId,
          bankName: bankConfig.bankName,
          error: "Banco VISA no implementado"
        }, "ERROR", companyId, userId);
        return {
          responseCode: 2,
          message: "Banco VISA no implementado. Por favor contacte al administrador."
        };
      }
      if (typeof qrData.amount !== "number" || qrData.amount <= 0) {
        return {
          responseCode: 1,
          message: "El monto debe ser un número positivo"
        };
      }
      if (!qrData.dueDate || !/^\d{4}-\d{2}-\d{2}$/.test(qrData.dueDate)) {
        return {
          responseCode: 1,
          message: "La fecha de vencimiento debe tener formato YYYY-MM-DD"
        };
      }
      if (typeof qrData.singleUse !== "boolean") {
        return {
          responseCode: 1,
          message: "El campo singleUse debe ser un valor booleano"
        };
      }
      if (typeof qrData.modifyAmount !== "boolean") {
        return {
          responseCode: 1,
          message: "El campo modifyAmount debe ser un valor booleano"
        };
      }
      if (bankConfig.bankCode === BANCO_ECONOMICO_CODE) {
        const date3 = new Date;
        const qrId = `${date3.getFullYear().toString().substring(2)}${(date3.getMonth() + 1).toString().padStart(2, "0")}${date3.getDate().toString().padStart(2, "0")}${BANCO_ECONOMICO_CODE}${Math.floor(Math.random() * 1e9).toString().padStart(9, "0")}`;
        const qrContent = {
          id: qrId,
          transactionId: qrData.transactionId,
          accountCredit: bankConfig.accountNumber,
          currency,
          amount: qrData.amount,
          description: qrData.description || "",
          dueDate: qrData.dueDate,
          singleUse: qrData.singleUse,
          modifyAmount: qrData.modifyAmount,
          branchCode,
          bankCode: BANCO_ECONOMICO_CODE
        };
        const qrImage = await import_qrcode.default.toDataURL(JSON.stringify(qrContent));
        await query(`
          INSERT INTO qr_codes (
            qr_id,
            transaction_id,
            account_credit,
            company_id,
            bank_id,
            currency,
            amount,
            description,
            due_date,
            single_use,
            modify_amount,
            branch_code,
            qr_image,
            status
          ) 
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
        `, [
          qrId,
          qrData.transactionId,
          bankConfig.accountNumber,
          companyId,
          bankId,
          currency,
          qrData.amount,
          qrData.description || null,
          qrData.dueDate,
          qrData.singleUse,
          qrData.modifyAmount,
          branchCode,
          qrImage,
          "ACTIVE"
        ]);
        await logActivity("QR_GENERATED", {
          qrId,
          companyId,
          bankId,
          bankName: bankConfig.bankName,
          amount: qrData.amount,
          currency,
          dueDate: qrData.dueDate
        }, "SUCCESS", companyId, userId);
        return {
          qrId,
          qrImage,
          responseCode: 0,
          message: "Código QR generado exitosamente"
        };
      } else {
        await logActivity("QR_GENERATE_ERROR", {
          companyId,
          bankId,
          bankName: bankConfig.bankName,
          error: "Banco no implementado"
        }, "ERROR", companyId, userId);
        return {
          responseCode: 2,
          message: `Banco ${bankConfig.bankName} no implementado. Por favor contacte al administrador.`
        };
      }
    } catch (error3) {
      console.error("Error generando código QR:", error3);
      await logActivity("QR_GENERATE_ERROR", {
        companyId,
        bankId,
        error: error3 instanceof Error ? error3.message : "Unknown error"
      }, "ERROR", companyId, userId);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error generando código QR"
      };
    }
  }
  async cancelQR(companyId, qrId, userId) {
    try {
      const qrCheck = await query(`
        SELECT 
          qr.bank_id,
          qr.status,
          b.code as bank_code,
          b.name as bankName
        FROM qr_codes qr
        JOIN banks b ON qr.bank_id = b.id
        WHERE qr.qr_id = $1 AND qr.company_id = $2
        AND qr.deleted_at IS NULL
        AND b.deleted_at IS NULL
      `, [qrId, companyId]);
      if (qrCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "QR no encontrado o no pertenece a esta empresa"
        };
      }
      const qrData = qrCheck.rows[0];
      if (qrData.status !== "ACTIVE") {
        return {
          responseCode: 1,
          message: `No se puede cancelar el QR porque su estado actual es: ${qrData.status}`
        };
      }
      if (qrData.bank_code === BANCO_ECONOMICO_CODE) {
        try {
          const config = await this.getBankConfig(companyId, qrData.bank_code);
          const banecoApi = new baneco_api_default(config.apiBaseUrl, config.aesKey);
          const token = await banecoApi.getToken(config.username, config.password);
          await banecoApi.cancelQr(token, qrId);
          await query(`
            UPDATE qr_codes
            SET status = 'CANCELLED', updated_at = CURRENT_TIMESTAMP
            WHERE qr_id = $1 AND company_id = $2
          `, [qrId, companyId]);
          await logActivity("QR_CANCELLED", { qrId }, "SUCCESS", companyId, userId);
          return {
            responseCode: 0,
            message: "QR cancelado exitosamente"
          };
        } catch (error3) {
          console.error("Error cancelando QR Baneco:", error3);
          await logActivity("QR_CANCEL_ERROR", {
            qrId,
            error: error3 instanceof Error ? error3.message : "Error desconocido"
          }, "ERROR", companyId, userId);
          return {
            responseCode: 1,
            message: error3 instanceof Error ? error3.message : "Error cancelando QR"
          };
        }
      }
      if (qrData.status === "CANCELLED") {
        return {
          responseCode: 1,
          message: "El código QR ya ha sido anulado"
        };
      }
      if (qrData.status === "PAID" && qrData.single_use) {
        return {
          responseCode: 1,
          message: "No se puede anular un código QR de uso único que ya ha sido pagado"
        };
      }
      await query(`
        UPDATE qr_codes
        SET status = 'CANCELLED', updated_at = CURRENT_TIMESTAMP
        WHERE qr_id = $1
      `, [qrId]);
      await logActivity("QR_CANCELLED", {
        qrId,
        bankId: qrData.bankId,
        bankName: qrData.bankName
      }, "SUCCESS", companyId, userId);
      return {
        qrId,
        responseCode: 0,
        message: "Código QR anulado exitosamente"
      };
    } catch (error3) {
      console.error("Error anulando código QR:", error3);
      await logActivity("QR_CANCEL_ERROR", {
        qrId,
        error: error3 instanceof Error ? error3.message : "Unknown error"
      }, "ERROR", companyId, userId);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error anulando código QR"
      };
    }
  }
  async checkQRStatus(companyId, qrId, userId) {
    try {
      const qrCheck = await query(`
        SELECT 
          qr.bank_id,
          qr.status,
          b.code as bankCode,
          b.name as bankName
        FROM qr_codes qr
        JOIN banks b ON qr.bank_id = b.id
        WHERE qr.qr_id = $1 AND qr.company_id = $2
        AND qr.deleted_at IS NULL
        AND b.deleted_at IS NULL
      `, [qrId, companyId]);
      if (qrCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "QR no encontrado o no pertenece a esta empresa"
        };
      }
      const qrData = qrCheck.rows[0];
      if (qrData.bankCode === BANCO_ECONOMICO_CODE) {
        try {
          const config = await this.getBankConfig(companyId, qrData.bankCode);
          const banecoApi = new baneco_api_default(config.apiBaseUrl, config.aesKey);
          const token = await banecoApi.getToken(config.username, config.password);
          const statusResult = await banecoApi.getQrStatus(token, qrId);
          await logActivity("QR_STATUS_CHECK", {
            qrId,
            status: statusResult.statusQrCode
          }, "SUCCESS", companyId, userId);
          return {
            statusQRCode: statusResult.statusQrCode,
            payment: statusResult.payment || [],
            responseCode: 0,
            message: "Consulta de estado exitosa"
          };
        } catch (error3) {
          console.error("Error consultando estado QR Baneco:", error3);
          await logActivity("QR_STATUS_CHECK_ERROR", {
            qrId,
            error: error3 instanceof Error ? error3.message : "Error desconocido"
          }, "ERROR", companyId, userId);
          return {
            responseCode: 1,
            message: error3 instanceof Error ? error3.message : "Error consultando estado del QR"
          };
        }
      }
      let statusQRCode = 0;
      if (qrData.status === "PAID") {
        statusQRCode = 1;
      } else if (qrData.status === "CANCELLED") {
        statusQRCode = 9;
      } else if (qrData.status === "EXPIRED") {
        statusQRCode = 10;
      }
      let payments = [];
      if (statusQRCode === 1) {
        const paymentResult = await query(`
          SELECT
            qr_id,
            transaction_id,
            payment_date,
            payment_time,
            currency,
            amount,
            sender_bank_code,
            sender_name,
            sender_document_id,
            sender_account,
            description,
            branch_code
          FROM qr_payments
          WHERE qr_id = $1 AND company_id = $2
          ORDER BY payment_date DESC, payment_time DESC
        `, [qrId, companyId]);
        payments = paymentResult.rows.map((row) => ({
          qrId: row.qr_id,
          transactionId: row.transaction_id,
          paymentDate: row.payment_date,
          paymentTime: row.payment_time,
          currency: row.currency,
          amount: parseFloat(row.amount),
          senderBankCode: row.sender_bank_code,
          senderName: row.sender_name,
          senderDocumentId: row.sender_document_id,
          senderAccount: row.sender_account,
          description: row.description,
          branchCode: row.branch_code
        }));
      }
      await logActivity("QR_STATUS_CHECKED", {
        qrId,
        status: qrData.status,
        bankId: qrData.bankId,
        bankName: qrData.bankName
      }, "SUCCESS", companyId, userId);
      return {
        statusQRCode,
        payment: payments,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error verificando estado de código QR:", error3);
      await logActivity("QR_STATUS_ERROR", {
        qrId,
        error: error3 instanceof Error ? error3.message : "Unknown error"
      }, "ERROR", companyId, userId);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error verificando estado de código QR"
      };
    }
  }
  async getPaidQRs(companyId, date3, bankId, userId) {
    try {
      if (bankId) {
        const bankCheck = await query(`
          SELECT code as "bankCode"
          FROM banks
          WHERE id = $1 AND status = 'ACTIVE'
          AND deleted_at IS NULL
        `, [bankId]);
        if (bankCheck.rowCount === 0) {
          return {
            responseCode: 1,
            message: "Banco no encontrado o no está activo"
          };
        }
        const bankCode = bankCheck.rows[0].code;
        if (bankCode === BANCO_ECONOMICO_CODE) {
          try {
            const config = await this.getBankConfig(companyId, bankCode);
            const banecoApi = new baneco_api_default(config.apiBaseUrl, config.aesKey);
            const token = await banecoApi.getToken(config.username, config.password);
            const dateObj = new Date(date3.substring(0, 4) + "-" + date3.substring(4, 6) + "-" + date3.substring(6, 8));
            const formattedDate2 = import_date_fns.format(dateObj, "yyyyMMdd");
            const paidQRs = await banecoApi.getPaidQrsByDate(token, formattedDate2);
            await logActivity("QR_PAID_LIST_CHECK", {
              date: formattedDate2,
              count: paidQRs.length
            }, "SUCCESS", companyId, userId);
            return {
              paymentList: paidQRs,
              responseCode: 0,
              message: `Se encontraron ${paidQRs.length} pagos para la fecha ${date3}`
            };
          } catch (error3) {
            console.error("Error consultando QRs pagados Baneco:", error3);
            await logActivity("QR_PAID_LIST_ERROR", {
              date: date3,
              error: error3 instanceof Error ? error3.message : "Error desconocido"
            }, "ERROR", companyId, userId);
            return {
              responseCode: 1,
              message: error3 instanceof Error ? error3.message : "Error consultando QRs pagados"
            };
          }
        }
      }
      if (!/^\d{8}$/.test(date3)) {
        return {
          responseCode: 1,
          message: "Formato de fecha inválido. Debe ser YYYYMMDD"
        };
      }
      const formattedDate = `${date3.substring(0, 4)}-${date3.substring(4, 6)}-${date3.substring(6, 8)}`;
      const bankCondition = bankId ? "AND bank_id = $3" : "";
      const params = bankId ? [companyId, formattedDate, bankId] : [companyId, formattedDate];
      const result = await query(`
        SELECT
          qr_id,
          transaction_id,
          payment_date,
          payment_time,
          currency,
          amount,
          sender_bank_code,
          sender_name,
          sender_document_id,
          sender_account,
          description,
          branch_code
        FROM qr_payments
        WHERE company_id = $1 
        AND date(payment_date) = $2
        ${bankCondition}
        ORDER BY payment_date DESC, payment_time DESC
      `, params);
      const payments = result.rows.map((row) => ({
        qrId: row.qr_id,
        transactionId: row.transaction_id,
        paymentDate: row.payment_date,
        paymentTime: row.payment_time,
        currency: row.currency,
        amount: parseFloat(row.amount),
        senderBankCode: row.sender_bank_code,
        senderName: row.sender_name,
        senderDocumentId: row.sender_document_id,
        senderAccount: row.sender_account,
        description: row.description,
        branchCode: row.branch_code
      }));
      await logActivity("QR_PAYMENTS_LISTED", {
        date: formattedDate,
        count: payments.length,
        bankId
      }, "SUCCESS", companyId, userId);
      return {
        paymentList: payments,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error obteniendo QRs pagados:", error3);
      await logActivity("QR_PAYMENTS_LIST_ERROR", {
        date: date3,
        bankId,
        error: error3 instanceof Error ? error3.message : "Unknown error"
      }, "ERROR", companyId, userId);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error obteniendo QRs pagados"
      };
    }
  }
  async checkExpiringQRs() {
    try {
      const now = new Date;
      const twentyFourHoursLater = new Date(now.getTime() + 24 * 60 * 60 * 1000);
      const result = await query(`
        SELECT
          q.qr_id,
          q.company_id,
          q.bank_id,
          q.due_date,
          q.currency,
          q.amount,
          c.name as companyName,
          b.name as bankName
        FROM qr_codes q
        JOIN companies c ON q.company_id = c.id
        JOIN banks b ON q.bank_id = b.id
        WHERE q.status = 'ACTIVE'
        AND q.due_date BETWEEN $1 AND $2
        AND q.deleted_at IS NULL
      `, [now.toISOString(), twentyFourHoursLater.toISOString()]);
      for (const qr of result.rows) {
        await logActivity("QR_EXPIRING_SOON", {
          qrId: qr.qr_id,
          dueDate: qr.dueDate,
          currency: qr.currency,
          amount: qr.amount,
          companyName: qr.companyName,
          bankName: qr.bankName
        }, "WARNING", qr.companyId);
      }
      console.log(`✅ Verificación de QRs por expirar completada: ${result.rowCount} QRs próximos a vencer`);
    } catch (error3) {
      console.error("❌ Error verificando QRs próximos a vencer:", error3);
    }
  }
  async updateExpiredQRs() {
    try {
      const now = new Date;
      const result = await query(`
        UPDATE qr_codes
        SET status = 'EXPIRED', updated_at = CURRENT_TIMESTAMP
        WHERE status = 'ACTIVE'
        AND due_date < $1
        AND deleted_at IS NULL
        RETURNING qr_id, company_id, bank_id
      `, [now.toISOString()]);
      for (const qr of result.rows) {
        await logActivity("QR_EXPIRED", {
          qrId: qr.qr_id
        }, "WARNING", qr.companyId);
      }
      console.log(`✅ Actualización de QRs expirados completada: ${result.rowCount} QRs marcados como expirados`);
    } catch (error3) {
      console.error("❌ Error actualizando QRs expirados:", error3);
    }
  }
  async simulateQRPayment(companyId, qrId, paymentData, userId) {
    try {
      const qrCheck = await query(`
        SELECT 
          q.*,
          b.name as bankName
        FROM qr_codes q
        JOIN banks b ON q.bank_id = b.id
        WHERE q.qr_id = $1 AND q.company_id = $2 AND q.status = 'ACTIVE'
        AND q.deleted_at IS NULL
      `, [qrId, companyId]);
      if (qrCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Código QR no encontrado, no activo o no pertenece a esta empresa"
        };
      }
      const qrInfo = qrCheck.rows[0];
      if (new Date > new Date(qrInfo.due_date)) {
        return {
          responseCode: 1,
          message: "El código QR ha expirado"
        };
      }
      if (!qrInfo.modify_amount && paymentData.amount && paymentData.amount !== parseFloat(qrInfo.amount)) {
        return {
          responseCode: 1,
          message: "Este QR no permite modificar el monto"
        };
      }
      const now = new Date;
      const paymentDate = now.toISOString().split("T")[0];
      const paymentTime = now.toTimeString().split(" ")[0];
      const amount = paymentData.amount || parseFloat(qrInfo.amount);
      const senderBankCode = paymentData.senderBankCode || "1016";
      const senderName = paymentData.senderName || "Cliente de Prueba";
      const transactionId = `SIMU${now.getTime()}${Math.floor(Math.random() * 1000)}`;
      await query(`
        INSERT INTO qr_payments (
          qr_id,
          company_id,
          bank_id,
          transaction_id,
          payment_date,
          payment_time,
          currency,
          amount,
          sender_bank_code,
          sender_name,
          sender_document_id,
          sender_account,
          description,
          branch_code
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
      `, [
        qrId,
        companyId,
        qrInfo.bank_id,
        transactionId,
        paymentDate,
        paymentTime,
        qrInfo.currency,
        amount,
        senderBankCode,
        senderName,
        "0",
        "******1234",
        qrInfo.description,
        qrInfo.branch_code
      ]);
      if (qrInfo.single_use) {
        await query(`
          UPDATE qr_codes
          SET status = 'PAID', updated_at = CURRENT_TIMESTAMP
          WHERE qr_id = $1
        `, [qrId]);
      }
      await logActivity("QR_PAYMENT_SIMULATED", {
        qrId,
        amount,
        currency: qrInfo.currency,
        bankId: qrInfo.bankId,
        bankName: qrInfo.bankName,
        transactionId
      }, "SUCCESS", companyId, userId);
      return {
        responseCode: 0,
        message: "Pago de QR simulado exitosamente"
      };
    } catch (error3) {
      console.error("Error simulando pago de QR:", error3);
      await logActivity("QR_PAYMENT_SIMULATION_ERROR", {
        qrId,
        error: error3 instanceof Error ? error3.message : "Unknown error"
      }, "ERROR", companyId, userId);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error simulando pago de QR"
      };
    }
  }
  async listQRs(companyId, filters, userId) {
    try {
      let sqlQuery = `
        SELECT 
          q.qr_id,
          q.transaction_id,
          q.created_at,
          q.due_date,
          q.currency,
          q.amount,
          q.status,
          q.description,
          q.single_use,
          q.modify_amount,
          q.branch_code,
          b.id as bankId,
          b.name as bankName
        FROM qr_codes q
        JOIN banks b ON q.bank_id = b.id
        WHERE q.company_id = $1
        AND q.deleted_at IS NULL
      `;
      const queryParams = [companyId];
      let paramIndex = 2;
      if (filters.status) {
        sqlQuery += ` AND q.status = $${paramIndex}`;
        queryParams.push(filters.status);
        paramIndex++;
      }
      if (filters.startDate) {
        sqlQuery += ` AND q.created_at >= $${paramIndex}`;
        queryParams.push(filters.startDate);
        paramIndex++;
      }
      if (filters.endDate) {
        sqlQuery += ` AND q.created_at <= $${paramIndex}`;
        queryParams.push(filters.endDate);
        paramIndex++;
      }
      if (filters.bankId) {
        sqlQuery += ` AND q.bank_id = $${paramIndex}`;
        queryParams.push(typeof filters.bankId === "string" ? parseInt(filters.bankId) : filters.bankId);
        paramIndex++;
      }
      sqlQuery += ` ORDER BY q.created_at DESC`;
      const result = await query(sqlQuery, queryParams);
      let countQuery = `
        SELECT COUNT(*) as total
        FROM qr_codes q
        WHERE q.company_id = $1
        AND q.deleted_at IS NULL
      `;
      if (filters.status) {
        countQuery += ` AND q.status = $2`;
      }
      let countParamIndex = filters.status ? 3 : 2;
      if (filters.startDate) {
        countQuery += ` AND q.created_at >= $${countParamIndex}`;
        countParamIndex++;
      }
      if (filters.endDate) {
        countQuery += ` AND q.created_at <= $${countParamIndex}`;
        countParamIndex++;
      }
      if (filters.bankId) {
        countQuery += ` AND q.bank_id = $${countParamIndex}`;
      }
      const countResult = await query(countQuery, queryParams);
      const totalCount = parseInt(countResult.rows[0].total);
      const qrList = [];
      const paidQrIds = result.rows.filter((row) => row.status === "PAID").map((row) => row.qr_id);
      let paymentsMap = {};
      if (paidQrIds.length > 0) {
        const paymentsQuery = `
          SELECT
            qr_id,
            transaction_id,
            payment_date,
            payment_time,
            currency,
            amount,
            sender_bank_code,
            sender_name,
            sender_document_id,
            sender_account,
            description,
            branch_code
          FROM qr_payments
          WHERE company_id = $1 AND qr_id = ANY($2::text[])
          ORDER BY payment_date DESC, payment_time DESC
        `;
        const paymentsResult = await query(paymentsQuery, [companyId, paidQrIds]);
        paymentsMap = paymentsResult.rows.reduce((acc, row) => {
          const payment = {
            qrId: row.qr_id,
            transactionId: row.transaction_id,
            paymentDate: row.payment_date,
            paymentTime: row.payment_time,
            currency: row.currency,
            amount: parseFloat(row.amount),
            senderBankCode: row.sender_bank_code,
            senderName: row.sender_name,
            senderDocumentId: row.sender_document_id,
            senderAccount: row.sender_account,
            description: row.description,
            branchCode: row.branch_code
          };
          if (!acc[row.qr_id]) {
            acc[row.qr_id] = [];
          }
          acc[row.qr_id].push(payment);
          return acc;
        }, {});
      }
      for (const row of result.rows) {
        const qrItem = {
          qrId: row.qrId,
          transactionId: row.transactionId,
          createdAt: row.createdAt,
          dueDate: row.dueDate,
          currency: row.currency,
          amount: parseFloat(row.amount),
          status: row.status,
          description: row.description,
          bankName: row.bankName,
          bankId: row.bankId,
          singleUse: row.singleUse,
          modifyAmount: row.modifyAmount,
          branchCode: row.branchCode
        };
        if (row.status === "PAID" && paymentsMap[row.qrId]) {
          qrItem.payments = paymentsMap[row.qrId];
        }
        qrList.push(qrItem);
      }
      await logActivity("QR_LIST_VIEWED", {
        filters,
        count: qrList.length,
        totalCount
      }, "SUCCESS", companyId, userId);
      return {
        qrList,
        totalCount,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error listando códigos QR:", error3);
      await logActivity("QR_LIST_ERROR", {
        filters,
        error: error3 instanceof Error ? error3.message : "Unknown error"
      }, "ERROR", companyId, userId);
      return {
        totalCount: 0,
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error listando códigos QR"
      };
    }
  }
}
var qrService = new QrService;
var qr_service_default = qrService;

// src/services/monitor.service.ts
async function logActivity(actionType, actionDetails, status, companyId, userId) {
  try {
    await query("INSERT INTO activity_logs (company_id, action_type, action_details, status) VALUES ($1, $2, $3, $4)", [companyId || null, actionType, actionDetails, status]);
  } catch (error3) {
    console.error("Error logging activity:", error3);
  }
}
function initScheduledTasks() {
  new import_cron.CronJob("0 */6 * * *", async () => {
    console.log("\uD83D\uDD0D Running scheduled check for expiring QR codes");
    await qrService.checkExpiringQRs();
  }, null, true);
  new import_cron.CronJob("0 * * * *", async () => {
    console.log("\uD83D\uDD04 Running scheduled update for expired QR codes");
    await qrService.updateExpiredQRs();
  }, null, true);
  new import_cron.CronJob("0 3 * * *", async () => {
    try {
      console.log("\uD83E\uDDF9 Cleaning old activity logs");
      const result = await query(`
        DELETE FROM activity_logs
        WHERE created_at < NOW() - INTERVAL '30 days'
        RETURNING id
      `);
      console.log(`\uD83E\uDDF9 Deleted ${result.rowCount} old activity logs`);
    } catch (error3) {
      console.error("Error cleaning activity logs:", error3);
    }
  }, null, true);
  console.log("⏰ Scheduled tasks initialized");
}

// src/services/auth.service.ts
var import_jsonwebtoken = __toESM(require_jsonwebtoken(), 1);
var JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";
var TOKEN_EXPIRY = parseInt(process.env.TOKEN_EXPIRY || "86400", 10);

class AuthService {
  cryptoService;
  constructor() {
    this.cryptoService = new CryptoService(process.env.CRYPTO_KEY || "default-encryption-key");
  }
  async authenticate(email, password) {
    const userQuery = await query(`
      SELECT * FROM users WHERE email = $1 AND status = 'ACTIVE' AND deleted_at IS NULL`, [email]);
    if (userQuery.rowCount === 0) {
      return {
        user: {
          responseCode: 1,
          message: "Usuario no encontrado"
        },
        auth: {
          accessToken: "",
          refreshToken: ""
        }
      };
    }
    const user = userQuery.rows[0];
    const valid = await Bun.password.verify(password, user.password);
    if (!valid) {
      return {
        user: {
          responseCode: 1,
          message: "Contraseña incorrecta"
        },
        auth: {
          accessToken: "",
          refreshToken: ""
        }
      };
    }
    const accessToken = import_jsonwebtoken.default.sign({
      userId: user.id,
      companyId: user.company_id,
      email: user.email,
      role: user.role
    }, JWT_SECRET, { expiresIn: TOKEN_EXPIRY });
    const refreshToken = import_jsonwebtoken.default.sign({
      userId: user.id,
      companyId: user.company_id,
      email: user.email,
      role: user.role
    }, JWT_SECRET, { expiresIn: "30d" });
    return {
      user: {
        userId: user.id,
        companyId: user.company_id,
        email: user.email,
        role: user.role,
        responseCode: 0,
        message: "Autenticación exitosa"
      },
      auth: {
        accessToken,
        refreshToken
      }
    };
  }
  async verifyToken(token) {
    try {
      import_jsonwebtoken.default.verify(token, JWT_SECRET);
      return true;
    } catch (error3) {
      return false;
    }
  }
  async changePassword(userId, currentPassword, newPassword) {
    try {
      const userResult = await query("SELECT id, email, password, company_id FROM users WHERE id = $1 AND deleted_at IS NULL", [userId]);
      if (userResult.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Usuario no encontrado"
        };
      }
      const user = userResult.rows[0];
      const isValidPassword = await Bun.password.verify(currentPassword, user.password);
      if (!isValidPassword) {
        await logActivity("PASSWORD_CHANGE_FAILED", { userId, reason: "INVALID_CURRENT_PASSWORD" }, "ERROR", user.company_id, userId);
        return {
          responseCode: 1,
          message: "Contraseña actual incorrecta"
        };
      }
      const hashedPassword = await Bun.password.hash(newPassword, {
        algorithm: "bcrypt",
        cost: 10
      });
      await query("UPDATE users SET password = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2", [hashedPassword, userId]);
      await logActivity("PASSWORD_CHANGED", { userId }, "SUCCESS", user.company_id, userId);
      return {
        responseCode: 0,
        message: "Contraseña actualizada exitosamente"
      };
    } catch (error3) {
      console.error("Error cambiando contraseña:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error cambiando contraseña"
      };
    }
  }
  encryptText(text, aesKey) {
    try {
      return this.cryptoService.encrypt(text, aesKey);
    } catch (error3) {
      throw new Error("Error al encriptar el texto");
    }
  }
  decryptText(encryptedText, aesKey) {
    try {
      return this.cryptoService.decrypt(encryptedText, aesKey);
    } catch (error3) {
      throw new Error("Error al desencriptar el texto");
    }
  }
  async createUser(userData, creatorId) {
    try {
      const existingCheck = await query("SELECT id FROM users WHERE email = $1 AND deleted_at IS NULL", [userData.email]);
      if (existingCheck.rowCount && existingCheck.rowCount > 0) {
        return {
          responseCode: 1,
          message: `El usuario ${userData.email} ya existe`
        };
      }
      const companyCheck = await query("SELECT id FROM companies WHERE id = $1 AND deleted_at IS NULL", [userData.companyId]);
      if (companyCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "La empresa especificada no existe"
        };
      }
      const hashedPassword = await Bun.password.hash(userData.password, {
        algorithm: "bcrypt",
        cost: 10
      });
      const result = await query(`
        INSERT INTO users (
          email,
          password,
          full_name,
          company_id,
          role
        )
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
      `, [
        userData.email,
        hashedPassword,
        userData.fullName,
        userData.companyId,
        userData.role
      ]);
      const userId = result.rows[0].id;
      await logActivity("USER_CREATED", {
        userId,
        email: userData.email,
        companyId: userData.companyId,
        role: userData.role
      }, "SUCCESS", userData.companyId, creatorId);
      return {
        id: userId,
        email: userData.email,
        responseCode: 0,
        message: "Usuario creado exitosamente"
      };
    } catch (error3) {
      console.error("Error creando usuario:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error creando usuario"
      };
    }
  }
  async getUserInfo(email) {
    try {
      const result = await query(`
        SELECT 
          u.id, 
          u.email, 
          u.full_name, 
          u.company_id, 
          c.name as company_name,
          u.role
        FROM users u
        LEFT JOIN companies c ON u.company_id = c.id
        WHERE u.email = $1 AND u.status = 'ACTIVE' AND u.deleted_at IS NULL
      `, [email]);
      if (result.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Usuario no encontrado"
        };
      }
      const user = result.rows[0];
      return {
        id: user.id,
        email: user.email,
        fullName: user.full_name,
        companyId: user.company_id,
        companyName: user.company_name,
        role: user.role,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error obteniendo información de usuario:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error obteniendo información de usuario"
      };
    }
  }
  async listUsers(companyId) {
    try {
      const result = await query(`
        SELECT 
          id, 
          email, 
          full_name, 
          role, 
          status, 
          created_at
        FROM users
        WHERE company_id = $1 AND deleted_at IS NULL
        ORDER BY email
      `, [companyId]);
      const users = result.rows.map((user) => ({
        id: user.id,
        email: user.email,
        fullName: user.full_name,
        role: user.role,
        status: user.status,
        createdAt: user.created_at
      }));
      return {
        users,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error listando usuarios:", error3);
      return {
        users: [],
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error listando usuarios"
      };
    }
  }
}
var authService = new AuthService;
var auth_service_default = authService;

// src/routes/auth.routes.ts
var AuthRequestSchema = t.Object({
  email: t.String(),
  password: t.String()
});
var authRoutes = new Elysia({ prefix: "/authentication" }).post("/authenticate", async ({ body }) => {
  try {
    console.log("body", body);
    const response = await auth_service_default.authenticate(body.email, body.password);
    return response;
  } catch (error3) {
    console.log("error", error3);
  }
}, {
  body: AuthRequestSchema,
  detail: {
    tags: ["auth"],
    summary: "Autenticar usuario y obtener token JWT"
  }
}).get("/encrypt", async ({ query: query2 }) => {
  try {
    const { text, aesKey } = query2;
    if (!text || !aesKey) {
      return {
        responseCode: 1,
        message: "Parámetros text y aesKey son requeridos"
      };
    }
    return auth_service_default.encryptText(text, aesKey);
  } catch (error3) {
    return {
      responseCode: 1,
      message: error3 instanceof Error ? error3.message : "Error de encriptación"
    };
  }
}, {
  query: t.Object({
    text: t.String(),
    aesKey: t.String()
  }),
  detail: {
    tags: ["auth"],
    summary: "Encriptar texto"
  }
}).get("/decrypt", async ({ query: query2 }) => {
  try {
    const { text, aesKey } = query2;
    if (!text || !aesKey) {
      return {
        responseCode: 1,
        message: "Parámetros text y aesKey son requeridos"
      };
    }
    return auth_service_default.decryptText(text, aesKey);
  } catch (error3) {
    return {
      responseCode: 1,
      message: error3 instanceof Error ? error3.message : "Error de desencriptación"
    };
  }
}, {
  query: t.Object({
    text: t.String(),
    aesKey: t.String()
  }),
  detail: {
    tags: ["auth"],
    summary: "Desencriptar texto"
  }
});
var auth_routes_default = authRoutes;

// src/middlewares/auth.middleware.ts
var import_jsonwebtoken2 = __toESM(require_jsonwebtoken(), 1);

// src/services/apikey.service.ts
class ApiKeyService {
  async verifyApiKey(apiKey) {
    try {
      const result = await query(`
        SELECT id, company_id, permissions, expires_at, status
        FROM api_keys
        WHERE api_key = $1
      `, [apiKey]);
      if (result.rowCount === 0) {
        return { isValid: false };
      }
      const apiKeyData = result.rows[0];
      if (apiKeyData.status !== "ACTIVE") {
        return { isValid: false };
      }
      if (apiKeyData.expires_at && new Date > new Date(apiKeyData.expires_at)) {
        await query(`
          UPDATE api_keys
          SET status = 'EXPIRED'
          WHERE id = $1
        `, [apiKeyData.id]);
        return { isValid: false };
      }
      return {
        isValid: true,
        companyId: apiKeyData.company_id,
        permissions: apiKeyData.permissions
      };
    } catch (error3) {
      console.error("Error verificando API key:", error3);
      return { isValid: false };
    }
  }
  async hasPermission(apiKey, permission) {
    const verification = await this.verifyApiKey(apiKey);
    if (!verification.isValid || !verification.permissions) {
      return false;
    }
    return verification.permissions[permission] === true;
  }
  async generateApiKey(companyId, description, permissions, expiresAt, userId) {
    try {
      const companyCheck = await query("SELECT id FROM companies WHERE id = $1", [companyId]);
      if (companyCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Empresa no encontrada"
        };
      }
      const apiKey = generateApiKey();
      const result = await query(`
        INSERT INTO api_keys (
          api_key, 
          description, 
          company_id, 
          permissions, 
          expires_at
        ) 
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, created_at
      `, [
        apiKey,
        description,
        companyId,
        JSON.stringify(permissions),
        expiresAt ? new Date(expiresAt) : null
      ]);
      await logActivity("API_KEY_GENERATED", {
        apiKeyId: result.rows[0].id,
        description,
        expiresAt
      }, "SUCCESS", companyId, userId);
      return {
        id: result.rows[0].id,
        apiKey,
        description,
        permissions,
        companyId,
        expiresAt,
        status: "ACTIVE",
        createdAt: result.rows[0].created_at,
        responseCode: 0,
        message: "API key generada exitosamente"
      };
    } catch (error3) {
      console.error("Error generando API key:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error generando API key"
      };
    }
  }
  async listApiKeys(companyId) {
    try {
      const result = await query(`
        SELECT 
          id, 
          api_key, 
          description, 
          permissions, 
          expires_at, 
          status, 
          created_at
        FROM api_keys
        WHERE company_id = $1
        ORDER BY created_at DESC
      `, [companyId]);
      return {
        apiKeys: result.rows.map((row) => ({
          id: row.id,
          apiKey: row.api_key,
          description: row.description,
          permissions: row.permissions,
          expiresAt: row.expires_at,
          status: row.status,
          createdAt: row.created_at
        })),
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error listando API keys:", error3);
      return {
        apiKeys: [],
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error listando API keys"
      };
    }
  }
  async revokeApiKey(apiKeyId, companyId, userId) {
    try {
      const apiKeyCheck = await query(`
        SELECT id, api_key
        FROM api_keys
        WHERE id = $1 AND company_id = $2
      `, [apiKeyId, companyId]);
      if (apiKeyCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "API key no encontrada o no pertenece a su empresa"
        };
      }
      await query(`
        UPDATE api_keys
        SET status = 'REVOKED', updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      `, [apiKeyId]);
      await logActivity("API_KEY_REVOKED", {
        apiKeyId,
        apiKey: apiKeyCheck.rows[0].api_key
      }, "SUCCESS", companyId, userId);
      return {
        id: apiKeyId,
        responseCode: 0,
        message: "API key revocada exitosamente"
      };
    } catch (error3) {
      console.error("Error revocando API key:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error revocando API key"
      };
    }
  }
}
var apiKeyService = new ApiKeyService;
var apikey_service_default = apiKeyService;

// src/middlewares/auth.middleware.ts
var authMiddleware = new Elysia({ name: "auth" }).derive(async (context) => {
  try {
    const authHeader = context.headers.authorization;
    if (authHeader && authHeader.startsWith("Bearer ")) {
      const token = authHeader.substring(7);
      try {
        const decodedToken = import_jsonwebtoken2.default.verify(token, process.env.JWT_SECRET || "your-secret-key");
        const userInfo = await authService.getUserInfo(decodedToken.email);
        if (!userInfo || userInfo.responseCode !== 0) {
          throw new Error("Usuario no encontrado");
        }
        return {
          auth: {
            type: "jwt",
            user: {
              id: userInfo.id,
              email: userInfo.email,
              companyId: userInfo.companyId,
              role: userInfo.role
            }
          }
        };
      } catch (error3) {
        throw new Error("Error en autenticación");
      }
    }
    const apiKeyHeader = context.headers["x-api-key"];
    if (apiKeyHeader) {
      const apiKey = apiKeyHeader;
      const verification = await apiKeyService.verifyApiKey(apiKey);
      if (verification.isValid && verification.companyId && verification.permissions) {
        await logActivity("API_KEY_USED", {
          path: context.path,
          method: context.request.method
        }, "SUCCESS", verification.companyId);
        return {
          auth: {
            type: "apikey",
            apiKeyInfo: {
              companyId: verification.companyId,
              permissions: verification.permissions
            }
          }
        };
      }
      throw new Error("API key inválida");
    }
    throw new Error("No autorizado. Se requiere autenticación válida.");
  } catch (error3) {
    throw new Error("Error en autenticación");
  }
});

// src/schemas/qr.schemas.ts
var QRRequestSchema = t.Object({
  transactionId: t.String(),
  amount: t.Number(),
  description: t.Optional(t.String()),
  bankId: t.Optional(t.Number({ default: 1 })),
  dueDate: t.Optional(t.String()),
  singleUse: t.Optional(t.Boolean({ default: false })),
  modifyAmount: t.Optional(t.Boolean({ default: false }))
});

// src/routes/qr.routes.ts
var qrRoutes = new Elysia({ prefix: "/qrsimple" }).use(authMiddleware).post("/generateQR", async ({ body, auth }) => {
  let companyId;
  let userId;
  if (auth?.type === "jwt") {
    companyId = auth.user.companyId;
    userId = auth.user.id;
  } else if (auth?.type === "apikey") {
    const hasPermission = await apikey_service_default.hasPermission(auth.apiKeyInfo.companyId.toString(), "qr_generate");
    if (!hasPermission) {
      return {
        responseCode: 1,
        message: "API Key no tiene permisos para generar QR"
      };
    }
    companyId = auth.apiKeyInfo.companyId;
  } else {
    return {
      responseCode: 1,
      message: "No autorizado"
    };
  }
  const bankId = body?.bankId || 1;
  return await qr_service_default.generateQR(companyId, body, userId, bankId);
}, {
  body: QRRequestSchema,
  detail: {
    tags: ["qr"],
    summary: "Generar código QR para cobro"
  }
}).delete("/cancelQR", async ({ body, auth }) => {
  let companyId;
  let userId;
  if (auth?.type === "jwt") {
    companyId = auth.user.companyId;
    userId = auth.user.id;
  } else if (auth?.type === "apikey") {
    const hasPermission = await apikey_service_default.hasPermission(auth.apiKeyInfo.companyId.toString(), "qr_cancel");
    if (!hasPermission) {
      return {
        responseCode: 1,
        message: "API Key no tiene permisos para cancelar QR"
      };
    }
    companyId = auth.apiKeyInfo.companyId;
  } else {
    return {
      responseCode: 1,
      message: "No autorizado"
    };
  }
  return await qr_service_default.cancelQR(companyId, body.qrId, userId);
}, {
  body: t.Object({
    qrId: t.String()
  }),
  detail: {
    tags: ["qr"],
    summary: "Cancelar código QR"
  }
}).get("/v2/statusQR/:id", async ({ params, auth }) => {
  let companyId;
  let userId;
  if (auth?.type === "jwt") {
    companyId = auth.user.companyId;
    userId = auth.user.id;
  } else if (auth?.type === "apikey") {
    const hasPermission = await apikey_service_default.hasPermission(auth.apiKeyInfo.companyId.toString(), "qr_status");
    if (!hasPermission) {
      return {
        responseCode: 1,
        message: "API Key no tiene permisos para verificar estado de QR"
      };
    }
    companyId = auth.apiKeyInfo.companyId;
  } else {
    return {
      responseCode: 1,
      message: "No autorizado"
    };
  }
  return await qr_service_default.checkQRStatus(companyId, params.id, userId);
}, {
  params: t.Object({
    id: t.String()
  }),
  detail: {
    tags: ["qr"],
    summary: "Verificar estado de un código QR"
  }
}).get("/v2/paidQR/:fecha", async ({ params, query: query2, auth }) => {
  let companyId;
  let userId;
  if (auth?.type === "jwt") {
    companyId = auth.user.companyId;
    userId = auth.user.id;
  } else if (auth?.type === "apikey") {
    const hasPermission = await apikey_service_default.hasPermission(auth.apiKeyInfo.companyId.toString(), "qr_status");
    if (!hasPermission) {
      return {
        responseCode: 1,
        message: "API Key no tiene permisos para listar QR pagados"
      };
    }
    companyId = auth.apiKeyInfo.companyId;
  } else {
    return {
      responseCode: 1,
      message: "No autorizado"
    };
  }
  return await qr_service_default.getPaidQRs(companyId, params.fecha, query2.bankId, userId);
}, {
  params: t.Object({
    fecha: t.String()
  }),
  query: t.Object({
    bankId: t.Optional(t.Numeric())
  }),
  detail: {
    tags: ["qr"],
    summary: "Obtener lista de QRs pagados en una fecha determinada"
  }
}).get("/list", async ({ query: query2, auth }) => {
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  return await qr_service_default.listQRs(auth.user.companyId, {
    status: query2.status,
    startDate: query2.startDate,
    endDate: query2.endDate,
    bankId: query2.bankId
  });
}, {
  query: t.Object({
    status: t.Optional(t.String()),
    startDate: t.Optional(t.String()),
    endDate: t.Optional(t.String()),
    bankId: t.Optional(t.Numeric())
  }),
  detail: {
    tags: ["qr"],
    summary: "Listar códigos QR con filtros"
  }
}).post("/simulatePayment", async ({ body, auth }) => {
  if (false) {}
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  return await qr_service_default.simulateQRPayment(auth.user.companyId, body.qrId, {
    amount: body.amount,
    senderBankCode: body.senderBankCode,
    senderName: body.senderName
  }, auth.user.id);
}, {
  body: t.Object({
    qrId: t.String(),
    amount: t.Optional(t.Number()),
    senderBankCode: t.Optional(t.String()),
    senderName: t.Optional(t.String())
  }),
  detail: {
    tags: ["qr"],
    summary: "Simular pago de un código QR (solo para desarrollo)"
  }
});
var qr_routes_default = qrRoutes;

// src/routes/apikeys.routes.ts
var apiKeyRoutes = new Elysia({ prefix: "/api-keys" }).use(authMiddleware).get("/", async ({ auth }) => {
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  return await apikey_service_default.listApiKeys(auth.user.companyId);
}, {
  detail: {
    tags: ["api-keys"],
    summary: "Listar API keys de la empresa"
  }
}).post("/", async ({ body, auth }) => {
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  if (auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Se requiere rol de administrador para esta operación"
    };
  }
  return await apikey_service_default.generateApiKey(auth.user.companyId, body.description, body.permissions, body.expiresAt, auth.user.id);
}, {
  body: t.Object({
    description: t.String(),
    permissions: t.Object({
      qr_generate: t.Boolean(),
      qr_status: t.Boolean(),
      qr_cancel: t.Boolean()
    }),
    expiresAt: t.Optional(t.String())
  }),
  detail: {
    tags: ["api-keys"],
    summary: "Generar nueva API key"
  }
}).delete("/:id", async ({ params, auth }) => {
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  if (auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Se requiere rol de administrador para esta operación"
    };
  }
  return await apikey_service_default.revokeApiKey(Number(params.id), auth.user.companyId, auth.user.id);
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  detail: {
    tags: ["api-keys"],
    summary: "Revocar una API key"
  }
});
var apikeys_routes_default = apiKeyRoutes;

// src/routes/users.routes.ts
var userRoutes = new Elysia({ prefix: "/users" }).use(authMiddleware).post("/", async ({ body, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await auth_service_default.createUser({
    email: body.email,
    password: body.password,
    fullName: body.fullName,
    companyId: auth.user.companyId,
    role: "USER"
  }, auth.user.id);
}, {
  body: t.Object({
    password: t.String(),
    fullName: t.String(),
    email: t.String()
  }),
  detail: {
    tags: ["admin"],
    summary: "Crear nuevo usuario"
  }
}).get("/", async ({ auth }) => {
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  return await auth_service_default.listUsers(auth.user.companyId);
}, {
  detail: {
    tags: ["admin"],
    summary: "Listar usuarios de la empresa"
  }
}).post("/change-password", async ({ body, auth }) => {
  if (auth?.type !== "jwt") {
    return {
      responseCode: 1,
      message: "Se requiere autenticación de usuario para esta operación"
    };
  }
  return await auth_service_default.changePassword(auth.user.id, body.currentPassword, body.newPassword);
}, {
  body: t.Object({
    currentPassword: t.String(),
    newPassword: t.String()
  }),
  detail: {
    tags: ["auth"],
    summary: "Cambiar contraseña"
  }
});
var users_routes_default = userRoutes;

// src/services/company.service.ts
class CompanyService {
  async createCompany(companyData, userId) {
    try {
      const existingCheck = await query("SELECT id FROM companies WHERE business_id = $1", [companyData.businessId]);
      if (existingCheck.rowCount > 0) {
        return {
          responseCode: 1,
          message: `Ya existe una empresa con el ID de negocio '${companyData.businessId}'`
        };
      }
      const result = await query(`
        INSERT INTO companies (
          name,
          business_id,
          address,
          contact_email,
          contact_phone
        )
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, created_at
      `, [
        companyData.name,
        companyData.businessId,
        companyData.address || null,
        companyData.contactEmail,
        companyData.contactPhone || null
      ]);
      const companyId = result.rows[0].id;
      await logActivity("COMPANY_CREATED", {
        companyId,
        name: companyData.name,
        businessId: companyData.businessId
      }, "SUCCESS", companyId, userId);
      return {
        id: companyId,
        name: companyData.name,
        businessId: companyData.businessId,
        address: companyData.address,
        contactEmail: companyData.contactEmail,
        contactPhone: companyData.contactPhone,
        status: "ACTIVE",
        responseCode: 0,
        message: "Empresa creada exitosamente"
      };
    } catch (error3) {
      console.error("Error creando empresa:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error creando empresa"
      };
    }
  }
  async updateCompany(companyId, companyData, userId) {
    try {
      const companyCheck = await query("SELECT id FROM companies WHERE id = $1", [companyId]);
      if (companyCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Empresa no encontrada"
        };
      }
      const updates = [];
      const values = [];
      let paramCounter = 1;
      if (companyData.name !== undefined) {
        updates.push(`name = $${paramCounter++}`);
        values.push(companyData.name);
      }
      if (companyData.businessId !== undefined) {
        if (companyData.businessId) {
          const existingCheck = await query("SELECT id FROM companies WHERE business_id = $1 AND id != $2", [companyData.businessId, companyId]);
          if (existingCheck.rowCount > 0) {
            return {
              responseCode: 1,
              message: `Ya existe otra empresa con el ID de negocio '${companyData.businessId}'`
            };
          }
          updates.push(`business_id = $${paramCounter++}`);
          values.push(companyData.businessId);
        }
      }
      if (companyData.address !== undefined) {
        updates.push(`address = $${paramCounter++}`);
        values.push(companyData.address || null);
      }
      if (companyData.contactEmail !== undefined) {
        updates.push(`contact_email = $${paramCounter++}`);
        values.push(companyData.contactEmail);
      }
      if (companyData.contactPhone !== undefined) {
        updates.push(`contact_phone = $${paramCounter++}`);
        values.push(companyData.contactPhone || null);
      }
      updates.push(`updated_at = CURRENT_TIMESTAMP`);
      if (updates.length === 1) {
        return {
          id: companyId,
          responseCode: 0,
          message: "No se realizaron cambios"
        };
      }
      values.push(companyId);
      const result = await query(`
        UPDATE companies
        SET ${updates.join(", ")}
        WHERE id = $${paramCounter}
        RETURNING id, name, business_id, address, contact_email, contact_phone, status
      `, values);
      const updatedCompany = result.rows[0];
      await logActivity("COMPANY_UPDATED", {
        companyId,
        updatedFields: Object.keys(companyData)
      }, "SUCCESS", companyId, userId);
      return {
        id: updatedCompany.id,
        name: updatedCompany.name,
        businessId: updatedCompany.business_id,
        address: updatedCompany.address,
        contactEmail: updatedCompany.contact_email,
        contactPhone: updatedCompany.contact_phone,
        status: updatedCompany.status,
        responseCode: 0,
        message: "Empresa actualizada exitosamente"
      };
    } catch (error3) {
      console.error("Error actualizando empresa:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error actualizando empresa"
      };
    }
  }
  async getCompanyDetails(companyId) {
    try {
      const companyResult = await query(`
        SELECT 
          id, 
          name, 
          business_id, 
          address, 
          contact_email, 
          contact_phone, 
          status, 
          created_at, 
          updated_at
        FROM companies
        WHERE id = $1
      `, [companyId]);
      if (companyResult.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Empresa no encontrada"
        };
      }
      const bankConfigsResult = await query(`
        SELECT 
          cbc.id,
          b.id as bank_id,
          b.code as bank_code,
          b.name as bank_name,
          cbc.account_number,
          cbc.merchant_id,
          cbc.additional_config,
          cbc.status
        FROM company_bank_configs cbc
        JOIN banks b ON cbc.bank_id = b.id
        WHERE cbc.company_id = $1
        ORDER BY b.name
      `, [companyId]);
      const company = {
        id: companyResult.rows[0].id,
        name: companyResult.rows[0].name,
        businessId: companyResult.rows[0].business_id,
        address: companyResult.rows[0].address,
        contactEmail: companyResult.rows[0].contact_email,
        contactPhone: companyResult.rows[0].contact_phone,
        status: companyResult.rows[0].status,
        createdAt: companyResult.rows[0].created_at,
        updatedAt: companyResult.rows[0].updated_at
      };
      const bankConfigs = bankConfigsResult.rows.map((row) => ({
        id: row.id,
        bankId: row.bank_id,
        bankCode: row.bank_code,
        bankName: row.bank_name,
        accountNumber: row.account_number,
        merchantId: row.merchant_id,
        additionalConfig: row.additional_config,
        status: row.status
      }));
      return {
        company,
        bankConfigs,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error obteniendo detalles de la empresa:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error obteniendo detalles de la empresa"
      };
    }
  }
  async listCompanies() {
    try {
      const result = await query(`
        SELECT 
          id, 
          name, 
          business_id, 
          contact_email, 
          contact_phone, 
          status, 
          created_at
        FROM companies
        ORDER BY name
      `);
      const companies = result.rows.map((row) => ({
        id: row.id,
        name: row.name,
        businessId: row.business_id,
        contactEmail: row.contact_email,
        contactPhone: row.contact_phone,
        status: row.status,
        createdAt: row.created_at
      }));
      return {
        companies,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error listando empresas:", error3);
      return {
        companies: [],
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error listando empresas"
      };
    }
  }
  async configureBankForCompany(companyId, bankConfig, userId) {
    try {
      const companyCheck = await query("SELECT id FROM companies WHERE id = $1", [companyId]);
      if (companyCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Empresa no encontrada"
        };
      }
      const bankCheck = await query("SELECT id FROM banks WHERE id = $1", [bankConfig.bankId]);
      if (bankCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Banco no encontrado"
        };
      }
      const configCheck = await query(`
        SELECT id 
        FROM company_bank_configs
        WHERE company_id = $1 AND bank_id = $2
      `, [companyId, bankConfig.bankId]);
      let configId;
      if (configCheck.rowCount > 0) {
        configId = configCheck.rows[0].id;
        await query(`
          UPDATE company_bank_configs
          SET 
            account_number = $1,
            merchant_id = $2,
            encryption_key = $3,
            additional_config = $4,
            status = 'ACTIVE',
            updated_at = CURRENT_TIMESTAMP
          WHERE id = $5
        `, [
          bankConfig.accountNumber,
          bankConfig.merchantId || null,
          bankConfig.encryptionKey || null,
          bankConfig.additionalConfig ? JSON.stringify(bankConfig.additionalConfig) : null,
          configId
        ]);
        await logActivity("BANK_CONFIG_UPDATED", {
          companyId,
          bankId: bankConfig.bankId,
          configId
        }, "SUCCESS", companyId, userId);
        return {
          configId,
          responseCode: 0,
          message: "Configuración de banco actualizada exitosamente"
        };
      } else {
        const result = await query(`
          INSERT INTO company_bank_configs (
            company_id,
            bank_id,
            account_number,
            merchant_id,
            encryption_key,
            additional_config
          )
          VALUES ($1, $2, $3, $4, $5, $6)
          RETURNING id
        `, [
          companyId,
          bankConfig.bankId,
          bankConfig.accountNumber,
          bankConfig.merchantId || null,
          bankConfig.encryptionKey || null,
          bankConfig.additionalConfig ? JSON.stringify(bankConfig.additionalConfig) : null
        ]);
        configId = result.rows[0].id;
        await logActivity("BANK_CONFIG_CREATED", {
          companyId,
          bankId: bankConfig.bankId,
          configId
        }, "SUCCESS", companyId, userId);
        return {
          configId,
          responseCode: 0,
          message: "Configuración de banco creada exitosamente"
        };
      }
    } catch (error3) {
      console.error("Error configurando banco para la empresa:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error configurando banco"
      };
    }
  }
  async deactivateCompany(companyId, userId) {
    try {
      const companyCheck = await query("SELECT id, name FROM companies WHERE id = $1", [companyId]);
      if (companyCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Empresa no encontrada"
        };
      }
      await query(`
        UPDATE companies
        SET status = 'INACTIVE', updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      `, [companyId]);
      await logActivity("COMPANY_DEACTIVATED", {
        companyId,
        companyName: companyCheck.rows[0].name
      }, "SUCCESS", companyId, userId);
      return {
        id: companyId,
        responseCode: 0,
        message: "Empresa desactivada exitosamente"
      };
    } catch (error3) {
      console.error("Error desactivando empresa:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error desactivando empresa"
      };
    }
  }
}
var companyService = new CompanyService;
var company_service_default = companyService;

// src/routes/admin/companies.routes.ts
var companiesRoutes = new Elysia({ prefix: "/admin/companies" }).use(authMiddleware).get("/", async ({ auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await company_service_default.listCompanies();
}, {
  detail: {
    tags: ["admin", "companies"],
    summary: "Listar todas las empresas"
  }
}).post("/", async ({ body, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await company_service_default.createCompany(body, auth.user.id);
}, {
  body: t.Object({
    name: t.String(),
    businessId: t.String(),
    address: t.Optional(t.String()),
    contactEmail: t.String(),
    contactPhone: t.Optional(t.String())
  }),
  detail: {
    tags: ["admin", "companies"],
    summary: "Crear nueva empresa"
  }
}).get("/:id", async ({ params, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await company_service_default.getCompanyDetails(Number(params.id));
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  detail: {
    tags: ["admin", "companies"],
    summary: "Obtener detalles de una empresa"
  }
}).put("/:id", async ({ params, body, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await company_service_default.updateCompany(Number(params.id), body, auth.user.id);
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  body: t.Object({
    name: t.Optional(t.String()),
    businessId: t.Optional(t.String()),
    address: t.Optional(t.String()),
    contactEmail: t.Optional(t.String()),
    contactPhone: t.Optional(t.String())
  }),
  detail: {
    tags: ["admin", "companies"],
    summary: "Actualizar una empresa"
  }
}).post("/:id/bank-configs", async ({ params, body, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await company_service_default.configureBankForCompany(Number(params.id), body, auth.user.id);
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  body: t.Object({
    bankId: t.Number(),
    accountNumber: t.String(),
    merchantId: t.Optional(t.String()),
    encryptionKey: t.Optional(t.String()),
    additionalConfig: t.Optional(t.Object({}))
  }),
  detail: {
    tags: ["admin", "companies"],
    summary: "Configurar un banco para una empresa"
  }
}).delete("/:id", async ({ params, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await company_service_default.deactivateCompany(Number(params.id), auth.user.id);
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  detail: {
    tags: ["admin", "companies"],
    summary: "Desactivar una empresa"
  }
});
var companies_routes_default = companiesRoutes;

// src/services/bank.service.ts
class BankService {
  async createBank(bankData, userId, companyId) {
    try {
      const existingCheck = await query("SELECT id FROM banks WHERE code = $1 AND deleted_at IS NULL", [bankData.code]);
      if (existingCheck.rowCount && existingCheck.rowCount > 0) {
        return {
          responseCode: 1,
          message: `Ya existe un banco con el código '${bankData.code}'`
        };
      }
      const result = await query(`
        INSERT INTO banks (
          code,
          name,
          test_api_url,
          prod_api_url,
          encryption_key
        )
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id, created_at
      `, [
        bankData.code,
        bankData.name,
        bankData.testApiUrl || null,
        bankData.prodApiUrl || null,
        bankData.encryptionKey || null
      ]);
      const bankId = result.rows[0].id;
      await logActivity("BANK_CREATED", {
        bankId,
        code: bankData.code,
        name: bankData.name
      }, "SUCCESS", companyId, userId);
      return {
        id: bankId,
        code: bankData.code,
        name: bankData.name,
        status: "ACTIVE",
        responseCode: 0,
        message: "Banco creado exitosamente"
      };
    } catch (error3) {
      console.error("Error creando banco:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error creando banco"
      };
    }
  }
  async updateBank(bankId, bankData, userId, companyId) {
    try {
      const bankCheck = await query("SELECT id FROM banks WHERE id = $1 AND deleted_at IS NULL", [bankId]);
      if (bankCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Banco no encontrado"
        };
      }
      const updates = [];
      const values = [];
      let paramCounter = 1;
      if (bankData.code !== undefined) {
        if (bankData.code) {
          const existingCheck = await query("SELECT id FROM banks WHERE code = $1 AND id != $2 AND deleted_at IS NULL", [bankData.code, bankId]);
          if (existingCheck.rowCount && existingCheck.rowCount > 0) {
            return {
              responseCode: 1,
              message: `Ya existe otro banco con el código '${bankData.code}'`
            };
          }
          updates.push(`code = $${paramCounter++}`);
          values.push(bankData.code);
        }
      }
      if (bankData.name !== undefined) {
        updates.push(`name = $${paramCounter++}`);
        values.push(bankData.name);
      }
      if (bankData.testApiUrl !== undefined) {
        updates.push(`test_api_url = $${paramCounter++}`);
        values.push(bankData.testApiUrl || null);
      }
      if (bankData.prodApiUrl !== undefined) {
        updates.push(`prod_api_url = $${paramCounter++}`);
        values.push(bankData.prodApiUrl || null);
      }
      if (bankData.encryptionKey !== undefined) {
        updates.push(`encryption_key = $${paramCounter++}`);
        values.push(bankData.encryptionKey || null);
      }
      updates.push(`updated_at = CURRENT_TIMESTAMP`);
      if (updates.length === 1) {
        return {
          id: bankId,
          responseCode: 0,
          message: "No se realizaron cambios"
        };
      }
      values.push(bankId);
      const result = await query(`
        UPDATE banks
        SET ${updates.join(", ")}
        WHERE id = $${paramCounter}
        RETURNING id, code, name, status
      `, values);
      const updatedBank = result.rows[0];
      await logActivity("BANK_UPDATED", {
        bankId,
        updatedFields: Object.keys(bankData)
      }, "SUCCESS", companyId, userId);
      return {
        id: updatedBank.id,
        code: updatedBank.code,
        name: updatedBank.name,
        status: updatedBank.status,
        responseCode: 0,
        message: "Banco actualizado exitosamente"
      };
    } catch (error3) {
      console.error("Error actualizando banco:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error actualizando banco"
      };
    }
  }
  async getBankDetails(bankId) {
    try {
      const result = await query(`
        SELECT 
          id, 
          code, 
          name, 
          status, 
          created_at, 
          updated_at
        FROM banks
        WHERE id = $1 AND deleted_at IS NULL
      `, [bankId]);
      if (result.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Banco no encontrado"
        };
      }
      const bank = {
        id: result.rows[0].id,
        code: result.rows[0].code,
        name: result.rows[0].name,
        status: result.rows[0].status,
        createdAt: result.rows[0].created_at,
        updatedAt: result.rows[0].updated_at
      };
      return {
        bank,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error obteniendo detalles del banco:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error obteniendo detalles del banco"
      };
    }
  }
  async listBanks() {
    try {
      const result = await query(`
        SELECT 
          id, 
          code, 
          name, 
          status, 
          created_at
        FROM banks
        WHERE deleted_at IS NULL
        ORDER BY name
      `);
      const banks = result.rows.map((row) => ({
        id: row.id,
        code: row.code,
        name: row.name,
        status: row.status,
        createdAt: row.created_at
      }));
      return {
        banks,
        responseCode: 0,
        message: ""
      };
    } catch (error3) {
      console.error("Error listando bancos:", error3);
      return {
        banks: [],
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error listando bancos"
      };
    }
  }
  async deactivateBank(bankId, userId, companyId) {
    try {
      const bankCheck = await query("SELECT id, code, name FROM banks WHERE id = $1 AND deleted_at IS NULL", [bankId]);
      if (bankCheck.rowCount === 0) {
        return {
          responseCode: 1,
          message: "Banco no encontrado"
        };
      }
      await query(`
        UPDATE banks
        SET status = 'INACTIVE', updated_at = CURRENT_TIMESTAMP
        WHERE id = $1
      `, [bankId]);
      await logActivity("BANK_DEACTIVATED", {
        bankId,
        bankCode: bankCheck.rows[0].code,
        bankName: bankCheck.rows[0].name
      }, "SUCCESS", companyId, userId);
      return {
        id: bankId,
        responseCode: 0,
        message: "Banco desactivado exitosamente"
      };
    } catch (error3) {
      console.error("Error desactivando banco:", error3);
      return {
        responseCode: 1,
        message: error3 instanceof Error ? error3.message : "Error desactivando banco"
      };
    }
  }
}
var bankService = new BankService;
var bank_service_default = bankService;

// src/routes/admin/banks.routes.ts
var banksRoutes = new Elysia({ prefix: "/admin/banks" }).use(authMiddleware).get("/", async ({ auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await bank_service_default.listBanks();
}, {
  detail: {
    tags: ["admin", "banks"],
    summary: "Listar todos los bancos"
  }
}).post("/", async ({ body, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await bank_service_default.createBank(body, auth.user.id);
}, {
  body: t.Object({
    code: t.String(),
    name: t.String(),
    apiBaseUrl: t.Optional(t.String()),
    apiVersion: t.Optional(t.String()),
    encryptionKey: t.Optional(t.String())
  }),
  detail: {
    tags: ["admin", "banks"],
    summary: "Crear nuevo banco"
  }
}).get("/:id", async ({ params, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await bank_service_default.getBankDetails(Number(params.id));
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  detail: {
    tags: ["admin", "banks"],
    summary: "Obtener detalles de un banco"
  }
}).put("/:id", async ({ params, body, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await bank_service_default.updateBank(Number(params.id), body, auth.user.id);
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  body: t.Object({
    code: t.Optional(t.String()),
    name: t.Optional(t.String()),
    apiBaseUrl: t.Optional(t.String()),
    apiVersion: t.Optional(t.String()),
    encryptionKey: t.Optional(t.String())
  }),
  detail: {
    tags: ["admin", "banks"],
    summary: "Actualizar un banco"
  }
}).delete("/:id", async ({ params, auth }) => {
  if (auth?.type !== "jwt" || auth.user.role !== "ADMIN") {
    return {
      responseCode: 1,
      message: "Acceso denegado"
    };
  }
  return await bank_service_default.deactivateBank(Number(params.id), auth.user.id);
}, {
  params: t.Object({
    id: t.Numeric()
  }),
  detail: {
    tags: ["admin", "banks"],
    summary: "Desactivar un banco"
  }
});
var banks_routes_default = banksRoutes;

// src/routes/index.ts
var routes = new Elysia({ prefix: "/api" }).use(auth_routes_default).use(qr_routes_default).use(apikeys_routes_default).use(users_routes_default).use(companies_routes_default).use(banks_routes_default);

// src/scripts/seed-db.ts
async function seedDatabase() {
  try {
    console.log("Poblando la base de datos con datos iniciales...");
    const encryptionKey = "6F09E3167E1D40829207B01041A65B12";
    const banecoApiUrl = "https://apimktdesa.baneco.com.bo/ApiGateway/";
    const banecoUsername = "1649710";
    const banecoPassword = "1234";
    const banecoAccount = "1041070599";
    const defaultUser = "admin@example.com";
    const defaultPassword = "1234";
    const bnbApiUrl = "https://api-sandbox.bnb.com.bo/";
    console.log("Usando configuración:");
    console.log(`- Llave de encriptación: ${encryptionKey}`);
    console.log(`- URL API Banco Económico: ${banecoApiUrl}`);
    console.log(`- Usuario: ${banecoUsername}`);
    console.log(`- Cuenta: ${banecoAccount}`);
    console.log("Insertando datos de los bancos...");
    const banecoResult = await query(`
      INSERT INTO banks (code, name, api_version, encryption_key, test_api_url, prod_api_url, status)
      VALUES ('1016', 'Banco Económico', 'v1.3', $1, $2, $3, 'ACTIVE')
      ON CONFLICT (code) 
      DO UPDATE SET 
        encryption_key = $1,
        test_api_url = $2,
        prod_api_url = $3,
        updated_at = CURRENT_TIMESTAMP
      RETURNING id
    `, [encryptionKey, "https://apimktdesa.baneco.com.bo/ApiGateway/", "https://apimktdesa.baneco.com.bo/ApiGateway/"]);
    const banecoId = banecoResult.rows[0]?.id;
    console.log(`Banco Económico insertado/actualizado con ID: ${banecoId}`);
    const bnbResult = await query(`
      INSERT INTO banks (code, name, api_version, encryption_key, test_api_url, prod_api_url, status)
      VALUES ('1001', 'Banco Nacional de Bolivia (BNB)', 'v1.0', $1, $2, $3, 'ACTIVE')
      ON CONFLICT (code) 
      DO UPDATE SET 
        encryption_key = $1,
        test_api_url = $2,
        prod_api_url = $3,
        updated_at = CURRENT_TIMESTAMP
      RETURNING id
    `, [encryptionKey, bnbApiUrl, bnbApiUrl]);
    const bnbId = bnbResult.rows[0]?.id;
    console.log(`Banco BNB insertado/actualizado con ID: ${bnbId}`);
    const bisaResult = await query(`
      INSERT INTO banks (code, name, api_version, encryption_key, test_api_url, prod_api_url, status)
      VALUES ('1003', 'Banco BISA', 'v1.0', $1, $2, $3, 'ACTIVE')
      ON CONFLICT (code) 
      DO UPDATE SET 
        encryption_key = $1,
        test_api_url = $2,
        prod_api_url = $3,
        updated_at = CURRENT_TIMESTAMP
      RETURNING id
    `, [encryptionKey, "https://api-test.grupobisa.com/", "https://api-test.grupobisa.com/"]);
    const bisaId = bisaResult.rows[0]?.id;
    console.log(`Banco BISA insertado/actualizado con ID: ${bisaId}`);
    console.log("Insertando empresa de demostración...");
    const companyResult = await query(`
      INSERT INTO companies (name, business_id, contact_email, status)
      VALUES ('Empresa Demo', 'DEMO-COMPANY', 'demo@example.com', 'ACTIVE')
      ON CONFLICT (business_id) 
      DO UPDATE SET 
        name = 'Empresa Demo',
        contact_email = 'demo@example.com',
        updated_at = CURRENT_TIMESTAMP
      RETURNING id
    `);
    const companyId = companyResult.rows[0]?.id;
    console.log(`Empresa insertada/actualizada con ID: ${companyId}`);
    console.log("Insertando usuario administrador...");
    const passwordHash = await Bun.password.hash(defaultPassword, {
      algorithm: "bcrypt",
      cost: 10
    });
    const userResult = await query(`
      INSERT INTO users (email, password, full_name, company_id, role, status)
      VALUES ($1, $2, 'Usuario Demo', $3, 'ADMIN', 'ACTIVE')
      ON CONFLICT (email) 
      DO UPDATE SET 
        password = $2,
        updated_at = CURRENT_TIMESTAMP
      RETURNING id
    `, [defaultUser, passwordHash, companyId]);
    const userId = userResult.rows[0]?.id;
    console.log(`Usuario insertado/actualizado con ID: ${userId}`);
    console.log("Configurando relación empresa-banco para Banco Económico...");
    await query(`
      INSERT INTO company_bank_configs (company_id, bank_id, account_number, account_username, account_password, merchant_id, encryption_key, environment, status)
      VALUES ($1, $2, $3, $4, $5, $6, $7, 2, 'ACTIVE')
      ON CONFLICT (company_id, bank_id) 
      DO UPDATE SET 
        account_number = $3,
        account_username = $4,
        account_password = $5,
        merchant_id = $6,
        encryption_key = $7,
        environment = 2,
        updated_at = CURRENT_TIMESTAMP
    `, [companyId, banecoId, banecoAccount, banecoUsername, banecoPassword, "BANECO_MERCHANT", encryptionKey]);
    console.log("Configurando relación empresa-banco para BNB...");
    await query(`
      INSERT INTO company_bank_configs (company_id, bank_id, account_number, account_username, account_password, merchant_id, encryption_key, environment, status)
      VALUES ($1, $2, '10010000001', 'bnb_user', 'bnb_pass', 'BNB_MERCHANT', $3, 2, 'ACTIVE')
      ON CONFLICT (company_id, bank_id) 
      DO UPDATE SET 
        account_number = '10010000001',
        account_username = 'bnb_user',
        account_password = 'bnb_pass',
        merchant_id = 'BNB_MERCHANT',
        encryption_key = $3,
        environment = 2,
        updated_at = CURRENT_TIMESTAMP
    `, [companyId, bnbId, encryptionKey]);
    console.log("Configurando relación empresa-banco para BISA...");
    await query(`
      INSERT INTO company_bank_configs (company_id, bank_id, account_number, account_username, account_password, merchant_id, encryption_key, environment, status)
      VALUES ($1, $2, '10030000001', 'bisa_user', 'bisa_pass', 'BISA_MERCHANT', $3, 2, 'ACTIVE')
      ON CONFLICT (company_id, bank_id) 
      DO UPDATE SET 
        account_number = '10030000001',
        account_username = 'bisa_user',
        account_password = 'bisa_pass',
        merchant_id = 'BISA_MERCHANT',
        encryption_key = $3,
        environment = 2,
        updated_at = CURRENT_TIMESTAMP
    `, [companyId, bisaId, encryptionKey]);
    console.log("Configuración empresa-banco actualizada para los tres bancos");
    console.log("Creando API key para la empresa...");
    const apiKey = generateApiKey2();
    const permissions = {
      qr: {
        generate: true,
        cancel: true,
        check: true
      },
      payments: {
        list: true
      }
    };
    const expiresAt = new Date;
    expiresAt.setFullYear(expiresAt.getFullYear() + 1);
    await query(`
      INSERT INTO api_keys (api_key, description, company_id, permissions, expires_at, status)
      VALUES ($1, 'API Key de demostración', $2, $3, $4, 'ACTIVE')
      ON CONFLICT (api_key) 
      DO NOTHING
    `, [apiKey, companyId, JSON.stringify(permissions), expiresAt.toISOString()]);
    console.log(`API key generada: ${apiKey}`);
    console.log("Base de datos poblada correctamente.");
  } catch (error3) {
    console.error("Error al poblar la base de datos:", error3);
  } finally {}
}
function generateApiKey2(length = 32) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  const randomValues = new Uint8Array(length);
  crypto.getRandomValues(randomValues);
  for (let i2 = 0;i2 < length; i2++) {
    result += chars.charAt(randomValues[i2] % chars.length);
  }
  return result;
}
seedDatabase();

// src/index.ts
var PORT = process.env.PORT ? parseInt(process.env.PORT) : 3000;
var app = new Elysia().use(import_swagger.swagger({
  documentation: {
    info: {
      title: "API de Pagos con QR",
      version: "1.0.0",
      description: "API para generación y gestión de códigos QR de pago"
    },
    tags: [
      { name: "auth", description: "Endpoints de autenticación" },
      { name: "qr", description: "Endpoints para gestión de códigos QR" },
      { name: "admin", description: "Endpoints de administración" },
      { name: "companies", description: "Endpoints para gestión de empresas" },
      { name: "banks", description: "Endpoints para gestión de bancos" },
      { name: "api-keys", description: "Endpoints para gestión de API keys" }
    ]
  },
  provider: "swagger-ui"
})).use(import_cors.cors({
  origin: () => true,
  credentials: true,
  methods: "*"
})).use(import_cron2.cron({
  name: "monitor-tasks",
  pattern: "0 * * * *",
  run() {
    console.log("⏰ Running scheduled monitoring tasks");
    qr_service_default.updateExpiredQRs();
    qr_service_default.checkExpiringQRs();
  }
})).onError(({ code, error: error3, set: set2 }) => {
  console.error(`Error: ${code}`, error3);
  if (code === "VALIDATION") {
    set2.status = 400;
    return {
      responseCode: 1,
      message: error3.message
    };
  }
  set2.status = 500;
  return {
    responseCode: 1,
    message: "Internal Server Error"
  };
});
app.get("/", () => ({
  status: "online",
  timestamp: new Date().toISOString()
}));
app.use(routes);
async function start() {
  try {
    const args = process.argv.slice(2);
    const command = args[0]?.toLowerCase();
    await testConnection();
    if (command === "init-db" || command === "create-db") {
      console.log("\uD83D\uDDC4️ Inicializando la base de datos...");
      await migrateDB();
      process.exit(0);
    }
    if (command === "seed") {
      console.log("\uD83C\uDF31 Ejecutando seed de la base de datos...");
      await migrateDB();
      await seedDatabase();
      process.exit(0);
    }
    if (!command) {
      initScheduledTasks();
      app.listen(PORT);
      console.log(`\uD83D\uDE80 Servidor iniciado en http://localhost:${PORT}`);
      console.log(`\uD83D\uDCDA Documentación de la API disponible en http://localhost:${PORT}/swagger`);
    } else {
      console.log(`❌ Comando desconocido: ${command}`);
      console.log("Comandos disponibles: init-db, seed");
      process.exit(1);
    }
  } catch (error3) {
    console.error("Error iniciando la aplicación:", error3);
    process.exit(1);
  }
}
start();
